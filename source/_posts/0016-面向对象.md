---
title: 面向对象
date: 2019-02-21 09:44:01
tags:
    - Java
categories:
    - 后端
index_img: https://i.loli.net/2020/08/17/35FZ8rubRnfAKhG.jpg
banner_img: https://i.loli.net/2020/08/17/35FZ8rubRnfAKhG.jpg
---

## 面向对象

### 什么是面向对象

面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。


面向过程(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。


### 面向对象的三大基本特征
面向对象的三个基本特征是：封装、继承、多态。

![](http://www.cnitblog.com/images/cnitblog_com/lily/1972/o_OOBase.gif)

面向对象的三大基本特征和五大基本原则


**封装**

封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。

封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

**继承**

面向对象编程(OOP)语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为**子类**或**派生类**。被继承的类称为**基类**、**父类**或**超类**。

继承的过程，就是从一般到特殊的过程。

要实现继承，可以通过`继承（Inheritance）`和`组合（Composition）`来实现。
在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式有三类：实现继承、接口继承和可视继承。
- 实现继承是指使用基类的属性和方法而无需额外编码的能力；
- 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
- 可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是**属于**关系。例如，`Employee`是一个人，`Manager`也是一个人，因此这两个类都可以继承`Person`类。但是`Leg` 类却不能继承`Person`类，因为腿并不是一个人。

抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 `interface` 而不是`class`。

OO开发范式大致为：划分对象->抽象类->将类组织成为层次化结构(继承和合成) ->用类与实例进行设计和实现几个阶段。

**多态**

多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

实现多态，有二种方式: **覆盖**、**重载**。

- **覆盖**，是指子类重新定义父类的虚函数的做法。
- **重载**，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：`function func(p:integer):integer;`和`function func(p:string):integer;`。那么编译器做过修饰后的函数名称可能是这样的：`int_func`、`str_func`。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”

那么，多态的作用是什么呢？

我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

### 平台无关性

Java是平台无关的语言是指用Java写的应用程序不用修改就可在不同的软硬件平台上运行。平台无关有两种：源代码级和目标代码级。C和C++具有一定程度的源代码级平台无关，表明用C或C++写的应用程序不用修改只需重新编译就可以在不同平台上运行。

Java主要靠Java虚拟机（JVM）在目标码级实现平台无关性。JVM是一种抽象机器，它附着在具体操作系统之上，本身具有一套虚机器指令，并有自己的栈、寄存器组等。但JVM通常是在软件上而不是在硬件上实现。（目前，SUN系统公司已经设计实现了Java芯片，主要使用在网络计算机NC上。另外，Java芯片的出现也会使Java更容易嵌入到家用电器中。）JVM是Java平台无关的基础，在JVM上，有一个Java解释器用来解释Java编译器编译后的程序。Java编程人员在编写完软件后，通过Java编译器将Java源程序编译为JVM的字节代码。任何一台机器只要配备了Java解释器，就可以运行这个程序，而不管这种字节码是在何种平台上生成的（过程如图1所示）。另外，Java采用的是基于IEEE标准的数据类型。通过JVM保证数据类型的一致性，也确保了Java的平台无关性。

Java的平台无关性具有深远意义。首先，它使得编程人员所梦寐以求的事情（开发一次软件在任意平台上运行）变成事实，这将大大加快和促进软件产品的开发。其次Java的平台无关性正好迎合了 "网络计算机 "思想。如果大量常用的应用软件（如字处理软件等）都用Java重新编写，并且放在某个Internet服务器上，那么具有NC的用户将不需要占用大量空间安装软件，他们只需要一个Java解释器，每当需要使用某种应用软件时，下载该软件的字节代码即可，运行结果也可以发回服务器。目前，已有数家公司开始使用这种新型的计算模式构筑自己的企业信息系统。

#### JVM 还支持哪些语言

**Kotlin**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-1-660x344.gif)

官方站点：https://kotlinlang.org/

由JetBrains于2010年创建，并于2012年开源， Kotlin比Java更加简洁和安全。 您完全可以将Kotlin视为是一种“更加简单但高效的Java”。Kotlin的编译速度通常比Java代码快，而且在其创建之初，就非常明确的支持了函数式编程，这一点，Java是到Java 8才开始支持的。

特别的，因为有了Google的加持，越来越多的Android开发人员，开始选择Kotlin来开发应用程序，与此同时，独立的超越JVM的行动也已经在展开，通过一项名为LLVM的项目，Kotlin正在努力实现代码编译的本地化，而不在基于JVM 。

但无论如何，至少现在，它还活在JVM中。

**Scala**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-2-660x274.gif)

官方站点：http://www.scala-lang.org/

和Kotlin一样， Scala也是为了让Java开发人员提高工作效率而创建的。 作为一种完全的面向对象语言和一种完全的函数式编程语言，Scala巧妙的将这两种编程范式结合到了一起。

特别是在函数式编程方面，Scala几乎支持函数式编程语言中所有已知的特性，比如，模式匹配（Pattern matching）、延迟初始化（Lazy initialization）、偏函数（Partial Function）、不变性（Immutability）等等等等，

因此，虽然Scala的类Lisp的语法会让初学者倍感迷惑，但花时间在这上面，永远是值得的，很快，就会让你体会到那种只需要关注 What（做什么），而不用关注How（如何做）的酸爽。

一个最新的关于Scala的消息是，它似乎也在和Kotlin一样，在加速准备逃离JVM的控制，这对于JVM，恐怕不是一个什么特别好的消息，虽然，其距离用于生产可能还为时尚早。


**Clojure**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-3.gif)

官方站点：https://clojure.org/

Clojure是由开发人员Rich Hickey在JVM下，所创建的一种Lisp方言，借助于JVM的执行效率越来越高，Clojure也常被嵌入在Java中，用于编写其中需要高并发、高性能的部分 。


**Groovy**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-4-660x291.gif)

官方站点：http://www.groovy-lang.org/

Groovy是在Java现有基础上，吸收Python和Ruby等动态语言的特性，而创建的一种新型语言，也是Jenkins持续集成服务器，所直接支持的语言之一，并且最关键的一点，通过基于Groovy的Web开发框架Grails，可以快速的完成相关Web项目的构建 。

在未来，Groovy则拟包含Java和JVM的一些更新的特性，比如如Java 8的lambda语法等。

**Jython**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-5.gif)

官方站点：http://www.jython.org/

Jython是JVM的Python实现，与Python的2.x分支兼容，可以动态编译为Java字节码，并且可以与其他JVM语言（特别是Java）自由交互操作。

 **JRuby**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-6-660x206.gif)

官方站点：http://jruby.org

JRuby几乎就是Jython的翻版，所不同的是，JRuby所对标的语言是Ruby，当前所支持的语法规范则和Ruby 2.3兼容。

**Ceylon**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-7.gif)

官方站点：https://www.ceylon-lang.org

这个以大象为Logo的语言，其创建初衷可不是像大象一样笨拙，恰恰相反，语言的创始人 Gavin King，是出于对Java所存在问题的深刻认识，如泛型等特性的复杂性、粗劣的注解语法、不完善的块结构、对 XML 的依赖性等等，才萌生了创建一种新的静态类型语言语言，即Ceylon来一劳永逸的解决这些问题的想法。

Ceylon保留了一些好的 Java 语言特性，改进了语言的可读性和内置的模块性，还吸收了高阶函数等函数语言特性，此外，Ceylon 还融合了 C 和 Smalltalk 的一些特性。与 Java 语言一样，这种新语言也以业务计算为重点，但是它在其他领域也很灵活、很有用。并且，通过这些年的努力，Ceylon已经跨出了其自身跨平台的第一步，其代码已经可以在JVM，Dart VM或Node.js上进行编译或运行。

**Eta**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-8.gif)

官方站点：https://eta-lang.org/

我们的名单中怎么能少了时下最能装酷，也是被Node.js的创建者称为觉得暂无能力驾驭的语言Haskell的JVM实现？

它来了，就是Eta，它的优势，不仅仅在于它可以在JVM下执行，更在于它可以使用Haskell的软件包仓库中的软件包，最大程度的兼容了整个Haskell生态系统。

**Haxe**

![](https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-9.gif)

官方站点：http://haxe.org

Haxe的口号是：One Language，Everywhere！是不是有点熟悉？是的，在非常久远的过去，这其实正是Java的初心。

但是，这二者又是如此的迥异。Java的策略是，我做一个平台JVM，给出一种规范，你们来生成我需要的代码；Haxe的策略则正好相反，既然芸芸众生，语言纷杂，每个人都各有偏好，那好，来吧，我可以把我的代码，生成任何一种你们想要的语言下的代码！

多么疯狂的想法！就为这点疯狂，就值得我们每个开发人员去膜拜一番了，毕竟，在Haxe看来，JVM，不过是其可以编译的一个“小”对象而已。

### 值传递、引用传递

**值传递**：(形式参数类型是基本数据类型)：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。

**引用传递**：(形式参数类型是引用数据类型参数)：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。


说明：

（1）：“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。

（2）：在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java私塾”;


为什么说 Java 中只有值传递: https://blog.csdn.net/bjweimengshu/article/details/79799485




---

> 附参考
>
> - https://www.cnblogs.com/autumn001/p/9036148.html
> - https://blog.csdn.net/B9Q8e64lO6mm/article/details/80235376
>
