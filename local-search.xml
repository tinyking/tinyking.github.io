<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>细说ThreadLocal</title>
    <link href="/2021/07/28/jdk-threadlocal/"/>
    <url>/2021/07/28/jdk-threadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ThreadLocal是什么"><a href="#1-ThreadLocal是什么" class="headerlink" title="1. ThreadLocal是什么"></a>1. ThreadLocal是什么</h2><p>通过源码开头的注释，可以看出 <code>ThreadLocal</code>为线程提供了一个线程本局部变量。它和普通变量不同，是以静态变量的方式来使用，同时又很好地实现了线程隔离。</p><h2 id="2-怎么使用"><a href="#2-怎么使用" class="headerlink" title="2. 怎么使用"></a>2. 怎么使用</h2><h3 id="2-1-官方实例"><a href="#2-1-官方实例" class="headerlink" title="2.1 官方实例"></a>2.1 官方实例</h3><p>同样在源码开头的注释里面，提供了一个使用的例子：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadId</span> </span>&#123;    <span class="hljs-comment">// Atomic integer containing the next thread ID to be assigned</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger nextId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-comment">// Thread local variable containing each thread's ID</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =        <span class="hljs-keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> nextId.getAndIncrement();        &#125;    &#125;;    <span class="hljs-comment">// Returns the current thread's unique ID, assigning it if necessary</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> threadId.get();    &#125;&#125;</code></pre><p>在此例子中，直接使用<code>initialValue</code>的方法为实例进行数据初始化，实现每个线程在使用的过程中，都能获取一个单独的id。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadIdRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        String name = Thread.currentThread().getName();        System.out.println(<span class="hljs-string">"Thread name is "</span> + name + <span class="hljs-string">", threadId is "</span> + get());    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadIdRunnable());    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadIdRunnable());    t1.start();    t2.start();&#125;</code></pre><p>执行结果：</p><pre><code class="hljs undefined">Thread <span class="hljs-built_in">name</span> <span class="hljs-keyword">is</span> Thread<span class="hljs-number">-0</span>, threadId <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>Thread <span class="hljs-built_in">name</span> <span class="hljs-keyword">is</span> Thread<span class="hljs-number">-1</span>, threadId <span class="hljs-keyword">is</span> <span class="hljs-number">1</span></code></pre><h3 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h3><p>日常开发过程中，应用的场景也是比较多。比如：</p><ul><li>request的请求处理的过程中，需要在不同的方法中使用用户的登录信息。</li></ul><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><p>通过源码可以看到，数据是存储在<strong>ThreadLocalMap</strong>中的。<strong>ThreadLocalMap</strong>的是通过Entry数据（Entry[] table）实现的。</p><p><em>Entry</em> 类如下</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        <span class="hljs-keyword">super</span>(k);        value = v;    &#125;&#125;</code></pre><p>总结一下就是，ThreadLocal是由一个名为ThreadLocalMap的哈希映射。哈希映射是由继承了索引用的Entry对象组成的数组。</p><h3 id="3-2-hash计算"><a href="#3-2-hash计算" class="headerlink" title="3.2 hash计算"></a>3.2 hash计算</h3><p>ThreadLocal中的hash和平时创建类的hash code是有区别的。平时创建类时，都是通过重写hashCode方法。</p><p>在ThreadLocal直接使用了一个final变量threadLocalHashCode来表示ThreadLocal实例的hash值，以此值参与后面的逻辑处理。使用AtomicInteger来处理线程安全的问题。</p><p>在使用AtomicInteger生成threadLocalHashCode的过程中，使用了一个特殊的步长值 <code>HASH_INCREMENT = 0x61c88647</code>, 这个值可以实现threadLocalHashCode尽可能均匀的分布在2的N次幂的数组中，降低hash冲突的概率。可以在 <a href="https://www.javaspecialists.eu/archive/Issue164-Why-0x61c88647.html" target="_blank" rel="noopener">Why 0x61c88647?</a> 中找到相关的描述。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();<span class="hljs-comment">/** * The next hash code to be given out. Updated atomically. Starts at * zero. */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode =    <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-comment">/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;<span class="hljs-comment">/** * Returns the next hash code. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);&#125;</code></pre><h2 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4. 线程安全"></a>4. 线程安全</h2><p>ThreadLocal本身并不存储数据，数据实际是存储在使用它的Thread中的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);&#125;<span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;    <span class="hljs-keyword">return</span> t.threadLocals;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);&#125;</code></pre><p>同过为每个线程创建一个独立的ThreadLocalMap，实现数据的多线程隔离。</p><h2 id="5-内存泄漏"><a href="#5-内存泄漏" class="headerlink" title="5. 内存泄漏"></a>5. 内存泄漏</h2><h3 id="5-1-什么是内存泄漏"><a href="#5-1-什么是内存泄漏" class="headerlink" title="5.1 什么是内存泄漏"></a>5.1 什么是内存泄漏</h3><p>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><h3 id="5-2-ThreadLocal的内存泄漏"><a href="#5-2-ThreadLocal的内存泄漏" class="headerlink" title="5.2 ThreadLocal的内存泄漏"></a>5.2 ThreadLocal的内存泄漏</h3><p>很多文章中提到了使用ThreadLocal，可能会产生内存泄漏的，这是为什么呢？</p><p>上面也提到了ThreadLocal实际是为每个线程创建ThreadLocalMap，其引用被线程持有，这也就意味的ThreadLocalMap的生命周期和线程是一致的。线程结束了，ThreadLocalMap在GC的时候也会被回收。那它是怎产生内存泄漏的呢。</p><p>关于这个还是要从线程的使用方面着手分析。</p><p>我们知道线程资源是比较昂贵的，为了减少线程创建的开销，引入了池化技术。线程池有效的解决了复用的问题，减少频繁创建线程的问题。常用的池化技术有线程池，数据库连接池等等。</p><p>但是线程池的复用线程复用也引来了新的问题，那就是线程的生命周期被无限拉长。也就是说ThreadLocalMap也不会被回收了。同一线程不断的使用不同的ThreadLocal实例，而value不释放，从而产生内存泄漏。</p><p>可能有人会说，Entry是实现了WeakReference的，而弱引用在GC的时候会强制被回收的。没错，对于弱引用的确是在GC的时候会被回收的，但是Entry的key是ThreadLocal实例的所引用，也就是或在ThreadLocal实例只有Entry持有的时候，不会产生内存泄漏。</p><p>在实际使用ThreadLocal的过程中，会将其创建为静态变量：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadId</code></pre><p>此时是强引用，在JVM的GC算法中，如果一个对象有它的强引用存在就不会被回收。</p><h3 id="5-3-如何避免"><a href="#5-3-如何避免" class="headerlink" title="5.3 如何避免"></a>5.3 如何避免</h3><p>ThreadLocal提供了remove方法，用来使用value资源。为了避免内存蝎落，需要在线程的业务逻辑结束的时候，主动的调用remove。</p><pre><code class="hljs java"><span class="hljs-comment">/** * Remove the entry for key. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;    Entry[] tab = table;    <span class="hljs-keyword">int</span> len = tab.length;    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (Entry e = tab[i];            e != <span class="hljs-keyword">null</span>;            e = tab[i = nextIndex(i, len)]) &#123;        <span class="hljs-keyword">if</span> (e.get() == key) &#123;            e.clear();            expungeStaleEntry(i);            <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在生产中如何关闭Swagger-ui</title>
    <link href="/2021/06/28/creating-efficient-docker-images-with-spring-boot-2-3/"/>
    <url>/2021/06/28/creating-efficient-docker-images-with-spring-boot-2-3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Swagger用户界面允许我们查看关于REST服务的信息。这对于开发非常方便。然而，出于安全考虑，我们可能不希望在公共环境中允许这种行为。</p><p>在这个简短的教程中，我们将看看如何在生产中摆脱Swagger。</p><h2 id="2-Swagger配置"><a href="#2-Swagger配置" class="headerlink" title="2. Swagger配置"></a>2. Swagger配置</h2><p>为了使用Spring设置Swagger，我们在配置bean中定义它。</p><p>让我们创建一个SwaggerConfig类:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">api</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).select()                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.baeldung"</span>))                .paths(PathSelectors.regex(<span class="hljs-string">"/.*"</span>))                .build();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;        registry.addResourceHandler(<span class="hljs-string">"swagger-ui.html"</span>)                .addResourceLocations(<span class="hljs-string">"classpath:/META-INF/resources/"</span>);        registry.addResourceHandler(<span class="hljs-string">"/webjars/**"</span>)                .addResourceLocations(<span class="hljs-string">"classpath:/META-INF/resources/webjars/"</span>);    &#125;&#125;</code></pre><p>默认情况下，这个配置bean总是被注入到Spring上下文中。因此，Swagger可用于所有环境。</p><p>要在生产中禁用Swagger，让我们切换是否注入这个配置bean。</p><h2 id="3-使用Spring配置文件"><a href="#3-使用Spring配置文件" class="headerlink" title="3.使用Spring配置文件"></a>3.使用Spring配置文件</h2><p>在Spring中，我们可以使用@Profile注释来启用或禁用bean的注入。</p><p>让我们尝试使用SpEL表达来匹配“swagger”的轮廓，而不是“prod”的配置:</p><pre><code class="hljs undefined"><span class="hljs-meta">@Profile(&#123;<span class="hljs-meta-string">"!prod &amp;&amp; swagger"</span>&#125;)</span></code></pre><p>这迫使我们明确的环境，我们想要激活昂首阔步。它还有助于防止在生产中意外地打开它。</p><p>我们可以在配置中添加注释:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Profile</span>(&#123;<span class="hljs-string">"!prod &amp;&amp; swagger"</span>&#125;)<span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    ...&#125;</code></pre><p>现在，让我们用spring.profiles的不同设置启动我们的应用程序来测试它是否工作 spring.profiles.active:</p><pre><code class="hljs undefined">-Dspring<span class="hljs-selector-class">.profiles</span>.active=prod <span class="hljs-comment">// Swagger is disabled</span>-Dspring<span class="hljs-selector-class">.profiles</span>.active=prod,anyOther <span class="hljs-comment">// Swagger is disabled</span>-Dspring<span class="hljs-selector-class">.profiles</span>.active=swagger <span class="hljs-comment">// Swagger is enabled</span>-Dspring<span class="hljs-selector-class">.profiles</span>.active=swagger,anyOtherNotProd <span class="hljs-comment">// Swagger is enabled</span><span class="hljs-attribute">none</span> // Swagger is disabled</code></pre><h2 id="4-使用条件"><a href="#4-使用条件" class="headerlink" title="4. 使用条件"></a>4. 使用条件</h2><p>对于特性切换来说，Spring概要文件可能是一个过于粗粒度的解决方案。这种方法会导致配置错误和冗长的、难以管理的概要文件列表。</p><p>作为另一种选择，我们可以使用@ConditionalOnExpression，它允许为启用bean指定自定义属性:</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnExpression</span>(value = <span class="hljs-string">"$&#123;useSwagger:false&#125;"</span>)<span class="hljs-meta">@EnableSwagger</span>2<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    ...&#125;</code></pre><p>如果“useSwagger”属性丢失，这里的默认值为false。</p><p>要测试这一点，我们可以在应用程序中设置该属性。属性(或application.yaml)文件，或设置为VM选项:</p><pre><code class="hljs undefined"><span class="hljs-attr">-DuseSwagger</span>=<span class="hljs-literal">true</span></code></pre><p>我们应该注意，这个示例没有包含任何保证生产实例不会意外地将useSwagger设置为true的方法。</p><h2 id="5-避免陷阱"><a href="#5-避免陷阱" class="headerlink" title="5. 避免陷阱"></a>5. 避免陷阱</h2><p>如果启用Swagger是一种安全问题，那么我们需要选择一种不会出错但易于使用的策略。</p><p>当我们使用@Profile时，一些SpEL表达可能会违背这些目标:</p><pre><code class="hljs java"><span class="hljs-meta">@Profile</span>(&#123;<span class="hljs-string">"!prod"</span>&#125;) <span class="hljs-comment">// Leaves Swagger enabled by default with no way to disable it in other profiles</span><span class="hljs-meta">@Profile</span>(&#123;<span class="hljs-string">"swagger"</span>&#125;) <span class="hljs-comment">// Allows activating Swagger in prod as well</span><span class="hljs-meta">@Profile</span>(&#123;<span class="hljs-string">"!prod"</span>, <span class="hljs-string">"swagger"</span>&#125;) <span class="hljs-comment">// Equivalent to &#123;"!prod || swagger"&#125; so it's worse than &#123;"!prod"&#125; as it provides a way to activate Swagger in prod too</span></code></pre><p>这就是为什么我们使用@Profile的例子:</p><pre><code class="hljs java"><span class="hljs-meta">@Profile</span>(&#123;<span class="hljs-string">"!prod &amp;&amp; swagger"</span>&#125;)</code></pre><p>这个解决方案可能是最严格的，因为它在默认情况下禁用了Swagger，并保证在“prod”中不能启用它。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>在本文中，我们研究了在生产中禁用Swagger的解决方案。</p><p>我们了解了如何通过@Profile和@ConditionalOnExpression注释来切换打开Swagger的bean。我们还考虑了如何防止错误配置和不希望看到的默认值。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Jackson的两个Json对象进行比较</title>
    <link href="/2020/08/24/jackson-compare-two-json-objects/"/>
    <url>/2020/08/24/jackson-compare-two-json-objects/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本文中，我们将使用Jackson—一个用于Java的JSON处理库来比较两个JSON对象。</p><h2 id="2-Maven依赖"><a href="#2-Maven依赖" class="headerlink" title="2. Maven依赖"></a>2. Maven依赖</h2><p>首先，让我们添加jackson-databind Maven依赖:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="3-使用Jackson比较两个JSON对象"><a href="#3-使用Jackson比较两个JSON对象" class="headerlink" title="3.使用Jackson比较两个JSON对象"></a>3.使用Jackson比较两个JSON对象</h2><p>我们将使用ObjectMapper类来读取作为JsonNode的对象。</p><p>让我们创建一个ObjectMapper:</p><pre><code class="hljs java">ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();</code></pre><h3 id="3-1-比较两个简单的JSON对象"><a href="#3-1-比较两个简单的JSON对象" class="headerlink" title="3.1. 比较两个简单的JSON对象"></a>3.1. 比较两个简单的JSON对象</h3><p>让我们从使用JsonNode.equals方法开始。equals()方法执行一个完整的(深度的)比较。</p><p>假设我们有一个JSON字符串定义为s1变量:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"employee"</span>:    &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1212"</span>,        <span class="hljs-attr">"fullName"</span>: <span class="hljs-string">"John Miles"</span>,        <span class="hljs-attr">"age"</span>: <span class="hljs-number">34</span>    &#125;&#125;</code></pre><p>我们要和另一个JSON s2比较</p><pre><code class="hljs json">&#123;       <span class="hljs-attr">"employee"</span>:    &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1212"</span>,        <span class="hljs-attr">"age"</span>: <span class="hljs-number">34</span>,        <span class="hljs-attr">"fullName"</span>: <span class="hljs-string">"John Miles"</span>    &#125;&#125;</code></pre><p>让我们将输入的JSON读取为JsonNode并进行比较:</p><pre><code class="hljs java">assertEquals(mapper.readTree(s1), mapper.readTree(s2));</code></pre><p>需要注意的是，即使输入JSON变量s1和s2中的属性顺序不相同，equals()方法也会忽略顺序，并将它们视为相等的。</p><h3 id="3-2-比较两个嵌套元素的JSON对象"><a href="#3-2-比较两个嵌套元素的JSON对象" class="headerlink" title="3.2. 比较两个嵌套元素的JSON对象"></a>3.2. 比较两个嵌套元素的JSON对象</h3><p>接下来，我们将了解如何比较两个嵌套元素的JSON对象。</p><p>让我们从定义为s1变量的JSON开始:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"employee"</span>:    &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1212"</span>,        <span class="hljs-attr">"fullName"</span>:<span class="hljs-string">"John Miles"</span>,        <span class="hljs-attr">"age"</span>: <span class="hljs-number">34</span>,        <span class="hljs-attr">"contact"</span>:        &#123;            <span class="hljs-attr">"email"</span>: <span class="hljs-string">"john@xyz.com"</span>,            <span class="hljs-attr">"phone"</span>: <span class="hljs-string">"9999999999"</span>        &#125;    &#125;&#125;</code></pre><p>我们可以看到，JSON包含一个嵌套的元素contact。我们想将它与s2定义的另一个JSON进行比较:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"employee"</span>:    &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1212"</span>,        <span class="hljs-attr">"age"</span>: <span class="hljs-number">34</span>,        <span class="hljs-attr">"fullName"</span>: <span class="hljs-string">"John Miles"</span>,        <span class="hljs-attr">"contact"</span>:        &#123;            <span class="hljs-attr">"email"</span>: <span class="hljs-string">"john@xyz.com"</span>,            <span class="hljs-attr">"phone"</span>: <span class="hljs-string">"9999999999"</span>        &#125;    &#125;&#125;</code></pre><p>让我们将输入的JSON读取为JsonNode并进行比较:</p><pre><code class="hljs java">assertEquals(mapper.readTree(s1), mapper.readTree(s2));</code></pre><p>同样，我们应该注意到equals()还可以比较具有嵌套元素的两个输入JSON对象。</p><h3 id="3-3-比较包含列表元素的两个JSON对象"><a href="#3-3-比较包含列表元素的两个JSON对象" class="headerlink" title="3.3. 比较包含列表元素的两个JSON对象"></a>3.3. 比较包含列表元素的两个JSON对象</h3><p>类似地，我们还可以比较包含list元素的两个JSON对象。</p><p>让我们考虑这个JSON定义为s1:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"employee"</span>:    &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1212"</span>,        <span class="hljs-attr">"fullName"</span>: <span class="hljs-string">"John Miles"</span>,        <span class="hljs-attr">"age"</span>: <span class="hljs-number">34</span>,        <span class="hljs-attr">"skills"</span>: [<span class="hljs-string">"Java"</span>, <span class="hljs-string">"C++"</span>, <span class="hljs-string">"Python"</span>]    &#125;&#125;</code></pre><p>我们将它与另一个JSON s2进行比较:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"employee"</span>:    &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1212"</span>,        <span class="hljs-attr">"age"</span>: <span class="hljs-number">34</span>,        <span class="hljs-attr">"fullName"</span>: <span class="hljs-string">"John Miles"</span>,        <span class="hljs-attr">"skills"</span>: [<span class="hljs-string">"Java"</span>, <span class="hljs-string">"C++"</span>, <span class="hljs-string">"Python"</span>]    &#125;&#125;</code></pre><p>让我们将输入的JSON读取为JsonNode并进行比较:</p><pre><code class="hljs java">assertEquals(mapper.readTree(s1), mapper.readTree(s2));</code></pre><p>重要的是要知道，只有当两个列表元素具有完全相同的顺序的相同值时，才会将它们作为相等进行比较。</p><h2 id="4-使用自定义比较器比较两个JSON对象"><a href="#4-使用自定义比较器比较两个JSON对象" class="headerlink" title="4. 使用自定义比较器比较两个JSON对象"></a>4. 使用自定义比较器比较两个JSON对象</h2><p>JsonNode.equals在大多数情况下都很好用。Jackson还提供了JsonNode.equals(comparator, JsonNode)来配置定制的Java比较器对象。让我们了解如何使用自定义比较器。</p><h3 id="4-1-自定义比较器来比较数值"><a href="#4-1-自定义比较器来比较数值" class="headerlink" title="4.1. 自定义比较器来比较数值"></a>4.1. 自定义比较器来比较数值</h3><p>让我们了解如何使用自定义比较器来比较两个具有数值的JSON元素。</p><p>我们将使用这个JSON作为输入s1:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John"</span>,    <span class="hljs-attr">"score"</span>: <span class="hljs-number">5.0</span>&#125;</code></pre><p>让我们比较另一个定义为s2的JSON:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John"</span>,    <span class="hljs-attr">"score"</span>: <span class="hljs-number">5</span>&#125;</code></pre><p>我们需要注意，输入s1和s2中的属性分数值是不一样的。</p><p>让我们将输入的JSON读取为JsonNode并进行比较:</p><pre><code class="hljs java">JsonNode actualObj1 = mapper.readTree(s1);JsonNode actualObj2 = mapper.readTree(s2);assertNotEquals(actualObj1, actualObj2);</code></pre><p>我们可以注意到，这两个对象是不相等的。standard equals()方法认为值5.0和5是不同的。</p><p>但是，我们可以使用自定义的比较器来比较值5和5.0，并将它们同等对待。</p><p>让我们首先创建一个比较器来比较两个NumericNode对象:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumericNodeComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">JsonNode</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(JsonNode o1, JsonNode o2)</span>    </span>&#123;        <span class="hljs-keyword">if</span> (o1.equals(o2))&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> ((o1 <span class="hljs-keyword">instanceof</span> NumericNode) &amp;&amp; (o2 <span class="hljs-keyword">instanceof</span> NumericNode))&#123;            Double d1 = ((NumericNode) o1).asDouble();            Double d2 = ((NumericNode) o2).asDouble();            <span class="hljs-keyword">if</span> (d1.compareTo(d2) == <span class="hljs-number">0</span>) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>接下来，让我们看看如何使用这个比较器:</p><pre><code class="hljs java">NumericNodeComparator cmp = <span class="hljs-keyword">new</span> NumericNodeComparator();assertTrue(actualObj1.equals(cmp, actualObj2));</code></pre><h3 id="4-2-自定义比较器来比较文本值"><a href="#4-2-自定义比较器来比较文本值" class="headerlink" title="4.2. 自定义比较器来比较文本值"></a>4.2. 自定义比较器来比较文本值</h3><p>让我们看另一个自定义比较器的示例，用于对两个JSON值进行不区分大小写的比较。</p><p>我们将使用这个JSON作为输入s1:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"john"</span>,    <span class="hljs-attr">"score"</span>: <span class="hljs-number">5</span>&#125;</code></pre><p>让我们比较另一个定义为s2的JSON:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"JOHN"</span>,    <span class="hljs-attr">"score"</span>: <span class="hljs-number">5</span>&#125;</code></pre><p>正如我们看到的那样，属性名在输入s1中是小写的，在s2中是大写的。</p><p>让我们首先创建一个比较器来比较两个TextNode对象:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextNodeComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">JsonNode</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(JsonNode o1, JsonNode o2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o1.equals(o2)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span> ((o1 <span class="hljs-keyword">instanceof</span> TextNode) &amp;&amp; (o2 <span class="hljs-keyword">instanceof</span> TextNode)) &#123;            String s1 = ((TextNode) o1).asText();            String s2 = ((TextNode) o2).asText();            <span class="hljs-keyword">if</span> (s1.equalsIgnoreCase(s2)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>让我们看看如何比较s1和s2使用TextNodeComparator:</p><pre><code class="hljs java">JsonNode actualObj1 = mapper.readTree(s1);JsonNode actualObj2 = mapper.readTree(s2);TextNodeComparator cmp = <span class="hljs-keyword">new</span> TextNodeComparator();assertNotEquals(actualObj1, actualObj2);assertTrue(actualObj1.equals(cmp, actualObj2));</code></pre><p>最后，我们可以看到，在比较两个JSON对象时，使用自定义的comparator对象非常有用，因为输入的JSON元素值并不完全相同，但我们仍然希望将它们同等对待。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在这个快速教程中，我们了解了如何使用Jackson来比较两个JSON对象以及如何使用自定义比较器。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Spring 5中设置响应头</title>
    <link href="/2020/08/18/spring-response-header/"/>
    <url>/2020/08/18/spring-response-header/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在这个快速教程中，我们将介绍在服务响应上设置头的不同方法，无论是针对非反应性端点，还是针对使用Spring 5 WebFlux框架的api。</p><p>我们可以在以前的文章中找到关于这个框架的更多信息。</p><h2 id="2-非反应性组件的header"><a href="#2-非反应性组件的header" class="headerlink" title="2. 非反应性组件的header"></a>2. 非反应性组件的header</h2><p>如果我们想设置单个响应的头，我们可以使用HttpServletResponse或ResponseEntity对象。</p><p>另一方面，如果我们的目标是向所有或多个响应添加一个过滤器，则需要配置一个过滤器。</p><h3 id="2-1-使用HttpServletResponse"><a href="#2-1-使用HttpServletResponse" class="headerlink" title="2.1. 使用HttpServletResponse"></a>2.1. 使用HttpServletResponse</h3><p>我们只需将HttpServletResponse对象作为参数添加到REST端点，然后使用addHeader()方法:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/http-servlet-response"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">usingHttpServletResponse</span><span class="hljs-params">(HttpServletResponse response)</span> </span>&#123;    response.addHeader(<span class="hljs-string">"Baeldung-Example-Header"</span>, <span class="hljs-string">"Value-HttpServletResponse"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"Response with header using HttpServletResponse"</span>;&#125;</code></pre><p>如示例中所示，我们不必返回响应对象。</p><h3 id="2-2-使用ResponseEntity"><a href="#2-2-使用ResponseEntity" class="headerlink" title="2.2. 使用ResponseEntity"></a>2.2. 使用ResponseEntity</h3><p>在这种情况下，让我们使用ResponseEntity类提供的BodyBuilder:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/response-entity-builder-with-http-headers"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">usingResponseEntityBuilderAndHttpHeaders</span><span class="hljs-params">()</span> </span>&#123;    HttpHeaders responseHeaders = <span class="hljs-keyword">new</span> HttpHeaders();    responseHeaders.set(<span class="hljs-string">"Baeldung-Example-Header"</span>,      <span class="hljs-string">"Value-ResponseEntityBuilderWithHttpHeaders"</span>);    <span class="hljs-keyword">return</span> ResponseEntity.ok()      .headers(responseHeaders)      .body(<span class="hljs-string">"Response with header using ResponseEntity"</span>);&#125;</code></pre><p>HttpHeaders类提供了许多方便的方法来设置最常见的头信息。</p><h3 id="2-3-为所有响应添加header"><a href="#2-3-为所有响应添加header" class="headerlink" title="2.3. 为所有响应添加header"></a>2.3. 为所有响应添加header</h3><p>现在假设我们想要为许多端点设置一个特定的头。</p><p>当然，如果我们必须在每个映射方法上复制前面的代码，那将是令人沮丧的。</p><p>更好的方法是在我们的服务中配置一个过滤器:</p><pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span>(<span class="hljs-string">"/filter-response-header/*"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddResponseHeaderFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,      FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        HttpServletResponse httpServletResponse = (HttpServletResponse) response;        httpServletResponse.setHeader(          <span class="hljs-string">"Baeldung-Example-Filter-Header"</span>, <span class="hljs-string">"Value-Filter"</span>);        chain.doFilter(request, response);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre><p>@WebFilter注释允许我们指出这个过滤器将对哪些urlPatterns有效。</p><p>正如我们在本文中指出的，为了让我们的过滤器被Spring发现，我们需要在Spring应用程序类中添加@ServletComponentScan注释:</p><pre><code class="hljs java"><span class="hljs-meta">@ServletComponentScan</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseHeadersApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ResponseHeadersApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>如果我们不需要@WebFilter提供的任何功能，我们可以通过在过滤器类中使用@Component注释来避免这最后一步。</p><h2 id="3-响应性header"><a href="#3-响应性header" class="headerlink" title="3.响应性header"></a>3.响应性header</h2><p>同样，我们将看到如何使用ServerHttpResponse、ResponseEntity或ServerResponse(针对功能性端点)类和接口在单个端点响应上设置报头。</p><p>我们还将学习如何实现一个Spring 5 WebFilter来在所有的响应中添加一个头。</p><h3 id="3-1-使用ServerHttpResponse"><a href="#3-1-使用ServerHttpResponse" class="headerlink" title="3.1. 使用ServerHttpResponse"></a>3.1. 使用ServerHttpResponse</h3><p>此方法与对应的HttpServletResponse非常相似:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/server-http-response"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">usingServerHttpResponse</span><span class="hljs-params">(ServerHttpResponse response)</span> </span>&#123;    response.getHeaders().add(<span class="hljs-string">"Baeldung-Example-Header"</span>, <span class="hljs-string">"Value-ServerHttpResponse"</span>);    <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">"Response with header using ServerHttpResponse"</span>);&#125;</code></pre><h3 id="3-2-使用ResponseEntity"><a href="#3-2-使用ResponseEntity" class="headerlink" title="3.2. 使用ResponseEntity"></a>3.2. 使用ResponseEntity</h3><p>我们可以使用ResponseEntity类，就像我们做的非反应端点:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/response-entity"</span>)<span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;String&gt;&gt; usingResponseEntityBuilder() &#123;    String responseHeaderKey = <span class="hljs-string">"Baeldung-Example-Header"</span>;    String responseHeaderValue = <span class="hljs-string">"Value-ResponseEntityBuilder"</span>;    String responseBody = <span class="hljs-string">"Response with header using ResponseEntity (builder)"</span>;    <span class="hljs-keyword">return</span> Mono.just(ResponseEntity.ok()      .header(responseHeaderKey, responseHeaderValue)      .body(responseBody));&#125;</code></pre><h3 id="3-3-使用-ServerResponse"><a href="#3-3-使用-ServerResponse" class="headerlink" title="3.3. 使用 ServerResponse"></a>3.3. 使用 ServerResponse</h3><p>最后两小节中介绍的类和接口可以在@Controller注释类中使用，但不适合新的Spring 5 Functional Web框架。</p><p>如果我们想在HandlerFunction上设置一个头，那么我们需要得到ServerResponse接口:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">useHandler</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ServerRequest request)</span> </span>&#123;     <span class="hljs-keyword">return</span> ServerResponse.ok()        .header(<span class="hljs-string">"Baeldung-Example-Header"</span>, <span class="hljs-string">"Value-Handler"</span>)        .body(Mono.just(<span class="hljs-string">"Response with header using Handler"</span>),String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><h3 id="3-4-为所有响应添加header"><a href="#3-4-为所有响应添加header" class="headerlink" title="3.4. 为所有响应添加header"></a>3.4. 为所有响应添加header</h3><p>最后，Spring 5提供了一个WebFilter接口来为服务检索到的所有响应设置一个头:</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddResponseHeaderWebFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebFilter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title">filter</span><span class="hljs-params">(ServerWebExchange exchange, WebFilterChain chain)</span> </span>&#123;        exchange.getResponse()          .getHeaders()          .add(<span class="hljs-string">"Baeldung-Example-Filter-Header"</span>, <span class="hljs-string">"Value-Filter"</span>);        <span class="hljs-keyword">return</span> chain.filter(exchange);    &#125;&#125;</code></pre><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>总之,我们学到许多不同的方式设置一个头的反应,如果我们想要把它放在一个端点或如果我们想配置所有rest api,即使我们迁移活性堆栈,现在我们有知识做所有这些事情。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux和Spring中Cron语法的区别</title>
    <link href="/2020/08/17/cron-syntax-linux-vs-spring/"/>
    <url>/2020/08/17/cron-syntax-linux-vs-spring/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Cron表达式使我们能够安排任务在特定的日期和时间周期性地运行。在Unix中引入它之后，其他基于Unix的操作系统和软件库(包括Spring框架)采用了它的方法进行任务调度。</p><p>在这个快速教程中，我们将了解基于unix的操作系统中的Cron表达式与Spring框架之间的区别。</p><h2 id="2-Unix-Cron"><a href="#2-Unix-Cron" class="headerlink" title="2. Unix Cron"></a>2. Unix Cron</h2><p>在大多数基于unix的系统中，Cron有5个字段:分钟(0-59)、小时(0-23)、月份(1-31)、月份(1-12或名称)和星期(0-7或名称)。</p><p>我们可以在每个字段中添加一些特殊的值，比如星号(*):</p><pre><code class="hljs undefined"><span class="hljs-symbol">5 </span><span class="hljs-number">0</span> * * *</code></pre><p>该任务将在每天午夜后5分钟执行。也可以使用一系列的值:</p><pre><code class="hljs undefined"><span class="hljs-symbol">5 </span><span class="hljs-number">0</span>-<span class="hljs-number">5</span> * * *</code></pre><p>在这里，调度器将在午夜后5分钟执行任务，也将在每天1、2、3、4和5点后5分钟执行任务。</p><p>或者，我们可以使用一个值列表:</p><pre><code class="hljs undefined"><span class="hljs-symbol">5 </span><span class="hljs-number">0</span>,<span class="hljs-number">3</span> * * *</code></pre><p>现在调度器每天在午夜后5分钟和3点后5分钟执行作业。原始的Cron表达式提供了比我们到目前为止介绍的更多的特性。</p><p>但是，它有一个很大的限制:我们不能用第二个精度调度作业，因为它没有专门的第二个字段。</p><p>让我们看看Spring是如何修复这个限制的。</p><h2 id="3-Spring-Cron"><a href="#3-Spring-Cron" class="headerlink" title="3. Spring Cron"></a>3. Spring Cron</h2><p>为了在Spring中定期调度后台任务，我们通常将Cron表达式传递给@Scheduled注释。</p><p>与基于unix的系统中的Cron表达式不同，Spring中的Cron表达式有6个空格分隔的字段:秒、分钟、小时、日、月和工作日。</p><p>例如，每十秒钟运行一个任务，我们可以做:</p><pre><code class="hljs undefined"><span class="hljs-emphasis">*/10 *</span> <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">* *</span></code></pre><p>此外，每20秒运行一个任务，从早上8点到每天10m:</p><pre><code class="hljs undefined">*/<span class="hljs-number">20</span> * <span class="hljs-number">8</span><span class="hljs-number">-10</span> * * *</code></pre><p>如上例所示，第一个字段表示表达式的第二部分。这就是两种实现之间的区别。尽管第二个字段不同，但Spring支持来自原始Cron的许多特性，比如范围号或列表。</p><p>从实现的角度来看，CronSequenceGenerator类负责在Spring中解析Cron表达式。</p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>在这个简短的教程中，我们看到了Spring和大多数基于unix的系统之间Cron实现的差异。在这个过程中，我们看到了这两种实现的一些示例。</p><p>为了查看更多Cron表达式示例，强烈建议查看我们的Cron表达式指南。此外，查看CronSequenceGenerator类的源代码可以让我们更好地了解Spring是如何实现这个特性的。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>REST API错误处理的最佳实践</title>
    <link href="/2020/08/17/rest-api-error-handling-best-practices/"/>
    <url>/2020/08/17/rest-api-error-handling-best-practices/</url>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>REST是一种无状态的架构，客户端可以在其中访问和操作服务器上的资源。通常，REST服务利用HTTP发布它们管理的一组资源，并提供允许客户机获取或更改这些资源状态的API。</p><p>在本教程中，我们将学习处理REST API错误的一些最佳实践，包括为用户提供相关信息的有用方法、来自大型网站的示例以及使用示例Spring REST应用程序的具体实现。</p><h2 id="2-HTTP状态码"><a href="#2-HTTP状态码" class="headerlink" title="2. HTTP状态码"></a>2. HTTP状态码</h2><p>当客户端向HTTP服务器发出请求时——服务器成功接收到请求——服务器必须通知客户端请求是否被成功处理。HTTP完成这与五类状态代码:</p><ul><li>10x(信息性): 服务器确认请求</li><li>20x(成功): 服务器按预期完成请求</li><li>30x(重定向): 客户端需要执行进一步的操作来完成请求</li><li>40x(客户端错误): 客户端发送了一个无效的请求</li><li>50x(服务器错误): 服务器由于服务器错误而无法满足有效请求</li></ul><p>客户端可以根据响应代码推测特定请求的结果。</p><h2 id="3-处理错误"><a href="#3-处理错误" class="headerlink" title="3.处理错误"></a>3.处理错误</h2><p>处理错误的第一步是向客户机提供正确的状态码。此外，我们可能需要在响应体中提供更多信息。</p><h3 id="3-1-基本响应"><a href="#3-1-基本响应" class="headerlink" title="3.1 基本响应"></a>3.1 基本响应</h3><p>处理错误最简单的方法是使用适当的状态码进行响应。</p><p>一些常见的回应码包括:</p><ul><li>400错误的请求: 客户端发送了一个无效的请求,例如缺少必需的请求体或参数</li><li>401未经授权: 客户端对服务器进行身份验证失败</li><li>403禁止: 经过身份验证的客户端，但没有访问请求资源的权限</li><li>404未找到: 所请求的资源不存在</li><li>412先决条件失败: 请求头字段中的一个或多个条件被评估为false</li><li>500内部服务器错误: 一个通用错误发生在服务器上</li><li>503服务不可用: 所请求的服务不可用</li></ul><p>虽然很基本，但这些代码允许客户机了解所发生错误的广泛性质。例如，我们知道如果我们收到一个403错误，说明我们没有权限访问我们请求的资源。</p><p>然而，在许多情况下，我们需要在我们的答复中提供补充细节。</p><p>500错误表明服务器在处理请求时发生了一些问题或异常。一般来说，这个内部错误与我们的客户无关。</p><p>因此，为了尽量减少对客户机的响应，我们应该努力尝试处理或捕获内部错误，并在可能的情况下使用其他适当的状态代码进行响应。例如，如果由于请求的资源不存在而发生异常，我们应该将其公开为404错误，而不是500错误。</p><p>这并不是说不应该返回500，而是说应该将其用于阻止服务器执行请求的意外情况(如服务中断)。</p><h3 id="3-2-默认Spring错误响应"><a href="#3-2-默认Spring错误响应" class="headerlink" title="3.2. 默认Spring错误响应"></a>3.2. 默认Spring错误响应</h3><p>这些原则是如此普遍，以至于Spring已经在其默认的错误处理机制中编写了它们。</p><p>为了演示，假设我们有一个简单的Spring REST应用程序，它管理图书，有一个端点根据ID检索图书:</p><pre><code class="hljs undefined">curl -X GET -H <span class="hljs-string">"Accept: application/json"</span> http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8082</span><span class="hljs-regexp">/spring-rest/</span>api<span class="hljs-regexp">/book/</span><span class="hljs-number">1</span></code></pre><p>如果没有ID为1的书，我们期望控制器会抛出BookNotFoundException异常。在这个端点上执行GET，我们看到这个异常被抛出，响应体为:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"timestamp"</span>:<span class="hljs-string">"2019-09-16T22:14:45.624+0000"</span>,    <span class="hljs-attr">"status"</span>:<span class="hljs-number">500</span>,    <span class="hljs-attr">"error"</span>:<span class="hljs-string">"Internal Server Error"</span>,    <span class="hljs-attr">"message"</span>:<span class="hljs-string">"No message available"</span>,    <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/api/book/1"</span>&#125;</code></pre><p>注意，这个默认的错误处理程序包括错误发生时的时间戳、HTTP状态代码、标题(错误字段)、消息(默认为空)和错误发生时的URL路径。</p><p>这些字段为客户端或开发人员提供信息，以帮助解决问题，还构成了标准错误处理机制的一些字段。</p><p>另外，请注意，当BookNotFoundException被抛出时，Spring会自动返回一个HTTP状态码为500。尽管有些api会返回500状态码或其他通用代码，正如我们将在Facebook和Twitter api中看到的那样——为了简单起见，对于所有错误，最好尽可能使用最具体的错误代码。</p><p>在我们的示例中，我们可以添加一个@ControllerAdvice，这样当BookNotFoundException被抛出时，我们的API会返回一个状态404，表示没有找到，而不是500内部服务器错误。</p><h3 id="3-3-更多的响应细节"><a href="#3-3-更多的响应细节" class="headerlink" title="3.3. 更多的响应细节"></a>3.3. 更多的响应细节</h3><p>正如在上面的Spring示例中看到的，有时状态代码不足以显示错误的细节。在需要时，我们可以使用响应体向客户机提供附加信息。在提供详细回应时，我们应包括:</p><ul><li>错误：错误的唯一标识符</li><li>消息：一个简短的人类可读的消息</li><li>细节: 对错误的更长的解释</li></ul><p>例如，如果客户端发送了一个带有错误凭据的请求，我们可以发送一个包含以下内容的401响应:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"auth-0001"</span>,    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Incorrect username and password"</span>,    <span class="hljs-attr">"detail"</span>: <span class="hljs-string">"Ensure that the username and password included in the request are correct"</span>&#125;</code></pre><p>错误字段不应该与响应代码匹配。相反，它应该是应用程序特有的错误代码。通常，错误字段没有约定，希望它是唯一的。</p><p>通常，该字段只包含字母数字和连接字符，如破折号或下划线。例如，0001、auth-0001和incorrect-user-pass都是错误代码的典型示例。</p><p>通常认为主体的消息部分在用户界面上是可显示的。因此，如果我们支持国际化，就应该翻译这个标题。因此，如果客户端发送一个带有对应于法语的Accept-Language头的请求，则title值应该被翻译成法语。</p><p>细节部分是为客户端的开发人员而不是最终用户使用的，因此不需要进行翻译。</p><p>此外，我们还可以提供一个URL -如帮助字段-客户可以跟踪发现更多的信息:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"auth-0001"</span>,    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Incorrect username and password"</span>,    <span class="hljs-attr">"detail"</span>: <span class="hljs-string">"Ensure that the username and password included in the request are correct"</span>,    <span class="hljs-attr">"help"</span>: <span class="hljs-string">"https://example.com/help/error/auth-0001"</span>&#125;</code></pre><p>有时，我们可能希望为一个请求报告多个错误。在这种情况下，我们应该返回一个列表中的错误:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"errors"</span>: [        &#123;            <span class="hljs-attr">"error"</span>: <span class="hljs-string">"auth-0001"</span>,            <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Incorrect username and password"</span>,            <span class="hljs-attr">"detail"</span>: <span class="hljs-string">"Ensure that the username and password included in the request are correct"</span>,            <span class="hljs-attr">"help"</span>: <span class="hljs-string">"https://example.com/help/error/auth-0001"</span>        &#125;,        ...    ]&#125;</code></pre><p>当出现单个错误时，我们使用包含一个元素的列表进行响应。注意，对于简单的应用程序来说，响应多个错误可能过于复杂。在许多情况下，使用第一个或最重要的错误来响应就足够了。</p><h3 id="3-4-标准响应体"><a href="#3-4-标准响应体" class="headerlink" title="3.4. 标准响应体"></a>3.4. 标准响应体</h3><p>虽然大多数REST api遵循类似的约定，但具体细节通常不同，包括字段的名称和响应体中包含的信息。这些差异使得库和框架很难统一地处理错误。</p><p>为了标准化REST API错误处理，IETF设计了RFC 7807，它创建了一个通用的错误处理模式。</p><p>这个方案由五部分组成:</p><ul><li>type — 对错误进行分类的URI标识符</li><li>title — 一个简短的、人类可读的关于错误的消息</li><li>status — HTTP响应码</li><li>detail — 错误信息</li><li>instance — 标识错误发生的特定位置的URI</li></ul><p>而不是使用我们的自定义错误响应体，我们可以转换响应:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"/errors/incorrect-user-pass"</span>,    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Incorrect username or password."</span>,    <span class="hljs-attr">"status"</span>: <span class="hljs-number">401</span>,    <span class="hljs-attr">"detail"</span>: <span class="hljs-string">"Authentication failed due to incorrect username or password."</span>,    <span class="hljs-attr">"instance"</span>: <span class="hljs-string">"/login/log/abc123"</span>&#125;</code></pre><p>请注意，type字段对错误类型进行分类，而instance分别以类似于类和对象的方式标识错误的特定发生。</p><p>通过使用uri，客户机可以按照这些路径查找有关错误的更多信息，就像使用HATEOAS链接导航REST API一样。</p><h2 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h2><p>上述实践在一些最流行的REST api中很常见。虽然字段或格式的具体名称可能在不同的站点之间有所不同，但一般的模式几乎是通用的。</p><h3 id="4-1-Twitter"><a href="#4-1-Twitter" class="headerlink" title="4.1. Twitter"></a>4.1. Twitter</h3><p>例如，让我们发送一个GET请求而不提供必需的身份验证数据:</p><pre><code class="hljs undefined">curl -<span class="hljs-keyword">X</span> GET http<span class="hljs-variable">s:</span>//api.twitter.<span class="hljs-keyword">com</span>/<span class="hljs-number">1.1</span>/statuses/<span class="hljs-keyword">update</span>.json?include_entities=true</code></pre><p>Twitter API响应一个错误，如下正文:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"errors"</span>: [        &#123;            <span class="hljs-attr">"code"</span>:<span class="hljs-number">215</span>,            <span class="hljs-attr">"message"</span>:<span class="hljs-string">"Bad Authentication data."</span>        &#125;    ]&#125;</code></pre><p>此响应包括一个包含单个错误的列表，以及错误代码和消息。在Twitter的例子中，没有详细的信息，并且使用一个普遍的错误——而不是更具体的401错误——来表示认证失败。</p><p>有时更通用的状态代码更容易实现，我们将在下面的Spring示例中看到这一点。它允许开发人员捕获异常组，而不区分应该返回的状态代码。但是，在可能的情况下，应该使用最特定的状态代码。</p><h3 id="4-2-Facebook"><a href="#4-2-Facebook" class="headerlink" title="4.2. Facebook"></a>4.2. Facebook</h3><p>与Twitter类似，Facebook的Graph REST API也在响应中包含详细信息。</p><p>例如，让我们用Facebook Graph API执行一个POST请求来验证:</p><pre><code class="hljs undefined">curl -X GET https:<span class="hljs-regexp">//g</span>raph.facebook.com<span class="hljs-regexp">/oauth/</span>access_token?client_id=foo&amp;client_secret=bar&amp;grant_type=baz</code></pre><p>我们收到以下错误:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"error"</span>: &#123;        <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Missing redirect_uri parameter."</span>,        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"OAuthException"</span>,        <span class="hljs-attr">"code"</span>: <span class="hljs-number">191</span>,        <span class="hljs-attr">"fbtrace_id"</span>: <span class="hljs-string">"AWswcVwbcqfgrSgjG80MtqJ"</span>    &#125;&#125;</code></pre><p>像Twitter一样，Facebook也使用通用错误——而不是更具体的400级错误——来表示失败。除了消息和数字代码外，Facebook还包括一个类型字段，用于对错误进行分类，以及一个作为内部支持标识符的跟踪ID (fbtrace_id)。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本文中，我们研究了一些REST API错误处理的最佳实践，包括:</p><ul><li>提供特定状态码</li><li>在响应主体中包括附加信息</li><li>以统一的方式处理异常</li></ul><p>虽然错误处理的细节因应用程序而异，但这些通用原则几乎适用于所有REST api，并且应该尽可能遵守。</p><p>这不仅允许客户机以一致的方式处理错误，而且还简化了我们在实现REST API时创建的代码。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Spring REST Controller中获取header信息</title>
    <link href="/2020/08/17/spring-rest-http-headers/"/>
    <url>/2020/08/17/spring-rest-http-headers/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在这个快速教程中，我们将了解如何在Spring Rest控制器中访问HTTP头信息。</p><p>首先，我们将使用@RequestHeader注释分别读取头信息，也可以一起读取头信息。</p><p>之后，我们将深入了解@RequestHeader的属性。</p><h2 id="2-访问HTTP头"><a href="#2-访问HTTP头" class="headerlink" title="2. 访问HTTP头"></a>2. 访问HTTP头</h2><h3 id="2-1-简单方法"><a href="#2-1-简单方法" class="headerlink" title="2.1. 简单方法"></a>2.1. 简单方法</h3><p>如果我们需要访问一个特定的标题，我们可以配置@RequestHeader的标题名称:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/greeting"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">greeting</span><span class="hljs-params">(@RequestHeader(<span class="hljs-string">"accept-language"</span>)</span> String language) </span>&#123;    <span class="hljs-comment">// code that uses the language variable</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(greeting, HttpStatus.OK);&#125;</code></pre><p>然后，我们可以使用传入方法的变量来访问值。如果在请求中没有找到名为accept-language的头，该方法将返回一个“400 Bad request”错误。</p><p>我们的头不必是字符串。例如，如果我们知道我们的头是一个数字，我们可以声明我们的变量为数值类型:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/double"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">doubleNumber</span><span class="hljs-params">(@RequestHeader(<span class="hljs-string">"my-number"</span>)</span> <span class="hljs-keyword">int</span> myNumber) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(String.format(<span class="hljs-string">"%d * 2 = %d"</span>,      myNumber, (myNumber * <span class="hljs-number">2</span>)), HttpStatus.OK);&#125;</code></pre><h3 id="2-2-一次性获取"><a href="#2-2-一次性获取" class="headerlink" title="2.2. 一次性获取"></a>2.2. 一次性获取</h3><p>如果我们不确定将出现哪些头，或者我们需要在方法签名中更多的头，我们可以使用@RequestHeader注释，而不需要特定的名称。</p><p>我们的变量类型有几个选择:Map、MultiValueMap或HttpHeaders对象。</p><p>首先，让我们以映射的方式获取请求头信息:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/listHeaders"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">listAllHeaders</span><span class="hljs-params">(  @RequestHeader Map&lt;String, String&gt; headers)</span> </span>&#123;    headers.forEach((key, value) -&gt; &#123;        LOG.info(String.format(<span class="hljs-string">"Header '%s' = %s"</span>, key, value));    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(      String.format(<span class="hljs-string">"Listed %d headers"</span>, headers.size()), HttpStatus.OK);&#125;</code></pre><p>如果我们使用一个Map，而其中一个头文件有多个值，我们将只获得第一个值。这相当于MultiValueMap上使用getFirst方法。</p><p>如果我们的头可能有多个值，我们可以获得他们作为一个MultiValueMap:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/multiValue"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">multiValue</span><span class="hljs-params">(  @RequestHeader MultiValueMap&lt;String, String&gt; headers)</span> </span>&#123;    headers.forEach((key, value) -&gt; &#123;        LOG.info(String.format(          <span class="hljs-string">"Header '%s' = %s"</span>, key, value.stream().collect(Collectors.joining(<span class="hljs-string">"|"</span>))));    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(      String.format(<span class="hljs-string">"Listed %d headers"</span>, headers.size()), HttpStatus.OK);&#125;</code></pre><p>我们也可以获得我们的头作为HttpHeaders对象:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getBaseUrl"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">getBaseUrl</span><span class="hljs-params">(@RequestHeader HttpHeaders headers)</span> </span>&#123;    InetSocketAddress host = headers.getHost();    String url = <span class="hljs-string">"http://"</span> + host.getHostName() + <span class="hljs-string">":"</span> + host.getPort();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(String.format(<span class="hljs-string">"Base URL = %s"</span>, url), HttpStatus.OK);&#125;</code></pre><p>HttpHeaders对象具有通用应用程序头的访问器.</p><p>当我们通过名称从Map、MultiValueMap或HttpHeaders对象访问一个头时，如果它不存在，我们将得到一个空值。</p><h2 id="3-RequestHeader-属性"><a href="#3-RequestHeader-属性" class="headerlink" title="3. @RequestHeader 属性"></a>3. @RequestHeader 属性</h2><p>现在我们已经讨论了使用@RequestHeader注释访问请求头的基础知识，让我们进一步看看它的属性。</p><p>我们已经隐式地使用了名称或值属性，当我们指定我们的头:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">greeting</span><span class="hljs-params">(@RequestHeader(<span class="hljs-string">"accept-language"</span>)</span> String language) </span>&#123;&#125;</code></pre><p>我们可以通过使用name属性完成同样的事情:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">greeting</span><span class="hljs-params">(  @RequestHeader(name = <span class="hljs-string">"accept-language"</span>)</span> String language) </span>&#123;&#125;</code></pre><p>接下来，让我们以同样的方式使用value属性:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">greeting</span><span class="hljs-params">(  @RequestHeader(value = <span class="hljs-string">"accept-language"</span>)</span> String language) </span>&#123;&#125;</code></pre><p>当我们指定一个头时，默认情况下需要这个头。如果在请求中没有找到header，控制器将返回一个400错误。</p><p>让我们使用required属性来表示我们的头文件不是必需的:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/nonRequiredHeader"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">evaluateNonRequiredHeader</span><span class="hljs-params">(  @RequestHeader(value = <span class="hljs-string">"optional-header"</span>, required = <span class="hljs-keyword">false</span>)</span> String optionalHeader) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(String.format(      <span class="hljs-string">"Was the optional header present? %s!"</span>,        (optionalHeader == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"No"</span> : <span class="hljs-string">"Yes"</span>)),HttpStatus.OK);&#125;</code></pre><p>因为如果请求中没有头文件，我们的变量将为空，所以我们需要确保进行适当的空检查。</p><p>让我们使用defaultValue属性为我们的头文件提供一个默认值:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/default"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">evaluateDefaultHeaderValue</span><span class="hljs-params">(  @RequestHeader(value = <span class="hljs-string">"optional-header"</span>, defaultValue = <span class="hljs-string">"3600"</span>)</span> <span class="hljs-keyword">int</span> optionalHeader) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;String&gt;(      String.format(<span class="hljs-string">"Optional Header is %d"</span>, optionalHeader), HttpStatus.OK);&#125;</code></pre><h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h1><p>在这个简短的教程中，我们学习了如何在Spring REST控制器中访问请求头。首先，我们使用@RequestHeader注释为控制器方法提供请求头。</p><p>在了解了基础知识之后，我们详细了解了@RequestHeader注释的属性。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何将YAML中的列表映射到Java List</title>
    <link href="/2020/08/13/how-to-map-a-yaml-list-into-a-list-in-spring-boot/"/>
    <url>/2020/08/13/how-to-map-a-yaml-list-into-a-list-in-spring-boot/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在这个简短的教程中，我们将进一步了解如何在Spring Boot中将YAML列表映射到列表中。</p><p>我们首先介绍一些如何在YAML中定义列表的背景知识。然后，我们将深入研究如何将YAML列表绑定到对象列表。</p><h2 id="2-快速回顾一下YAML中的列表"><a href="#2-快速回顾一下YAML中的列表" class="headerlink" title="2. 快速回顾一下YAML中的列表"></a>2. 快速回顾一下YAML中的列表</h2><p>简而言之，YAML是一种人类可读的数据序列化标准，它提供了一种简洁而清晰的方式来编写配置文件。YAML的优点是它支持多种数据类型，如列表、映射和标量类型。</p><p>YAML列表中的元素使用“-”字符定义，它们共享相同的缩进级别:</p><pre><code class="hljs yml"><span class="hljs-attr">yamlconfig:</span>  <span class="hljs-attr">list:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">item1</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">item2</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">item3</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">item4</span></code></pre><p>与properties对比:</p><pre><code class="hljs undefined"><span class="hljs-attr">yamlconfig.list[0]</span>=item1<span class="hljs-attr">yamlconfig.list[1]</span>=item2<span class="hljs-attr">yamlconfig.list[2]</span>=item3<span class="hljs-attr">yamlconfig.list[3]</span>=item4</code></pre><p>事实上，与属性文件相比，YAML的层次性显著增强了可读性。YAML的另一个有趣的特性是可以为不同的Spring配置文件定义不同的属性。</p><p>值得一提的是，Spring引导为YAML配置提供了开箱即用的支持。按照设计，Spring引导从应用程序加载配置属性。yml启动，没有任何额外的工作。</p><h2 id="3-将一个YAML列表绑定到一个简单的对象列表"><a href="#3-将一个YAML列表绑定到一个简单的对象列表" class="headerlink" title="3.将一个YAML列表绑定到一个简单的对象列表"></a>3.将一个YAML列表绑定到一个简单的对象列表</h2><p>Spring Boot提供了@ConfigurationProperties注释来简化将外部配置数据映射到对象模型的逻辑。</p><p>在本节中，我们将使用@ConfigurationProperties将一个YAML列表绑定到list <object>中。</object></p><p>我们首先在application.yml中定义一个简单的列表:</p><pre><code class="hljs yml"><span class="hljs-attr">application:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">dev</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">prod</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">1</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">2</span></code></pre><p>然后，我们将创建一个简单的ApplicationProps POJO来保存将YAML列表绑定到对象列表的逻辑:</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"application"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationProps</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;Object&gt; profiles;    <span class="hljs-comment">// getter and setter</span>&#125;</code></pre><p>ApplicationProps类需要用@ConfigurationProperties进行装饰，以表达将所有带有指定前缀的YAML属性映射到ApplicationProps对象的意图。</p><p>要绑定profiles列表，我们只需要定义一个list类型的字段，其余的由@ConfigurationProperties注释处理。</p><p>注意，我们使用@Component将ApplicationProps类注册为一个普通的Spring bean。因此，我们可以以与任何其他Spring bean相同的方式将其注入到其他类中。</p><p>最后，我们将ApplicationProps bean注入到一个测试类中，并验证我们的概要文件YAML列表是否被正确注入为list <object>:</object></p><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith</span>(SpringExtension<span class="hljs-class">.<span class="hljs-keyword">class</span>)@<span class="hljs-title">ContextConfiguration</span>(<span class="hljs-title">initializers</span> </span>= ConfigFileApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">value</span> </span>= ApplicationProps<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">class</span> <span class="hljs-title">YamlSimpleListUnitTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ApplicationProps applicationProps;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenYamlList_thenLoadSimpleList</span><span class="hljs-params">()</span> </span>&#123;        assertThat(applicationProps.getProfiles().get(<span class="hljs-number">0</span>)).isEqualTo(<span class="hljs-string">"dev"</span>);        assertThat(applicationProps.getProfiles().get(<span class="hljs-number">4</span>).getClass()).isEqualTo(Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        assertThat(applicationProps.getProfiles().size()).isEqualTo(<span class="hljs-number">5</span>);    &#125;&#125;</code></pre><h2 id="4-将YAML列表绑定到复杂列表"><a href="#4-将YAML列表绑定到复杂列表" class="headerlink" title="4. 将YAML列表绑定到复杂列表"></a>4. 将YAML列表绑定到复杂列表</h2><p>现在，让我们进一步了解如何将嵌套的YAML列表注入到复杂的结构化列表中。</p><p>首先，让我们添加一些嵌套列表到application.yml:</p><pre><code class="hljs yml"><span class="hljs-attr">application:</span>  <span class="hljs-string">//</span> <span class="hljs-string">...</span>  <span class="hljs-attr">props:</span>    <span class="hljs-bullet">-</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">YamlList</span>      <span class="hljs-attr">url:</span> <span class="hljs-string">http://yamllist.dev</span>      <span class="hljs-attr">description:</span> <span class="hljs-string">Mapping</span> <span class="hljs-string">list</span> <span class="hljs-string">in</span> <span class="hljs-string">Yaml</span> <span class="hljs-string">to</span> <span class="hljs-string">list</span> <span class="hljs-string">of</span> <span class="hljs-string">objects</span> <span class="hljs-string">in</span> <span class="hljs-string">Spring</span> <span class="hljs-string">Boot</span>    <span class="hljs-bullet">-</span>      <span class="hljs-attr">ip:</span> <span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span>      <span class="hljs-attr">port:</span> <span class="hljs-number">8091</span>    <span class="hljs-bullet">-</span>      <span class="hljs-attr">email:</span> <span class="hljs-string">support@yamllist.dev</span>      <span class="hljs-attr">contact:</span> <span class="hljs-string">http://yamllist.dev/contact</span>  <span class="hljs-attr">users:</span>    <span class="hljs-bullet">-</span>      <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span>      <span class="hljs-attr">password:</span> <span class="hljs-string">admin@10@</span>      <span class="hljs-attr">roles:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">READ</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">WRITE</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">VIEW</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">DELETE</span>    <span class="hljs-bullet">-</span>      <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>      <span class="hljs-attr">password:</span> <span class="hljs-string">guest@01</span>      <span class="hljs-attr">roles:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">VIEW</span></code></pre><p>在这个例子中，我们将道具属性绑定到一个 List&lt;Map&lt;String, Object&gt;&gt;.。类似地，我们将把用户映射到User对象列表中。</p><p>但是，在用户的情况下，所有的项共享相同的键，所以为了简化它的映射，我们可能需要创建一个专用的用户类，将键封装为字段:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationProps</span> </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; props;    <span class="hljs-keyword">private</span> List&lt;User&gt; users;    <span class="hljs-comment">// getters and setters</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">private</span> String username;        <span class="hljs-keyword">private</span> String password;        <span class="hljs-keyword">private</span> List&lt;String&gt; roles;        <span class="hljs-comment">// getters and setters</span>    &#125;&#125;</code></pre><p>现在我们验证嵌套的YAML列表被正确映射:</p><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith</span>(SpringExtension<span class="hljs-class">.<span class="hljs-keyword">class</span>)@<span class="hljs-title">ContextConfiguration</span>(<span class="hljs-title">initializers</span> </span>= ConfigFileApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)@<span class="hljs-title">EnableConfigurationProperties</span>(<span class="hljs-title">value</span> </span>= ApplicationProps<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">class</span> <span class="hljs-title">YamlComplexListsUnitTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ApplicationProps applicationProps;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenYamlNestedLists_thenLoadComplexLists</span><span class="hljs-params">()</span> </span>&#123;        assertThat(applicationProps.getUsers().get(<span class="hljs-number">0</span>).getPassword()).isEqualTo(<span class="hljs-string">"admin@10@"</span>);        assertThat(applicationProps.getProps().get(<span class="hljs-number">0</span>).get(<span class="hljs-string">"name"</span>)).isEqualTo(<span class="hljs-string">"YamlList"</span>);        assertThat(applicationProps.getProps().get(<span class="hljs-number">1</span>).get(<span class="hljs-string">"port"</span>).getClass()).isEqualTo(Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本教程中，我们学习了如何将YAML列表映射到Java列表。我们还检查了如何将复杂列表绑定到定制pojo。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BeanFactory和ApplicationContext的区别</title>
    <link href="/2020/08/13/spring-beanfactory-vs-applicationcontext/"/>
    <url>/2020/08/13/spring-beanfactory-vs-applicationcontext/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Spring框架附带了两个IOC容器—BeanFactory和ApplicationContext。BeanFactory是IOC容器的最基本版本，ApplicationContext扩展了BeanFactory的特性。</p><p>在这个快速教程中，我们将通过实际示例了解这两种IOC容器之间的显著差异。</p><h2 id="2-延迟加载与即时加载"><a href="#2-延迟加载与即时加载" class="headerlink" title="2. 延迟加载与即时加载"></a>2. 延迟加载与即时加载</h2><p>BeanFactory按需加载bean，而ApplicationContext在启动时加载所有bean。因此，与ApplicationContext相比，BeanFactory是轻量级的。让我们用一个例子来理解它。</p><h3 id="2-1-使用BeanFactory延迟加载"><a href="#2-1-使用BeanFactory延迟加载" class="headerlink" title="2.1. 使用BeanFactory延迟加载"></a>2.1. 使用BeanFactory延迟加载</h3><p>让我们假设我们有一个名为Student的单例bean类，它只有一个方法:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isBeanInstantiated = <span class="hljs-keyword">false</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span><span class="hljs-params">()</span> </span>&#123;        setBeanInstantiated(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">//standard setters and getters</span>&#125;</code></pre><p>我们将在我们的BeanFactory配置文件中定义postConstruct()方法作为init-method, ioc-container-difference-example.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"student"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.baeldung.ioccontainer.bean.Student"</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">"postConstruct"</span>/&gt;</span></code></pre><p>现在，让我们编写一个创建BeanFactory的测试用例来检查它是否加载了Student bean:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenBFInitialized_thenStudentNotInitialized</span><span class="hljs-params">()</span> </span>&#123;    Resource res = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"ioc-container-difference-example.xml"</span>);    BeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(res);    assertFalse(Student.isBeanInstantiated());&#125;</code></pre><p>这里，Student对象没有初始化。换句话说，只有BeanFactory被初始化。只有当我们显式地调用getBean()方法时，BeanFactory中定义的bean才会被加载。</p><p>让我们检查一下我们手动调用getBean()方法的学生bean的初始化:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenBFInitialized_thenStudentInitialized</span><span class="hljs-params">()</span> </span>&#123;    Resource res = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"ioc-container-difference-example.xml"</span>);    BeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(res);    Student student = (Student) factory.getBean(<span class="hljs-string">"student"</span>);    assertTrue(Student.isBeanInstantiated());&#125;</code></pre><p>在这里，Student bean成功加载。因此，BeanFactory只在需要时加载bean。</p><h3 id="2-2-使用ApplicationContext进行即时加载"><a href="#2-2-使用ApplicationContext进行即时加载" class="headerlink" title="2.2. 使用ApplicationContext进行即时加载"></a>2.2. 使用ApplicationContext进行即时加载</h3><p>现在，让我们在BeanFactory的位置使用ApplicationContext。</p><p>我们将只定义ApplicationContext，它将使用快速加载策略立即加载所有bean:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenAppContInitialized_thenStudentInitialized</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"ioc-container-difference-example.xml"</span>);    assertTrue(Student.isBeanInstantiated());&#125;</code></pre><p>在这里，即使我们没有调用getBean()方法，也会创建Student对象。</p><p>ApplicationContext被认为是一个重IOC容器，因为它的快速加载策略在启动时加载所有bean。相比之下，BeanFactory是轻量级的，在内存受限的系统中非常方便。尽管如此，我们将在下一节中看到为什么ApplicationContext在大多数用例中是首选。</p><h2 id="3-企业应用程序功能"><a href="#3-企业应用程序功能" class="headerlink" title="3.企业应用程序功能"></a>3.企业应用程序功能</h2><p>ApplicationContext以更加面向框架的风格增强了BeanFactory，并提供了几个适合企业应用程序的特性。</p><p>例如，它提供消息传递(i18n或国际化)功能、事件发布功能、基于注释的依赖注入，以及与Spring AOP特性的轻松集成。</p><p>除此之外，ApplicationContext几乎支持所有类型的bean作用域，但是BeanFactory只支持两种作用域—单例和原型。因此，在构建复杂的企业应用程序时，最好使用ApplicationContext。</p><h2 id="4-自动注册BeanFactoryPostProcessor和BeanPostProcessor"><a href="#4-自动注册BeanFactoryPostProcessor和BeanPostProcessor" class="headerlink" title="4. 自动注册BeanFactoryPostProcessor和BeanPostProcessor"></a>4. 自动注册BeanFactoryPostProcessor和BeanPostProcessor</h2><p>ApplicationContext在启动时自动注册BeanFactoryPostProcessor和BeanPostProcessor。另一方面，BeanFactory不会自动注册这些接口。</p><h3 id="4-1-注册BeanFactory"><a href="#4-1-注册BeanFactory" class="headerlink" title="4.1. 注册BeanFactory"></a>4.1. 注册BeanFactory</h3><p>为了便于理解，我们来写两个类。</p><p>首先，我们有CustomBeanFactoryPostProcessor类，它实现了BeanFactoryPostProcessor:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isBeanFactoryPostProcessorRegistered = <span class="hljs-keyword">false</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span></span>&#123;        setBeanFactoryPostProcessorRegistered(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-comment">// standard setters and getters</span>&#125;</code></pre><p>在这里，我们覆盖了postProcessBeanFactory()方法以检查其注册。</p><p>其次，我们有另一个类CustomBeanPostProcessor，它实现了BeanPostProcessor:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isBeanPostProcessorRegistered = <span class="hljs-keyword">false</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span></span>&#123;        setBeanPostProcessorRegistered(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-comment">//standard setters and getters</span>&#125;</code></pre><p>在这里，我们覆盖了postprocessbeforeinitialize()方法来检查其注册。</p><p>同时，我们已经在我们的ioc-container-difference-example.xml配置文件中配置了两个类:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"customBeanPostProcessor"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"com.baeldung.ioccontainer.bean.CustomBeanPostProcessor"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"customBeanFactoryPostProcessor"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"com.baeldung.ioccontainer.bean.CustomBeanFactoryPostProcessor"</span> /&gt;</span></code></pre><p>让我们看一个测试用例来检查这两个类在启动时是否被自动注册:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenBFInitialized_thenBFPProcessorAndBPProcessorNotRegAutomatically</span><span class="hljs-params">()</span> </span>&#123;    Resource res = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"ioc-container-difference-example.xml"</span>);    ConfigurableListableBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(res);    assertFalse(CustomBeanFactoryPostProcessor.isBeanFactoryPostProcessorRegistered());    assertFalse(CustomBeanPostProcessor.isBeanPostProcessorRegistered());&#125;</code></pre><p>从我们的测试中可以看出，自动注册并没有发生。</p><p>现在，让我们来看一个在BeanFactory中手动添加它们的测试用例:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenBFPostProcessorAndBPProcessorRegisteredManually_thenReturnTrue</span><span class="hljs-params">()</span> </span>&#123;    Resource res = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"ioc-container-difference-example.xml"</span>);    ConfigurableListableBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(res);    CustomBeanFactoryPostProcessor beanFactoryPostProcessor      = <span class="hljs-keyword">new</span> CustomBeanFactoryPostProcessor();    beanFactoryPostProcessor.postProcessBeanFactory(factory);    assertTrue(CustomBeanFactoryPostProcessor.isBeanFactoryPostProcessorRegistered());    CustomBeanPostProcessor beanPostProcessor = <span class="hljs-keyword">new</span> CustomBeanPostProcessor();    factory.addBeanPostProcessor(beanPostProcessor);    Student student = (Student) factory.getBean(<span class="hljs-string">"student"</span>);    assertTrue(CustomBeanPostProcessor.isBeanPostProcessorRegistered());&#125;</code></pre><p>在这里，我们使用postProcessBeanFactory()方法注册CustomBeanFactoryPostProcessor，使用addBeanPostProcessor()方法注册CustomBeanPostProcessor。在本例中，它们都成功注册。</p><h3 id="4-2-注册ApplicationContext"><a href="#4-2-注册ApplicationContext" class="headerlink" title="4.2. 注册ApplicationContext"></a>4.2. 注册ApplicationContext</h3><p>如前所述，ApplicationContext自动注册这两个类而不需要编写额外的代码。</p><p>让我们在单元测试中验证这个行为:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenAppContInitialized_thenBFPostProcessorAndBPostProcessorRegisteredAutomatically</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext context      = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"ioc-container-difference-example.xml"</span>);    assertTrue(CustomBeanFactoryPostProcessor.isBeanFactoryPostProcessorRegistered());    assertTrue(CustomBeanPostProcessor.isBeanPostProcessorRegistered());&#125;</code></pre><p>我们可以看到，在这个例子中，两个类的自动注册都是成功的。</p><p>因此，使用ApplicationContext总是明智的，因为Spring 2.0(及以上版本)大量使用BeanPostProcessor。</p><p>还值得注意的是，如果您使用的是普通的BeanFactory，那么事务和AOP等特性将不会生效(至少在不编写额外代码的情况下不会)。这可能会导致混淆，因为配置看起来没有任何问题。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本文中，我们通过实际示例看到了ApplicationContext和BeanFactory之间的关键区别。</p><p>ApplicationContext提供了高级特性，包括几个面向企业应用程序的特性，而BeanFactory只提供基本特性。因此，通常建议使用ApplicationContext，并且只有在内存消耗非常严重的情况下才应该使用BeanFactory。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot集成Caffeine缓存</title>
    <link href="/2020/08/12/spring-boot-and-caffeine-cache/"/>
    <url>/2020/08/12/spring-boot-and-caffeine-cache/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Caffeine缓存是一个高性能的Java缓存库。在这个简短的教程中，我们将看到如何在Spring Boot中使用它。</p><h2 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2. 依赖"></a>2. 依赖</h2><p>要在Spring Boot中使用Caffeine缓存，我们首先要添加 <code>spring-boot-starter-cache</code>和 <code>caffeine</code>依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>caffeine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>它们导入基本的Spring缓存支持，以及caffeine库。</p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><p>现在我们需要在Spring引导应用程序中配置缓存。</p><p>首先，我们制作了一种caffeine bean。这是主要配置，将控制缓存行为，如过期，缓存大小限制，以及更多:</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Caffeine <span class="hljs-title">caffeineConfig</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Caffeine.newBuilder().expireAfterWrite(<span class="hljs-number">60</span>, TimeUnit.MINUTES);&#125;</code></pre><p>接下来，我们需要使用Spring CacheManager接口创建另一个bean。Caffeine提供了这个接口的实现，它需要我们上面创建的Caffeine对象:</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(Caffeine caffeine)</span> </span>&#123;  CaffeineCacheManager caffeineCacheManager = <span class="hljs-keyword">new</span> CaffeineCacheManager();  caffeineCacheManager.setCaffeine(caffeine);  <span class="hljs-keyword">return</span> caffeineCacheManager;&#125;</code></pre><p>最后，我们需要在Spring Boot中使用@EnableCaching注释启用缓存。这可以添加到应用程序中的任何@Configuration类中。</p><h2 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h2><p>启用缓存并配置为使用Caffeine后，让我们通过几个示例来了解如何在Spring Boot应用程序中使用缓存。</p><p>在Spring Boot中使用缓存的主要方法是使用@Cacheable注释。这个注释适用于Spring bean的任何方法(甚至是整个类)。它指示已注册的缓存管理器将方法调用的结果存储在缓存中。</p><p>一个典型的用法是在服务类内部:</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressService</span> </span>&#123;    <span class="hljs-meta">@Cacheable</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AddressDTO <span class="hljs-title">getAddress</span><span class="hljs-params">(<span class="hljs-keyword">long</span> customerId)</span> </span>&#123;        <span class="hljs-comment">// lookup and return result</span>    &#125;&#125;</code></pre><p>使用不带参数的@Cacheable注释将迫使Spring为缓存和缓存键使用默认名称。</p><p>我们可以通过在注释中添加一些参数来覆盖这两种行为:</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressService</span> </span>&#123;    <span class="hljs-meta">@Cacheable</span>(value = <span class="hljs-string">"address_cache"</span>, key = <span class="hljs-string">"customerId"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> AddressDTO <span class="hljs-title">getAddress</span><span class="hljs-params">(<span class="hljs-keyword">long</span> customerId)</span> </span>&#123;        <span class="hljs-comment">// lookup and return result</span>    &#125;&#125;</code></pre><p>上面的示例告诉Spring使用名为address_cache的缓存和缓存键的customerId参数。</p><p>最后，因为缓存管理器本身就是一个Spring bean，我们也可以将它自动绑定到任何其他bean中，并直接使用它:</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    CacheManager cacheManager;    <span class="hljs-function"><span class="hljs-keyword">public</span> AddressDTO <span class="hljs-title">getAddress</span><span class="hljs-params">(<span class="hljs-keyword">long</span> customerId)</span> </span>&#123;        <span class="hljs-keyword">if</span>(cacheManager.containsKey(customerId)) &#123;            <span class="hljs-keyword">return</span> cacheManager.get(customerId);        &#125;        <span class="hljs-comment">// lookup address, cache result, and return it</span>    &#125;&#125;</code></pre><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本教程中，我们看到了如何配置Spring Boot来使用咖啡因缓存，以及如何在应用程序中使用缓存的一些示例。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring @PathVariable注解</title>
    <link href="/2020/08/11/spring-pathvariable-annotation/"/>
    <url>/2020/08/11/spring-pathvariable-annotation/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在这个快速教程中，我们将探索Spring的<code>@PathVariable</code>注解。</p><p>简单地说，<code>@PathVariable</code>注解可以用于处理请求URI映射中的模板变量，并将它们用作方法参数。</p><p>让我们看看如何使用<code>@PathVariable</code>及其各种属性。</p><h2 id="2-简单映射"><a href="#2-简单映射" class="headerlink" title="2. 简单映射"></a>2. 简单映射</h2><p><code>@PathVariable</code>注解的一个简单用例是一个端点，它标识一个具有主键的实体:</p><pre><code class="hljs Java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/api/employees/&#123;id&#125;"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesById</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id;&#125;</code></pre><p>在本例中，我们使用@PathVariable注解来提取由变量{id}表示的URI模板化部分。</p><p>一个简单的GET请求<code>/api/employees/{id}</code>将调用getEmployeesById提取id值:</p><pre><code class="hljs text">http://localhost:8080/api/employees/111----ID: 111</code></pre><p>现在，让我们进一步研究这个注解并查看它的属性。</p><h2 id="3-指定路径变量名"><a href="#3-指定路径变量名" class="headerlink" title="3.指定路径变量名"></a>3.指定路径变量名</h2><p>在前面的示例中，我们跳过了定义模板路径变量的名称，因为方法参数的名称和路径变量的名称是相同的。</p><p>但是，如果路径变量名称不同，我们可以在<code>@PathVariable</code>注解的参数中指定:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/api/employeeswithvariable/&#123;id&#125;"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdWithVariableName</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> String employeeId) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + employeeId;&#125;</code></pre><pre><code class="hljs undefined"><span class="hljs-section">http://localhost:8080/api/employeeswithvariable/1----</span>ID: 1</code></pre><p>为了清晰起见，我们还可以将路径变量名定义为<code>@PathVariable(value= &quot;id&quot;)</code>，而不是<code>PathVariable(&quot;id&quot;)</code>。</p><h2 id="4-单个请求中的多个路径变量"><a href="#4-单个请求中的多个路径变量" class="headerlink" title="4. 单个请求中的多个路径变量"></a>4. 单个请求中的多个路径变量</h2><p>根据用例，我们可以在控制器方法的请求URI中有多个路径变量，它也有多个方法参数:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/api/employees/&#123;id&#125;/&#123;name&#125;"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdAndName</span><span class="hljs-params">(@PathVariable String id, @PathVariable String name)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id + <span class="hljs-string">", name: "</span> + name;&#125;</code></pre><pre><code class="hljs undefined"><span class="hljs-section">http://localhost:8080/api/employees/1/bar----</span>ID: 1, name: bar</code></pre><p>我们还可以使用类型为<code>java.util.Map&lt;String, String &gt;</code>的方法参数处理多个<code>@PathVariable</code>参数:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/api/employeeswithmapvariable/&#123;id&#125;/&#123;name&#125;"</span>)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdAndNameWithMapVariable</span><span class="hljs-params">(@PathVariable Map&lt;String, String&gt; pathVarsMap)</span> </span>&#123;    String id = pathVarsMap.get(<span class="hljs-string">"id"</span>);    String name = pathVarsMap.get(<span class="hljs-string">"name"</span>);    <span class="hljs-keyword">if</span> (id != <span class="hljs-keyword">null</span> &amp;&amp; name != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id + <span class="hljs-string">", name: "</span> + name;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Missing Parameters"</span>;    &#125;&#125;</code></pre><pre><code class="hljs undefined"><span class="hljs-section">http://localhost:8080/api/employees/1/bar----</span>ID: 1, name: bar</code></pre><h2 id="5-可选路径变量"><a href="#5-可选路径变量" class="headerlink" title="5. 可选路径变量"></a>5. 可选路径变量</h2><p>在Spring中，使用<code>@PathVariable</code>注解的方法参数在默认情况下是必需的:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(value = &#123; <span class="hljs-string">"/api/employeeswithrequired"</span>, <span class="hljs-string">"/api/employeeswithrequired/&#123;id&#125;"</span> &#125;)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdWithRequired</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id;&#125;</code></pre><p>从它的外观来看，上面的控制器应该同时处理<code>/api/employeeswithrequired</code>和<code>/api/employeeswithrequired/1</code>请求路径。但是，由于@PathVariables标注的方法参数在默认情况下是强制的，所以它不处理发送到<code>/api/employeeswithrequired</code>路径的请求:</p><pre><code class="hljs undefined"><span class="hljs-section">http://localhost:8080/api/employeeswithrequired----</span>&#123;"timestamp":"2020-07-08T02:20:07.349+00:00","status":404,"error":"Not Found","message":"","path":"/api/employeeswithrequired"&#125;<span class="hljs-section">http://localhost:8080/api/employeeswithrequired/1----</span>ID: 111</code></pre><p>我们有两种处理方法。</p><h3 id="5-1-将-PathVariable设置为不需要"><a href="#5-1-将-PathVariable设置为不需要" class="headerlink" title="5.1. 将@PathVariable设置为不需要"></a>5.1. 将@PathVariable设置为不需要</h3><p>我们可以将<code>@PathVariable</code>的必需属性设置为<code>false</code>，使其可选。因此，修改我们之前的例子，我们现在可以处理有和没有路径变量的URI版本:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(value = &#123; <span class="hljs-string">"/api/employeeswithrequiredfalse"</span>, <span class="hljs-string">"/api/employeeswithrequiredfalse/&#123;id&#125;"</span> &#125;)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdWithRequiredFalse</span><span class="hljs-params">(@PathVariable(required = <span class="hljs-keyword">false</span>)</span> String id) </span>&#123;    <span class="hljs-keyword">if</span> (id != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID missing"</span>;    &#125;&#125;</code></pre><pre><code class="hljs undefined"><span class="hljs-section">http://localhost:8080/api/employeeswithrequiredfalse----</span>ID missing</code></pre><h3 id="5-2-使用java-util-Optional"><a href="#5-2-使用java-util-Optional" class="headerlink" title="5.2. 使用java.util.Optional"></a>5.2. 使用java.util.Optional</h3><p>从Spring 4.1开始，我们还可以使用<code>java.util.Optional&lt;T&gt;</code>(在Java 8+中可用)来处理一个非强制路径变量:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(value = &#123; <span class="hljs-string">"/api/employeeswithoptional"</span>, <span class="hljs-string">"/api/employeeswithoptional/&#123;id&#125;"</span> &#125;)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdWithOptional</span><span class="hljs-params">(@PathVariable Optional&lt;String&gt; id)</span> </span>&#123;    <span class="hljs-keyword">if</span> (id.isPresent()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id.get();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID missing"</span>;    &#125;&#125;</code></pre><p>现在，如果我们没有在请求中指定路径变量id，我们会得到默认响应:</p><pre><code class="hljs undefined"><span class="hljs-section">http://localhost:8080/api/employeeswithoptional----</span>ID missing</code></pre><h3 id="5-3-使用类型为Map-lt-String-String-gt-的方法参数"><a href="#5-3-使用类型为Map-lt-String-String-gt-的方法参数" class="headerlink" title="5.3. 使用类型为Map&lt;String, String&gt;的方法参数"></a>5.3. 使用类型为Map&lt;String, String&gt;的方法参数</h3><p>如前面所示，我们可以使用<code>java.util.Map&lt;String, String&gt;</code>类型的单个方法参数。映射以处理请求URI中的所有路径变量。我们也可以使用这个策略来处理可选路径变量的情况:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(value = &#123; <span class="hljs-string">"/api/employeeswithmap/&#123;id&#125;"</span>, <span class="hljs-string">"/api/employeeswithmap"</span> &#125;)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeesByIdWithMap</span><span class="hljs-params">(@PathVariable Map&lt;String, String&gt; pathVarsMap)</span> </span>&#123;    String id = pathVarsMap.get(<span class="hljs-string">"id"</span>);    <span class="hljs-keyword">if</span> (id != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID missing"</span>;    &#125;&#125;</code></pre><h2 id="6-PathVariable的默认值"><a href="#6-PathVariable的默认值" class="headerlink" title="6. @PathVariable的默认值"></a>6. @PathVariable的默认值</h2><p>在开箱即用的情况下，没有为用<code>@PathVariable</code>注解的方法参数定义默认值的规定。但是，我们可以使用上面讨论的相同策略来满足<code>@PathVariable</code>的默认值情况。我们只需要检查路径变量是否为null。</p><p>例如，使用<code>java.util.Optional&lt;String&gt;</code>，我们可以确定路径变量是否为空。如果它是null，那么我们可以响应请求的默认值:</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(value = &#123; <span class="hljs-string">"/api/defaultemployeeswithoptional"</span>, <span class="hljs-string">"/api/defaultemployeeswithoptional/&#123;id&#125;"</span> &#125;)<span class="hljs-meta">@ResponseBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDefaultEmployeesByIdWithOptional</span><span class="hljs-params">(@PathVariable Optional&lt;String&gt; id)</span> </span>&#123;    <span class="hljs-keyword">if</span> (id.isPresent()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: "</span> + id.get();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"ID: Default Employee"</span>;    &#125;&#125;</code></pre><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>在本文中，我们讨论了如何使用Spring的@PathVariable注解。我们还确定了有效使用<code>@PathVariable</code>注解来适应不同用例的各种方法，比如可选参数和处理默认值。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何跨微服务共享DTO</title>
    <link href="/2020/08/11/java-microservices-share-dto/"/>
    <url>/2020/08/11/java-microservices-share-dto/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>近年来，微服务变得非常流行。微服务的基本特征之一是它们是模块化的、独立的、易于伸缩的。微服务需要一起工作并交换数据。为了实现这一点，我们创建一个称为dto的共享数据传输对象。</p><p>在本文中，我们将介绍在微服务之间共享dto的方法。</p><h2 id="2-将域对象暴露为DTO"><a href="#2-将域对象暴露为DTO" class="headerlink" title="2. 将域对象暴露为DTO"></a>2. 将域对象暴露为DTO</h2><p>表示应用程序域的模型使用微服务进行管理。领域模型是不同的关注点，我们将它们与DAO层中的数据模型分离开来。</p><p>这样做的主要原因是，我们不想通过服务向客户端公开领域的复杂性。相反，我们通过REST api在服务于应用程序客户机的服务之间公开dto。当dto在这些服务之间传递时，我们将它们转换为域对象。</p><p><img src="https://i.loli.net/2020/08/11/GyVIkCacZOBNnWf.png" srcset="/img/loading.gif" alt="application_architecture_with_dtos_and_service_facade_original-1.png"></p><p>上面的面向服务的体系结构示意图地显示了从DTO到域对象的组件和流程。</p><h2 id="3-微服务之间的DTO共享"><a href="#3-微服务之间的DTO共享" class="headerlink" title="3.微服务之间的DTO共享"></a>3.微服务之间的DTO共享</h2><p>以客户订购产品的过程为例。这个过程基于客户订单模型。让我们从服务架构的角度来看这个过程。</p><p>假设客户服务向订单服务发送请求数据为:</p><pre><code class="hljs java"><span class="hljs-string">"order"</span>: &#123;    <span class="hljs-string">"customerId"</span>: <span class="hljs-number">1</span>,    <span class="hljs-string">"itemId"</span>: <span class="hljs-string">"A152"</span>&#125;</code></pre><p>客户和订单服务使用契约相互通信。契约(另一种服务请求)以JSON格式显示。作为一个Java模型，OrderDTO类表示客户服务和订单服务之间的契约:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDTO</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> customerId;    <span class="hljs-keyword">private</span> String itemId;    <span class="hljs-comment">// constructor, getters, setters</span>&#125;</code></pre><h3 id="3-1-使用客户端模块-库-共享DTO"><a href="#3-1-使用客户端模块-库-共享DTO" class="headerlink" title="3.1. 使用客户端模块(库)共享DTO"></a>3.1. 使用客户端模块(库)共享DTO</h3><p>微服务需要来自其他服务的特定信息来处理任何请求。假设有第三个微服务接收订单支付请求。与订购服务不同，这项服务需要不同的客户信息:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerDTO</span> </span>&#123;    <span class="hljs-keyword">private</span> String firstName;    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-keyword">private</span> String cardNumber;    <span class="hljs-comment">// constructor, getters, setters</span>&#125;</code></pre><p>如果我们还添加了送货服务，客户信息将有:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerDTO</span> </span>&#123;    <span class="hljs-keyword">private</span> String firstName;    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-keyword">private</span> String homeAddress;    <span class="hljs-keyword">private</span> String contactNumber;    <span class="hljs-comment">// constructor, getters, setters</span>&#125;</code></pre><p>因此，将CustomerDTO类放在共享模块中不再满足预期的目的。为了解决这个问题，我们采用一种不同的方法。</p><p>在每个微服务模块中，让我们创建一个客户端模块(库)，在它旁边创建一个服务器模块:</p><pre><code class="hljs undefined"><span class="hljs-keyword">order</span>-service|__ <span class="hljs-keyword">order</span>-<span class="hljs-keyword">client</span>|__ <span class="hljs-keyword">order</span>-<span class="hljs-keyword">server</span></code></pre><p>订单客户端模块包含一个与客户服务共享的DTO。因此，订单客户端模块的结构如下:</p><pre><code class="hljs undefined"><span class="hljs-keyword">order-service</span>└──<span class="hljs-keyword">order-client</span>     <span class="hljs-keyword">OrderClient.java</span>     <span class="hljs-keyword">OrderClientImpl.java</span>     <span class="hljs-keyword">OrderDTO.java</span></code></pre><p>OrderClient是一个定义处理订单请求的订单方法的接口:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderClient</span> </span>&#123;    <span class="hljs-function">OrderResponse <span class="hljs-title">order</span><span class="hljs-params">(OrderDTO orderDTO)</span></span>;&#125;</code></pre><p>为了实现order方法，我们使用RestTemplate对象向order服务发送一个POST请求:</p><pre><code class="hljs Java">String serviceUrl = <span class="hljs-string">"http://localhost:8002/order-service"</span>;OrderResponse orderResponse = restTemplate.postForObject(serviceUrl + <span class="hljs-string">"/create"</span>,  request, OrderResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><p>此外，订单客户端模块已经可以使用了。现在它变成了客户服务模块的依赖库:</p><pre><code class="hljs undefined"><span class="hljs-selector-attr">[INFO]</span> <span class="hljs-selector-tag">---</span> <span class="hljs-selector-tag">maven-dependency-plugin</span><span class="hljs-selector-pseudo">:3.1.2</span><span class="hljs-selector-pseudo">:list</span> (default-cli) @ <span class="hljs-selector-tag">customer-service</span> <span class="hljs-selector-tag">---</span><span class="hljs-selector-attr">[INFO]</span> <span class="hljs-selector-tag">The</span> <span class="hljs-selector-tag">following</span> <span class="hljs-selector-tag">files</span> <span class="hljs-selector-tag">have</span> <span class="hljs-selector-tag">been</span> <span class="hljs-selector-tag">resolved</span>:<span class="hljs-selector-attr">[INFO]</span>    <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.baeldung</span><span class="hljs-selector-class">.orderservice</span><span class="hljs-selector-pseudo">:order-client</span><span class="hljs-selector-pseudo">:jar</span><span class="hljs-selector-pseudo">:1.0-SNAPSHOT</span><span class="hljs-selector-pseudo">:compile</span></code></pre><p>当然，如果没有order-server模块向订单客户端公开“/create”服务端点，这就没有任何意义:</p><pre><code class="hljs Java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/create"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> OrderResponse <span class="hljs-title">createOrder</span><span class="hljs-params">(@RequestBody OrderDTO request)</span></span></code></pre><p>由于有了这个服务端点，客户服务可以通过其订单客户端发送订单请求。通过使用客户端模块，微服务以一种更隔离的方式彼此通信。DTO中的属性在客户机模块中更新。因此，合同的破坏仅限于使用相同客户端模块的服务。</p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>在本文中，我们解释了在微服务之间共享DTO对象的方法。最好的情况是，我们通过制定特殊的契约作为microservice客户端模块(库)的一部分来实现这一点。通过这种方式，我们将服务客户端与包含API资源的服务器部分分离开来。因此，有一些好处:</p><ul><li>服务之间的DTO代码中没有冗余</li><li>合同的破坏仅限于使用相同客户端库的服务</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jackson注解示例</title>
    <link href="/2020/08/10/jackson-annotations-example/"/>
    <url>/2020/08/10/jackson-annotations-example/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本文中，我们将深入研究Jackson注解。<br>我们将看到如何使用现有的注释，如何创建自定义的注释，最后—如何禁用它们。</p><h2 id="2-Jackson序列化注解"><a href="#2-Jackson序列化注解" class="headerlink" title="2. Jackson序列化注解"></a>2. Jackson序列化注解</h2><p>首先，我们将查看序列化注释。</p><h3 id="2-1-JsonAnyGetter"><a href="#2-1-JsonAnyGetter" class="headerlink" title="2.1. @JsonAnyGetter"></a>2.1. @JsonAnyGetter</h3><p>@JsonAnyGetter注释允许灵活地使用映射字段作为标准属性。<br>下面是一个快速的例子——ExtendableBean实体拥有name属性和一组可扩展属性，它们以键/值对的形式存在:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendableBean</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; properties;    <span class="hljs-meta">@JsonAnyGetter</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">getProperties</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> properties;    &#125;&#125;</code></pre><p>当我们序列化这个实体的一个实例时，我们会得到Map中所有的键值作为标准的普通属性:</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"My bean"</span>,    <span class="hljs-attr">"attr2"</span>:<span class="hljs-string">"val2"</span>,    <span class="hljs-attr">"attr1"</span>:<span class="hljs-string">"val1"</span>&#125;</code></pre><p>这里是如何序列化这个实体看起来像在实践:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonAnyGetter_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    ExtendableBean bean = <span class="hljs-keyword">new</span> ExtendableBean(<span class="hljs-string">"My bean"</span>);    bean.add(<span class="hljs-string">"attr1"</span>, <span class="hljs-string">"val1"</span>);    bean.add(<span class="hljs-string">"attr2"</span>, <span class="hljs-string">"val2"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"attr1"</span>));    assertThat(result, containsString(<span class="hljs-string">"val1"</span>));&#125;</code></pre><p>我们还可以使用可选参数enabled为false来禁用@JsonAnyGetter()。在本例中，映射将被转换为JSON，并在序列化之后出现在properties变量下。</p><h3 id="2-2-JsonGetter"><a href="#2-2-JsonGetter" class="headerlink" title="2.2. @JsonGetter"></a>2.2. @JsonGetter</h3><p>@JsonGetter注释是@JsonProperty注释的替代品，它将方法标记为getter方法。<br>在下面的例子中-我们指定getTheName()方法作为MyBean实体的name属性的getter方法:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonGetter</span>(<span class="hljs-string">"name"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTheName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><p>这是如何在实践中运作的:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonGetter_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    MyBean bean = <span class="hljs-keyword">new</span> MyBean(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, containsString(<span class="hljs-string">"1"</span>));&#125;</code></pre><h3 id="2-3-JsonPropertyOrder"><a href="#2-3-JsonPropertyOrder" class="headerlink" title="2.3. @JsonPropertyOrder"></a>2.3. @JsonPropertyOrder</h3><p>我们可以使用@JsonPropertyOrder注释来指定序列化时属性的顺序。<br>让我们为MyBean实体的属性设置一个自定义顺序:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonPropertyOrder</span>(&#123; <span class="hljs-string">"name"</span>, <span class="hljs-string">"id"</span> &#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>这是序列化的输出:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"name"</span>:<span class="hljs-string">"My bean"</span>,    <span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>&#125;</code></pre><p>还有一个简单的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonPropertyOrder_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    MyBean bean = <span class="hljs-keyword">new</span> MyBean(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, containsString(<span class="hljs-string">"1"</span>));&#125;</code></pre><p>我们还可以使用@JsonPropertyOrder(alphabetic=true)按字母顺序排列属性。在这种情况下，序列化的输出将是:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>,    <span class="hljs-string">"name"</span>:<span class="hljs-string">"My bean"</span>&#125;</code></pre><h3 id="2-4-JsonRawValue"><a href="#2-4-JsonRawValue" class="headerlink" title="2.4. @JsonRawValue"></a>2.4. @JsonRawValue</h3><p>@JsonRawValue注释可以指示Jackson按原样序列化属性。<br>在下面的例子中，我们使用@JsonRawValue嵌入一些定制的JSON作为一个实体的值:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawBean</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@JsonRawValue</span>    <span class="hljs-keyword">public</span> String json;&#125;</code></pre><p>序列化实体的输出为:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"name"</span>:<span class="hljs-string">"My bean"</span>,    <span class="hljs-string">"json"</span>:&#123;        <span class="hljs-string">"attr"</span>:<span class="hljs-keyword">false</span>    &#125;&#125;</code></pre><p>还有一个简单的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonRawValue_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    RawBean bean = <span class="hljs-keyword">new</span> RawBean(<span class="hljs-string">"My bean"</span>, <span class="hljs-string">"&#123;\"attr\":false&#125;"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, containsString(<span class="hljs-string">"&#123;\"attr\":false&#125;"</span>));&#125;</code></pre><p>我们还可以使用可选的布尔参数值来定义这个注释是否是活动的。</p><h3 id="2-5-JsonValue"><a href="#2-5-JsonValue" class="headerlink" title="2.5. @JsonValue"></a>2.5. @JsonValue</h3><p>@JsonValue表示库将使用一个方法来序列化整个实例。<br>例如，在枚举中，我们用@JsonValue注释getName，这样任何这样的实体都可以通过其名称序列化:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> TypeEnumWithValue &#123;    TYPE1(<span class="hljs-number">1</span>, <span class="hljs-string">"Type A"</span>), TYPE2(<span class="hljs-number">2</span>, <span class="hljs-string">"Type 2"</span>);    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// standard constructors</span>    <span class="hljs-meta">@JsonValue</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><p>我们的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonValue_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonParseException, IOException </span>&#123;    String enumAsString = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(TypeEnumWithValue.TYPE1);    assertThat(enumAsString, is(<span class="hljs-string">""</span>Type A<span class="hljs-string">""</span>));&#125;</code></pre><h3 id="2-6-JsonRootName"><a href="#2-6-JsonRootName" class="headerlink" title="2.6. @JsonRootName"></a>2.6. @JsonRootName</h3><p>如果启用了包装，则使用@JsonRootName注释来指定要使用的根包装器的名称。<br>包装意味着不将用户序列化为以下内容:<br>它会像这样包装:</p><pre><code class="hljs Json">&#123;    <span class="hljs-attr">"User"</span>: &#123;        <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John"</span>    &#125;&#125;</code></pre><p>那么，让我们来看一个例子——我们将使用@JsonRootName注释来表示这个潜在的包装实体的名称:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonRootName</span>(value = <span class="hljs-string">"user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserWithRoot</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>默认情况下，包装器的名称将是类的名称- UserWithRoot。通过使用注释，我们得到了看起来更干净的用户:</p><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonRootName_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    UserWithRoot user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"John"</span>);    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);    String result = mapper.writeValueAsString(user);    assertThat(result, containsString(<span class="hljs-string">"John"</span>));    assertThat(result, containsString(<span class="hljs-string">"user"</span>));&#125;</code></pre><p>这是序列化的输出:</p><pre><code class="hljs Json">&#123;    <span class="hljs-attr">"user"</span>:&#123;        <span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,        <span class="hljs-attr">"name"</span>:<span class="hljs-string">"John"</span>    &#125;&#125;</code></pre><p>自Jackson 2.4以来，一个新的可选参数名称空间可用于XML等数据格式。如果我们添加它，它将成为完全限定名的一部分:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonRootName</span>(value = <span class="hljs-string">"user"</span>, namespace=<span class="hljs-string">"users"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserWithRootNamespace</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>如果我们用XmlMapper序列化它，输出将是:</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"users"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">""</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">""</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">items</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span></code></pre><h3 id="2-7-JsonSerialize"><a href="#2-7-JsonSerialize" class="headerlink" title="2.7. @JsonSerialize"></a>2.7. @JsonSerialize</h3><p>让我们看一个简单的例子。我们将使用@JsonSerialize用CustomDateSerializer来序列化eventDate属性:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventWithSerializer</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@JsonSerialize</span>(using = CustomDateSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)    <span class="hljs-title">public</span> <span class="hljs-title">Date</span> <span class="hljs-title">eventDate</span></span>;&#125;</code></pre><p>下面是简单的自定义Jackson序列化器:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDateSerializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StdSerializer</span>&lt;<span class="hljs-title">Date</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SimpleDateFormat formatter      = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd-MM-yyyy hh:mm:ss"</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomDateSerializer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomDateSerializer</span><span class="hljs-params">(Class&lt;Date&gt; t)</span> </span>&#123;        <span class="hljs-keyword">super</span>(t);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(      Date value, JsonGenerator gen, SerializerProvider arg2)</span>      <span class="hljs-keyword">throws</span> IOException, JsonProcessingException </span>&#123;        gen.writeString(formatter.format(value));    &#125;&#125;</code></pre><p>让我们在测试中使用这些:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonSerialize_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException, ParseException </span>&#123;    SimpleDateFormat df      = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd-MM-yyyy hh:mm:ss"</span>);    String toParse = <span class="hljs-string">"20-12-2014 02:30:00"</span>;    Date date = df.parse(toParse);    EventWithSerializer event = <span class="hljs-keyword">new</span> EventWithSerializer(<span class="hljs-string">"party"</span>, date);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(event);    assertThat(result, containsString(toParse));&#125;</code></pre><h2 id="Jackson反序列化注解"><a href="#Jackson反序列化注解" class="headerlink" title="Jackson反序列化注解"></a>Jackson反序列化注解</h2><p>接下来——让我们研究Jackson反序列化注解。</p><h3 id="3-1-JsonCreator"><a href="#3-1-JsonCreator" class="headerlink" title="3.1. @JsonCreator"></a>3.1. @JsonCreator</h3><p>我们可以使用@JsonCreator注释来调优反序列化中使用的构造器/工厂。<br>当我们需要反序列化一些与我们需要获取的目标实体不完全匹配的JSON时，它非常有用。<br>我们来看一个例子;说我们需要反序列化以下JSON:</p><pre><code class="hljs Json">&#123;    <span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,    <span class="hljs-attr">"theName"</span>:<span class="hljs-string">"My bean"</span>&#125;</code></pre><p>但是，在我们的目标实体中没有theName字段—只有name字段。现在，我们不想改变实体本身—我们只需要对数据编出过程进行更多的控制—通过使用@JsonCreator和@JsonProperty注释来注释构造函数:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanWithCreator</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@JsonCreator</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanWithCreator</span><span class="hljs-params">(      @JsonProperty(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">int</span> id,      @<span class="hljs-title">JsonProperty</span><span class="hljs-params">(<span class="hljs-string">"theName"</span>)</span> String name) </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><p>让我们来看看这是怎么回事:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingUsingJsonCreator_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    String json = <span class="hljs-string">"&#123;\"id\":1,\"theName\":\"My bean\"&#125;"</span>;    BeanWithCreator bean = <span class="hljs-keyword">new</span> ObjectMapper()      .readerFor(BeanWithCreator<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(<span class="hljs-string">"My bean"</span>, bean.name);&#125;</code></pre><h3 id="3-2-JacksonInject"><a href="#3-2-JacksonInject" class="headerlink" title="3.2. @JacksonInject"></a>3.2. @JacksonInject</h3><p>@JacksonInject表示属性将从注入中获得其值，而不是从JSON数据中。<br>在下面的例子中，我们使用@JacksonInject注入属性id:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanWithInject</span> </span>&#123;    <span class="hljs-meta">@JacksonInject</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>它是这样工作的:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingUsingJsonInject_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    String json = <span class="hljs-string">"&#123;\"name\":\"My bean\"&#125;"</span>;    InjectableValues inject = <span class="hljs-keyword">new</span> InjectableValues.Std()      .addValue(<span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, 1)</span>;    BeanWithInject bean = <span class="hljs-keyword">new</span> ObjectMapper().reader(inject)      .forType(BeanWithInject<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(<span class="hljs-string">"My bean"</span>, bean.name);    assertEquals(<span class="hljs-number">1</span>, bean.id);&#125;</code></pre><h3 id="3-3-JsonAnySetter"><a href="#3-3-JsonAnySetter" class="headerlink" title="3.3. @JsonAnySetter"></a>3.3. @JsonAnySetter</h3><p>@JsonAnySetter允许我们灵活地使用映射作为标准属性。在反序列化时，JSON的属性将被添加到映射中。</p><p>让我们看看这是如何工作的-我们将使用@JsonAnySetter来反序列化实体ExtendableBean:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendableBean</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; properties;    <span class="hljs-meta">@JsonAnySetter</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String key, String value)</span> </span>&#123;        properties.put(key, value);    &#125;&#125;</code></pre><p>这是我们需要反序列化的JSON:</p><pre><code class="hljs Json">&#123;    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"My bean"</span>,    <span class="hljs-attr">"attr2"</span>:<span class="hljs-string">"val2"</span>,    <span class="hljs-attr">"attr1"</span>:<span class="hljs-string">"val1"</span>&#125;</code></pre><p>而这一切是如何联系在一起的:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingUsingJsonAnySetter_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    String json      = <span class="hljs-string">"&#123;\"name\":\"My bean\",\"attr2\":\"val2\",\"attr1\":\"val1\"&#125;"</span>;    ExtendableBean bean = <span class="hljs-keyword">new</span> ObjectMapper()      .readerFor(ExtendableBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(<span class="hljs-string">"My bean"</span>, bean.name);    assertEquals(<span class="hljs-string">"val2"</span>, bean.getProperties().get(<span class="hljs-string">"attr2"</span>));&#125;</code></pre><h3 id="3-4-JsonSetter"><a href="#3-4-JsonSetter" class="headerlink" title="3.4. @JsonSetter"></a>3.4. @JsonSetter</h3><p>@JsonSetter是@JsonProperty的替代方法—它将方法标记为setter方法。</p><p>当我们需要读取一些JSON数据，但目标实体类与该数据不完全匹配时，这非常有用，因此我们需要调优流程以使其适合该数据。</p><p>在下面的例子中，我们将指定方法setTheName()作为MyBean实体中name属性的setter:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonSetter</span>(<span class="hljs-string">"name"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTheName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><p>现在，当我们需要unmarshall一些JSON数据-这是完美的工作:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingUsingJsonSetter_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    String json = <span class="hljs-string">"&#123;\"id\":1,\"name\":\"My bean\"&#125;"</span>;    MyBean bean = <span class="hljs-keyword">new</span> ObjectMapper()      .readerFor(MyBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(<span class="hljs-string">"My bean"</span>, bean.getTheName());&#125;</code></pre><h3 id="3-5-JsonDeserialize"><a href="#3-5-JsonDeserialize" class="headerlink" title="3.5. @JsonDeserialize"></a>3.5. @JsonDeserialize</h3><p>@JsonDeserialize表示使用自定义反序列化器。</p><p>让我们看看这是如何实现的-我们将使用@JsonDeserialize来反序列化eventDate属性与CustomDateDeserializer:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventWithSerializer</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@JsonDeserialize</span>(using = CustomDateDeserializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)    <span class="hljs-title">public</span> <span class="hljs-title">Date</span> <span class="hljs-title">eventDate</span></span>;&#125;</code></pre><p>这是自定义反序列化器:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDateDeserializer</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">StdDeserializer</span>&lt;<span class="hljs-title">Date</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SimpleDateFormat formatter      = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd-MM-yyyy hh:mm:ss"</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomDateDeserializer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomDateDeserializer</span><span class="hljs-params">(Class&lt;?&gt; vc)</span> </span>&#123;        <span class="hljs-keyword">super</span>(vc);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">deserialize</span><span class="hljs-params">(      JsonParser jsonparser, DeserializationContext context)</span>      <span class="hljs-keyword">throws</span> IOException </span>&#123;        String date = jsonparser.getText();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> formatter.parse(date);        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);        &#125;    &#125;&#125;</code></pre><p>这是背靠背的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingUsingJsonDeserialize_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    String json      = <span class="hljs-string">"&#123;"</span>name<span class="hljs-string">":"</span>party<span class="hljs-string">","</span>eventDate<span class="hljs-string">":"</span><span class="hljs-number">20</span>-<span class="hljs-number">12</span>-<span class="hljs-number">2014</span> <span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><span class="hljs-string">"&#125;"</span>;    SimpleDateFormat df      = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd-MM-yyyy hh:mm:ss"</span>);    EventWithSerializer event = <span class="hljs-keyword">new</span> ObjectMapper()      .readerFor(EventWithSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(      <span class="hljs-string">"20-12-2014 02:30:00"</span>, df.format(event.eventDate));&#125;</code></pre><h3 id="3-6-JsonAlias"><a href="#3-6-JsonAlias" class="headerlink" title="3.6 @JsonAlias"></a>3.6 @JsonAlias</h3><p>@JsonAlias在反序列化期间为属性定义一个或多个替代名称。<br>让我们通过一个简单的例子来看看这个注释是如何工作的:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliasBean</span> </span>&#123;    <span class="hljs-meta">@JsonAlias</span>(&#123; <span class="hljs-string">"fName"</span>, <span class="hljs-string">"f_name"</span> &#125;)    <span class="hljs-keyword">private</span> String firstName;       <span class="hljs-keyword">private</span> String lastName;&#125;</code></pre><p>在这里，我们有一个POJO，我们想用fName、f_name和firstName等值反序列化JSON到POJO的firstName变量中。<br>这里有一个测试，确保这个注释像expecte一样工作:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingUsingJsonAlias_thenCorrect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    String json = <span class="hljs-string">"&#123;\"fName\": \"John\", \"lastName\": \"Green\"&#125;"</span>;    AliasBean aliasBean = <span class="hljs-keyword">new</span> ObjectMapper().readerFor(AliasBean<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(<span class="hljs-string">"John"</span>, aliasBean.getFirstName());&#125;</code></pre><h2 id="4-Jackson属性包含注释"><a href="#4-Jackson属性包含注释" class="headerlink" title="4. Jackson属性包含注释"></a>4. Jackson属性包含注释</h2><h3 id="4-1-JsonIgnoreProperties"><a href="#4-1-JsonIgnoreProperties" class="headerlink" title="4.1. @JsonIgnoreProperties"></a>4.1. @JsonIgnoreProperties</h3><p>@JsonIgnoreProperties是一个类级注释，它标记Jackson将忽略的一个属性或一列属性。<br>让我们来看一个忽略属性id的例子:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonIgnoreProperties</span>(&#123; <span class="hljs-string">"id"</span> &#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanWithIgnore</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>下面是确保忽略发生的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonIgnoreProperties_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    BeanWithIgnore bean = <span class="hljs-keyword">new</span> BeanWithIgnore(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"id"</span>)));&#125;</code></pre><p>为了毫无例外地忽略JSON输入中的任何未知属性，我们可以对@JsonIgnoreProperties注释设置ignoreUnknown=true。</p><h3 id="4-2-JsonIgnore"><a href="#4-2-JsonIgnore" class="headerlink" title="4.2. @JsonIgnore"></a>4.2. @JsonIgnore</h3><p>@JsonIgnore注释用于在字段级别标记要忽略的属性。</p><p>让我们使用@JsonIgnore来忽略序列化中的属性id:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanWithIgnore</span> </span>&#123;    <span class="hljs-meta">@JsonIgnore</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>确保id被成功忽略的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonIgnore_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    BeanWithIgnore bean = <span class="hljs-keyword">new</span> BeanWithIgnore(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"id"</span>)));&#125;</code></pre><h3 id="4-3-JsonIgnoreType"><a href="#4-3-JsonIgnoreType" class="headerlink" title="4.3. @JsonIgnoreType"></a><strong>4.3. <em>@JsonIgnoreType</em></strong></h3><p>@JsonIgnoreType将注释类型的所有属性标记为忽略。<br>让我们使用注释来标记所有类型名称的属性被忽略:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> Name name;    <span class="hljs-meta">@JsonIgnoreType</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> </span>&#123;        <span class="hljs-keyword">public</span> String firstName;        <span class="hljs-keyword">public</span> String lastName;    &#125;&#125;</code></pre><p>这里有一个简单的测试，确保忽略工作正确:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonIgnoreType_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException, ParseException </span>&#123;    User.Name name = <span class="hljs-keyword">new</span> User.Name(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>);    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, name);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(user);    assertThat(result, containsString(<span class="hljs-string">"1"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"name"</span>)));    assertThat(result, not(containsString(<span class="hljs-string">"John"</span>)));&#125;</code></pre><h3 id="4-4-JsonInclude"><a href="#4-4-JsonInclude" class="headerlink" title="4.4. @JsonInclude"></a><strong>4.4. <em>@JsonInclude</em></strong></h3><p>我们可以使用@JsonInclude来排除具有空/空/默认值的属性。<br>让我们看一个例子-排除null从序列化:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude</span>(Include.NON_NULL)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>下面是完整的测试:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonInclude_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    MyBean bean = <span class="hljs-keyword">new</span> MyBean(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"1"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"name"</span>)));&#125;</code></pre><h3 id="4-5-JsonAutoDetect"><a href="#4-5-JsonAutoDetect" class="headerlink" title="4.5. @JsonAutoDetect"></a><strong>4.5. <em>@JsonAutoDetect</em></strong></h3><p>@JsonAutoDetect可以覆盖哪些属性可见，哪些不可见的默认语义。<br>让我们通过一个简单的例子来看看这个注释是如何非常有用的——让我们启用序列化私有属性:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonAutoDetect</span>(fieldVisibility = Visibility.ANY)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateBean</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonAutoDetect_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    PrivateBean bean = <span class="hljs-keyword">new</span> PrivateBean(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"1"</span>));    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));&#125;</code></pre><p><a name="JkWhc"></a></p><h2 id="5-Jackson多态类型处理注释"><a href="#5-Jackson多态类型处理注释" class="headerlink" title="5. Jackson多态类型处理注释"></a>5. Jackson多态类型处理注释</h2><p>接下来，让我们看看Jackson多态类型处理注释:</p><ul><li>@JsonTypeInfo——指示要在序列化中包含什么类型信息的详细信息</li><li>@JsonSubTypes——指示注释类型的子类型</li><li>@JsonTypeName—定义了一个用于注释类的逻辑类型名</li></ul><p>让我们看一个更复杂的例子，使用所有这三个——@JsonTypeInfo， @JsonSubTypes，和@JsonTypeName——来序列化/反序列化实体Zoo:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zoo</span> </span>&#123;    <span class="hljs-keyword">public</span> Animal animal;    <span class="hljs-meta">@JsonTypeInfo</span>(      use = JsonTypeInfo.Id.NAME,      include = As.PROPERTY,      property = <span class="hljs-string">"type"</span>)    <span class="hljs-meta">@JsonSubTypes</span>(&#123;        <span class="hljs-meta">@JsonSubTypes</span>.Type(value = Dog<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span> </span>= <span class="hljs-string">"dog"</span>),        <span class="hljs-meta">@JsonSubTypes</span>.Type(value = Cat<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span> </span>= <span class="hljs-string">"cat"</span>)    &#125;)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;        <span class="hljs-keyword">public</span> String name;    &#125;    <span class="hljs-meta">@JsonTypeName</span>(<span class="hljs-string">"dog"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> barkVolume;    &#125;    <span class="hljs-meta">@JsonTypeName</span>(<span class="hljs-string">"cat"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;        <span class="hljs-keyword">boolean</span> likesCream;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> lives;    &#125;&#125;</code></pre><p>当我们进行序列化时:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingPolymorphic_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    Zoo.Dog dog = <span class="hljs-keyword">new</span> Zoo.Dog(<span class="hljs-string">"lacy"</span>);    Zoo zoo = <span class="hljs-keyword">new</span> Zoo(dog);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writeValueAsString(zoo);    assertThat(result, containsString(<span class="hljs-string">"type"</span>));    assertThat(result, containsString(<span class="hljs-string">"dog"</span>));&#125;</code></pre><p>下面是将动物园实例与狗序列化将得到的结果:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"animal"</span>: &#123;        <span class="hljs-string">"type"</span>: <span class="hljs-string">"dog"</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"lacy"</span>,        <span class="hljs-string">"barkVolume"</span>: <span class="hljs-number">0</span>    &#125;&#125;</code></pre><p>现在反序列化-让我们从以下JSON输入开始:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"animal"</span>:&#123;        <span class="hljs-string">"name"</span>:<span class="hljs-string">"lacy"</span>,        <span class="hljs-string">"type"</span>:<span class="hljs-string">"cat"</span>    &#125;&#125;</code></pre><p>让我们看看它是如何被分解到一个动物园实例的:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDeserializingPolymorphic_thenCorrect</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> IOException </span>&#123;    String json = <span class="hljs-string">"&#123;\"animal\":&#123;\"name\":\"lacy\",\"type\":\"cat\"&#125;&#125;"</span>;    Zoo zoo = <span class="hljs-keyword">new</span> ObjectMapper()      .readerFor(Zoo<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">json</span>)</span>;    assertEquals(<span class="hljs-string">"lacy"</span>, zoo.animal.name);    assertEquals(Zoo.Cat<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">zoo</span>.<span class="hljs-title">animal</span>.<span class="hljs-title">getClass</span>())</span>;&#125;</code></pre><p><a name="EPNDX"></a></p><h2 id="6-Jackson通用注解"><a href="#6-Jackson通用注解" class="headerlink" title="6. Jackson通用注解"></a><strong>6. Jackson通用注解</strong></h2><p>接下来——让我们讨论Jackson的一些更通用的注释。<br><a name="yZcQ1"></a></p><h3 id="6-1-JsonProperty"><a href="#6-1-JsonProperty" class="headerlink" title="6.1. @JsonProperty"></a><strong>6.1. <em>@JsonProperty</em></strong></h3><p>我们可以添加@JsonProperty注释来表示JSON中的属性名。<br>当我们处理非标准的getter和setter时，让我们使用@JsonProperty来序列化/反序列化属性名:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@JsonProperty</span>(<span class="hljs-string">"name"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTheName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@JsonProperty</span>(<span class="hljs-string">"name"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTheName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><p>我们的测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenUsingJsonProperty_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    MyBean bean = <span class="hljs-keyword">new</span> MyBean(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, containsString(<span class="hljs-string">"1"</span>));    MyBean resultBean = <span class="hljs-keyword">new</span> ObjectMapper()      .readerFor(MyBean<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">readValue</span>(<span class="hljs-title">result</span>)</span>;    assertEquals(<span class="hljs-string">"My bean"</span>, resultBean.getTheName());&#125;</code></pre><p><a name="RbKDb"></a></p><h3 id="6-2-JsonFormat"><a href="#6-2-JsonFormat" class="headerlink" title="6.2. @JsonFormat"></a><strong>6.2. <em>@JsonFormat</em></strong></h3><p>@JsonFormat注释在序列化日期/时间值时指定一种格式。<br>在下面的例子中，我们使用@JsonFormat来控制属性eventDate的格式:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventWithFormat</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@JsonFormat</span>(      shape = JsonFormat.Shape.STRING,      pattern = <span class="hljs-string">"dd-MM-yyyy hh:mm:ss"</span>)    <span class="hljs-keyword">public</span> Date eventDate;&#125;</code></pre><p>下面是测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonFormat_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException, ParseException </span>&#123;    SimpleDateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd-MM-yyyy hh:mm:ss"</span>);    df.setTimeZone(TimeZone.getTimeZone(<span class="hljs-string">"UTC"</span>));    String toParse = <span class="hljs-string">"20-12-2014 02:30:00"</span>;    Date date = df.parse(toParse);    EventWithFormat event = <span class="hljs-keyword">new</span> EventWithFormat(<span class="hljs-string">"party"</span>, date);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(event);    assertThat(result, containsString(toParse));&#125;</code></pre><p><a name="gTZ8U"></a></p><h3 id="6-3-JsonUnwrapped"><a href="#6-3-JsonUnwrapped" class="headerlink" title="6.3. @JsonUnwrapped"></a><strong>6.3. <em>@JsonUnwrapped</em></strong></h3><p>@JsonUnwrapped定义了在序列化/反序列化时应该被解包装/扁平化的值。<br>我们来看看它是如何工作的;我们将使用注释来展开属性名:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnwrappedUser</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-meta">@JsonUnwrapped</span>    <span class="hljs-keyword">public</span> Name name;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> </span>&#123;        <span class="hljs-keyword">public</span> String firstName;        <span class="hljs-keyword">public</span> String lastName;    &#125;&#125;</code></pre><p>现在让我们序列化这个类的一个实例:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonUnwrapped_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException, ParseException </span>&#123;    UnwrappedUser.Name name = <span class="hljs-keyword">new</span> UnwrappedUser.Name(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>);    UnwrappedUser user = <span class="hljs-keyword">new</span> UnwrappedUser(<span class="hljs-number">1</span>, name);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(user);    assertThat(result, containsString(<span class="hljs-string">"John"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"name"</span>)));&#125;</code></pre><p>下面是输出的样子-静态嵌套类的字段与其他字段一起展开:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>,    <span class="hljs-string">"firstName"</span>:<span class="hljs-string">"John"</span>,    <span class="hljs-string">"lastName"</span>:<span class="hljs-string">"Doe"</span>&#125;</code></pre><p><a name="NqUJn"></a></p><h3 id="6-4-JsonView"><a href="#6-4-JsonView" class="headerlink" title="6.4. @JsonView"></a><strong>6.4. <em>@JsonView</em></strong></h3><p>@JsonView表示将包含该属性进行序列化/反序列化的视图。<br>我们将使用@JsonView来序列化项目实体的实例。<br>让我们从视图开始:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Views</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Public</span> </span>&#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Internal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Public</span> </span>&#123;&#125;&#125;</code></pre><p>现在这是Item实体，使用视图:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> </span>&#123;    <span class="hljs-meta">@JsonView</span>(Views.Public<span class="hljs-class">.<span class="hljs-keyword">class</span>)    <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">id</span></span>;    <span class="hljs-meta">@JsonView</span>(Views.Public<span class="hljs-class">.<span class="hljs-keyword">class</span>)    <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">itemName</span></span>;    <span class="hljs-meta">@JsonView</span>(Views.Internal<span class="hljs-class">.<span class="hljs-keyword">class</span>)    <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">ownerName</span></span>;&#125;</code></pre><p>最后-完整测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonView_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    Item item = <span class="hljs-keyword">new</span> Item(<span class="hljs-number">2</span>, <span class="hljs-string">"book"</span>, <span class="hljs-string">"John"</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writerWithView(Views.Public<span class="hljs-class">.<span class="hljs-keyword">class</span>)      .<span class="hljs-title">writeValueAsString</span>(<span class="hljs-title">item</span>)</span>;    assertThat(result, containsString(<span class="hljs-string">"book"</span>));    assertThat(result, containsString(<span class="hljs-string">"2"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"John"</span>)));&#125;</code></pre><p><a name="SWLxT"></a></p><h3 id="6-5-JsonManagedReference-JsonBackReference"><a href="#6-5-JsonManagedReference-JsonBackReference" class="headerlink" title="6.5. @JsonManagedReference, @JsonBackReference"></a><strong>6.5. <em>@JsonManagedReference, @JsonBackReference</em></strong></h3><p>@JsonManagedReference和@JsonBackReference注释可以处理父/子关系并在循环中工作。<br>在下面的例子中-我们使用@JsonManagedReference和@JsonBackReference来序列化我们的ItemWithRef实体:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemWithRef</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String itemName;    <span class="hljs-meta">@JsonManagedReference</span>    <span class="hljs-keyword">public</span> UserWithRef owner;&#125;</code></pre><p>我们的UserWithRef实体:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserWithRef</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-meta">@JsonBackReference</span>    <span class="hljs-keyword">public</span> List&lt;ItemWithRef&gt; userItems;&#125;</code></pre><p>测试:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJacksonReferenceAnnotation_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    UserWithRef user = <span class="hljs-keyword">new</span> UserWithRef(<span class="hljs-number">1</span>, <span class="hljs-string">"John"</span>);    ItemWithRef item = <span class="hljs-keyword">new</span> ItemWithRef(<span class="hljs-number">2</span>, <span class="hljs-string">"book"</span>, user);    user.addItem(item);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(item);    assertThat(result, containsString(<span class="hljs-string">"book"</span>));    assertThat(result, containsString(<span class="hljs-string">"John"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"userItems"</span>)));&#125;</code></pre><p><a name="N9f5i"></a></p><h3 id="6-6-JsonIdentityInfo"><a href="#6-6-JsonIdentityInfo" class="headerlink" title="6.6. @JsonIdentityInfo"></a><strong>6.6. <em>@JsonIdentityInfo</em></strong></h3><p>@JsonIdentityInfo表示在序列化/反序列化值时应该使用对象标识—例如，用于处理无限递归类型的问题。<br>在下面的例子中-我们有一个ItemWithIdentity实体，它与UserWithIdentity实体具有双向关系:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonIdentityInfo</span>(  generator = ObjectIdGenerators.PropertyGenerator<span class="hljs-class">.<span class="hljs-keyword">class</span>,  <span class="hljs-title">property</span> </span>= <span class="hljs-string">"id"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemWithIdentity</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String itemName;    <span class="hljs-keyword">public</span> UserWithIdentity owner;&#125;</code></pre><p>和UserWithIdentity实体:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonIdentityInfo</span>(  generator = ObjectIdGenerators.PropertyGenerator<span class="hljs-class">.<span class="hljs-keyword">class</span>,  <span class="hljs-title">property</span> </span>= <span class="hljs-string">"id"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserWithIdentity</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">public</span> List&lt;ItemWithIdentity&gt; userItems;&#125;</code></pre><p>现在，让我们看看无限递归问题是如何处理的:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonIdentityInfo_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    UserWithIdentity user = <span class="hljs-keyword">new</span> UserWithIdentity(<span class="hljs-number">1</span>, <span class="hljs-string">"John"</span>);    ItemWithIdentity item = <span class="hljs-keyword">new</span> ItemWithIdentity(<span class="hljs-number">2</span>, <span class="hljs-string">"book"</span>, user);    user.addItem(item);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(item);    assertThat(result, containsString(<span class="hljs-string">"book"</span>));    assertThat(result, containsString(<span class="hljs-string">"John"</span>));    assertThat(result, containsString(<span class="hljs-string">"userItems"</span>));&#125;</code></pre><p>下面是序列化的项目和用户的完整输出:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>,    <span class="hljs-string">"itemName"</span>: <span class="hljs-string">"book"</span>,    <span class="hljs-string">"owner"</span>: &#123;        <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>,        <span class="hljs-string">"userItems"</span>: [            <span class="hljs-number">2</span>        ]    &#125;&#125;</code></pre><p><a name="ASuNM"></a></p><h3 id="6-7-JsonFilter"><a href="#6-7-JsonFilter" class="headerlink" title="6.7. @JsonFilter"></a><strong>6.7. <em>@JsonFilter</em></strong></h3><p>@JsonFilter注释指定要在序列化期间使用的过滤器。<br>让我们看一个例子;首先，我们定义实体，并指向过滤器:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonFilter</span>(<span class="hljs-string">"myFilter"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanWithFilter</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>现在，在完整的测试中，我们定义了过滤器——它排除了序列化中除了name之外的所有其他属性:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingJsonFilter_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    BeanWithFilter bean = <span class="hljs-keyword">new</span> BeanWithFilter(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>);    FilterProvider filters      = <span class="hljs-keyword">new</span> SimpleFilterProvider().addFilter(        <span class="hljs-string">"myFilter"</span>,        SimpleBeanPropertyFilter.filterOutAllExcept(<span class="hljs-string">"name"</span>));    String result = <span class="hljs-keyword">new</span> ObjectMapper()      .writer(filters)      .writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"id"</span>)));&#125;</code></pre><p><a name="ike8t"></a></p><h2 id="7-Jackson自定义注释"><a href="#7-Jackson自定义注释" class="headerlink" title="7. Jackson自定义注释"></a>7. Jackson自定义注释</h2><p>接下来，让我们看看如何创建自定义Jackson注释。我们可以使用@JacksonAnnotationsInside注释:</p><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)    <span class="hljs-meta">@JacksonAnnotationsInside</span>    <span class="hljs-meta">@JsonInclude</span>(Include.NON_NULL)    <span class="hljs-meta">@JsonPropertyOrder</span>(&#123; <span class="hljs-string">"name"</span>, <span class="hljs-string">"id"</span>, <span class="hljs-string">"dateCreated"</span> &#125;)    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomAnnotation &#123;&#125;</code></pre><p>现在，如果我们对一个实体使用新的注释:</p><pre><code class="hljs java"><span class="hljs-meta">@CustomAnnotation</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanWithCustomAnnotation</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">public</span> Date dateCreated;&#125;</code></pre><p>我们可以看到它是如何将现有的注解组合成一个更简单的、自定义的注解，我们可以使用它作为速记:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingCustomAnnotation_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    BeanWithCustomAnnotation bean      = <span class="hljs-keyword">new</span> BeanWithCustomAnnotation(<span class="hljs-number">1</span>, <span class="hljs-string">"My bean"</span>, <span class="hljs-keyword">null</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"My bean"</span>));    assertThat(result, containsString(<span class="hljs-string">"1"</span>));    assertThat(result, not(containsString(<span class="hljs-string">"dateCreated"</span>)));&#125;</code></pre><p>序列化过程的输出:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"name"</span>:<span class="hljs-string">"My bean"</span>,    <span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>&#125;</code></pre><p><a name="Uto7K"></a></p><h2 id="8-Jackson-MixIn-注解"><a href="#8-Jackson-MixIn-注解" class="headerlink" title="8. Jackson MixIn 注解"></a><strong>8. Jackson MixIn 注解</strong></h2><p>接下来——让我们看看如何使用Jackson MixIn注释。<br>让我们使用MixIn注释——例如——忽略类型User的属性:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String itemName;    <span class="hljs-keyword">public</span> User owner;&#125;<span class="hljs-meta">@JsonIgnoreType</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMixInForIgnoreType</span> </span>&#123;&#125;</code></pre><p>让我们来看看这是怎么回事:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenSerializingUsingMixInAnnotation_thenCorrect</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;    Item item = <span class="hljs-keyword">new</span> Item(<span class="hljs-number">1</span>, <span class="hljs-string">"book"</span>, <span class="hljs-keyword">null</span>);    String result = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(item);    assertThat(result, containsString(<span class="hljs-string">"owner"</span>));    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    mapper.addMixIn(User<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">MyMixInForIgnoreType</span>.<span class="hljs-title">class</span>)</span>;    result = mapper.writeValueAsString(item);    assertThat(result, not(containsString(<span class="hljs-string">"owner"</span>)));&#125;</code></pre><p><a name="mqKJV"></a></p><h2 id="9-禁用Jackson注解"><a href="#9-禁用Jackson注解" class="headerlink" title="9. 禁用Jackson注解"></a>9. 禁用Jackson注解</h2><p>最后，让我们看看如何禁用所有Jackson注释。我们可以通过禁用MapperFeature来做到这一点。如下例所示:</p><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude</span>(Include.NON_NULL)<span class="hljs-meta">@JsonPropertyOrder</span>(&#123; <span class="hljs-string">"name"</span>, <span class="hljs-string">"id"</span> &#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">public</span> String name;&#125;</code></pre><p>现在，禁用注释后，这些应该没有效果，库的默认值应该适用:</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whenDisablingAllAnnotations_thenAllDisabled</span><span class="hljs-params">()</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;    MyBean bean = <span class="hljs-keyword">new</span> MyBean(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);    ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    mapper.disable(MapperFeature.USE_ANNOTATIONS);    String result = mapper.writeValueAsString(bean);    assertThat(result, containsString(<span class="hljs-string">"1"</span>));    assertThat(result, containsString(<span class="hljs-string">"name"</span>));</code></pre><p>禁用注释之前序列化的结果:</p><pre><code class="hljs java">&#123;<span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>&#125;</code></pre><p>禁用注释后序列化的结果:</p><pre><code class="hljs java">&#123;    <span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>,    <span class="hljs-string">"name"</span>:<span class="hljs-keyword">null</span>&#125;</code></pre><p><a name="PmJqL"></a></p><h2 id="10-结论"><a href="#10-结论" class="headerlink" title="10. 结论"></a>10. 结论</h2><p>本教程对Jackson注释进行了深入的研究，只触及了正确使用它们所能获得的灵活性的表面。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot注解</title>
    <link href="/2020/08/06/spring-boot-annotations/"/>
    <url>/2020/08/06/spring-boot-annotations/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot注解"><a href="#Spring-Boot注解" class="headerlink" title="Spring Boot注解"></a>Spring Boot注解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring Boot通过其自动配置特性使Spring的配置更加容易。</p><p>在这个快速教程中，我们将探索<code>org.springframework.boot.autoconfigure</code>和 <code>org.springframework.boot.autoconfigure.condition</code>包。</p><h2 id="2-SpringBootApplication"><a href="#2-SpringBootApplication" class="headerlink" title="2. @SpringBootApplication"></a>2. @SpringBootApplication</h2><p>我们使用这个注解来标记Spring Boot应用程序的主类:</p><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(VehicleFactoryApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p><code>@SpringBootApplication</code>用默认属性封装了<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>注解。</p><h2 id="3-EnableAutoConfiguration"><a href="#3-EnableAutoConfiguration" class="headerlink" title="3. @EnableAutoConfiguration"></a>3. @EnableAutoConfiguration</h2><p><code>@EnableAutoConfiguration</code>，顾名思义，启用自动配置。这意味着Spring Boot在它的类路径中查找自动配置bean，并自动应用它们。</p><p>注意，我们必须使用@Configuration的注释:</p><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAutoConfiguration</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre><h2 id="4-自动配置条件"><a href="#4-自动配置条件" class="headerlink" title="4. 自动配置条件"></a>4. 自动配置条件</h2><p>通常，当我们编写自定义的自动配置时，我们希望Spring有条件地使用它们。我们可以通过本节中的注释实现这一点。</p><p>我们可以将注释放在<code>@Configuration</code>类或<code>@Bean</code>方法上。</p><h3 id="4-1-ConditionalOnClass-和-ConditionalOnMissingClass"><a href="#4-1-ConditionalOnClass-和-ConditionalOnMissingClass" class="headerlink" title="4.1. @ConditionalOnClass 和 @ConditionalOnMissingClass"></a>4.1. @ConditionalOnClass 和 @ConditionalOnMissingClass</h3><p>使用这些条件，Spring只会在注释参数中的类存在/不存在的情况下使用标记的自动配置bean:</p><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnClass</span>(DataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">class</span> <span class="hljs-title">MySQLAutoconfiguration</span> </span>&#123;    <span class="hljs-comment">//...</span>&#125;</code></pre><h3 id="4-2-ConditionalOnBean-和-ConditionalOnMissingBean"><a href="#4-2-ConditionalOnBean-和-ConditionalOnMissingBean" class="headerlink" title="4.2. @ConditionalOnBean 和 @ConditionalOnMissingBean"></a>4.2. @ConditionalOnBean 和 @ConditionalOnMissingBean</h3><p>我们可以使用这些注释来定义基于特定bean的存在或不存在的条件:</p><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnBean</span>(name = <span class="hljs-string">"dataSource"</span>)<span class="hljs-function">LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactory</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="4-3-ConditionalOnProperty"><a href="#4-3-ConditionalOnProperty" class="headerlink" title="4.3. @ConditionalOnProperty"></a>4.3. @ConditionalOnProperty</h3><p>通过这个注释，我们可以为属性的值设置条件:</p><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnProperty</span>(    name = <span class="hljs-string">"usemysql"</span>,    havingValue = <span class="hljs-string">"local"</span>)<span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="4-4-ConditionalOnResource"><a href="#4-4-ConditionalOnResource" class="headerlink" title="4.4. @ConditionalOnResource"></a>4.4. @ConditionalOnResource</h3><p>我们可以让Spring只在有特定资源时使用定义:</p><pre><code class="hljs Java"><span class="hljs-meta">@ConditionalOnResource</span>(resources = <span class="hljs-string">"classpath:mysql.properties"</span>)<span class="hljs-function">Properties <span class="hljs-title">additionalProperties</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="4-5-ConditionalOnWebApplication-和-ConditionalOnNotWebApplication"><a href="#4-5-ConditionalOnWebApplication-和-ConditionalOnNotWebApplication" class="headerlink" title="4.5. @ConditionalOnWebApplication 和 @ConditionalOnNotWebApplication"></a>4.5. @ConditionalOnWebApplication 和 @ConditionalOnNotWebApplication</h3><p>通过这些注释，我们可以根据当前应用程序是否是web应用程序来创建条件:</p><pre><code class="hljs Java"><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-function">HealthCheckController <span class="hljs-title">healthCheckController</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="4-6-ConditionalExpression"><a href="#4-6-ConditionalExpression" class="headerlink" title="4.6. @ConditionalExpression"></a>4.6. @ConditionalExpression</h3><p>我们可以在更复杂的情况下使用此注释。当SpEL表达式被赋值为真时，Spring将使用标记的定义:</p><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnExpression</span>(<span class="hljs-string">"$&#123;usemysql&#125; &amp;&amp; $&#123;mysqlserver == 'local'&#125;"</span>)<span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="4-7-Conditional"><a href="#4-7-Conditional" class="headerlink" title="4.7. @Conditional"></a>4.7. @Conditional</h3><p>对于更复杂的条件，我们可以创建一个评估自定义条件的类。我们告诉Spring使用<code>@Conditional</code>:</p><pre><code class="hljs Java"><span class="hljs-meta">@Conditional</span>(HibernateCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">Properties</span> <span class="hljs-title">additionalProperties</span>() </span>&#123;  <span class="hljs-comment">//...</span>&#125;</code></pre><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本文中，我们概述了如何调优自动配置过程，并为自定义自动配置bean提供条件。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 调度注解</title>
    <link href="/2020/08/06/spring-scheduling-annotations/"/>
    <url>/2020/08/06/spring-scheduling-annotations/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>当单线程执行任务不能满足需求时，我们可以使用<code>org.springframework.scheduling.annotation</code>包的注解。</p><p>在这个快速教程中，我们将探索Spring调度注解。</p><h2 id="2-EnableAsync"><a href="#2-EnableAsync" class="headerlink" title="2. @EnableAsync"></a>2. @EnableAsync</h2><p>通过这个注释，我们可以在Spring中启用异步功能。</p><p>我们必须使用<code>@Configuration</code>:</p><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAsync</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre><p>现在，我们已经启用了异步调用，我们可以使用<code>@Async</code>来定义支持它的方法。</p><h2 id="3-EnableScheduling"><a href="#3-EnableScheduling" class="headerlink" title="3. @EnableScheduling"></a>3. @EnableScheduling</h2><p>通过这个注释，我们可以在应用程序中启用调度。</p><p>我们还必须将它与@Configuration一起使用:</p><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableScheduling</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre><p>因此，我们现在可以使用<code>@Scheduled</code>定期运行方法。</p><h2 id="4-Async"><a href="#4-Async" class="headerlink" title="4. @Async"></a>4. @Async</h2><p>我们可以定义希望在不同线程上执行的方法，从而异步地运行它们。</p><p>为了实现这一点，我们可以用@Async注释方法:</p><pre><code class="hljs Java"><span class="hljs-meta">@Async</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">repairCar</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>如果我们将这个注释应用到一个类，那么所有方法都将被异步调用。</p><p>注意，我们需要使用@EnableAsync或XML配置启用异步调用，以使该注释工作。</p><h2 id="5-Scheduled"><a href="#5-Scheduled" class="headerlink" title="5. @Scheduled"></a>5. @Scheduled</h2><p>如果我们需要一个方法定期执行，我们可以使用这个注释:</p><pre><code class="hljs Java"><span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">10000</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkVehicle</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>我们可以使用它在固定的时间间隔内执行一个方法，或者我们可以使用类似cron的表达式对其进行微调。</p><p><code>@Scheduled</code>利用了Java 8的重复注释功能，这意味着我们可以用它多次标记一个方法:</p><pre><code class="hljs Java"><span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">10000</span>)<span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 * * * * MON-FRI"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkVehicle</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>注意，用@Scheduled注释的方法应该有一个空返回类型。</p><p>此外，我们必须使这个注释的调度能够与@EnableScheduling或XML配置一起工作。</p><h2 id="6-Schedules"><a href="#6-Schedules" class="headerlink" title="6. @Schedules"></a>6. @Schedules</h2><p>我们可以使用这个注释来指定多个<code>@Scheduled</code>规则:</p><pre><code class="hljs Java"><span class="hljs-meta">@Schedules</span>(&#123;<span class="hljs-meta">@Scheduled</span>(fixedRate = <span class="hljs-number">10000</span>),<span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 * * * * MON-FRI"</span>)&#125;)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkVehicle</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>注意，自从Java 8以来，我们可以通过上面描述的重复注释功能实现相同的功能。</p><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>在本文中，我们概述了最常见的Spring调度注释。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Web注解</title>
    <link href="/2020/08/06/spring-web-annotations/"/>
    <url>/2020/08/06/spring-web-annotations/</url>
    
    <content type="html"><![CDATA[<p><a name="UQpVy"></a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本教程中，我们将探索来自<code>org.springframework.web.bind.annotation</code>  的Spring Web注解。<br><a name="9cM9q"></a></p><h2 id="2-RequestMapping"><a href="#2-RequestMapping" class="headerlink" title="2. @RequestMapping"></a>2. @RequestMapping</h2><p>简单地说，@RequestMapping标记了@Controller类内部的请求处理程序方法;它可以配置使用:</p><ul><li>path, name, value：方法映射到哪个URL</li><li>method： 兼容的HTTP方法</li><li>params： 根据HTTP参数的存在、不存在或值过滤请求</li><li>headers：根据HTTP头的存在、不存在或值过滤请求</li><li>consumes：该方法可以在HTTP请求体中使用哪些媒体类型</li><li>produces：该方法可以在HTTP响应体中生成哪些媒体类型</li></ul><p>下面是一个简单的例子:</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/vehicles/home"</span>, method = RequestMethod.GET)    <span class="hljs-function">String <span class="hljs-title">home</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;    &#125;&#125;</code></pre><p>如果我们在类级别上应用这个注解，我们可以为@Controller类中的所有处理程序方法提供默认设置。唯一的例外是URL, Spring不会用方法级别设置覆盖它，而是添加了两个路径部分。<br>例如，下面的配置与上面的配置具有相同的效果:</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/vehicles"</span>, method = RequestMethod.GET)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/home"</span>)    <span class="hljs-function">String <span class="hljs-title">home</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;    &#125;&#125;</code></pre><p>此外，@GetMapping、@PostMapping、@PutMapping、@DeleteMapping和@PatchMapping是@RequestMapping的不同变体，它们的HTTP方法已经分别设置为GET、POST、PUT、DELETE和PATCH。自Spring 4.3发布以来就可以使用了。</p><p><a name="WwiLL"></a></p><h2 id="3-RequestBody"><a href="#3-RequestBody" class="headerlink" title="3. @RequestBody"></a>3. <em>@RequestBody</em></h2><p>让我们转到@RequestBody——它将HTTP请求体映射到一个对象:</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/save"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveVehicle</span><span class="hljs-params">(@RequestBody Vehicle vehicle)</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>反序列化是自动的，取决于请求的内容类型。<br><a name="sEKrI"></a></p><h2 id="4-PathVariable"><a href="#4-PathVariable" class="headerlink" title="4. @PathVariable"></a>4. <em>@PathVariable</em></h2><p>接下来，让我们讨论@PathVariable。<br>此注解指示方法参数绑定到URI模板变量。我们可以用@RequestMapping注解指定URI模板，并用@PathVariable将方法参数绑定到模板的一个部分。<br>我们可以通过名称或其别名，value参数来实现这一点:</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)<span class="hljs-function">Vehicle <span class="hljs-title">getVehicle</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">long</span> id) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>如果模板中部件的名称与方法参数的名称相匹配，我们不需要在注解中指定:</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)<span class="hljs-function">Vehicle <span class="hljs-title">getVehicle</span><span class="hljs-params">(@PathVariable <span class="hljs-keyword">long</span> id)</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>此外，我们可以通过将参数required设置为false来标记一个可选的path变量:</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)<span class="hljs-function">Vehicle <span class="hljs-title">getVehicle</span><span class="hljs-params">(@PathVariable(required = <span class="hljs-keyword">false</span>)</span> <span class="hljs-keyword">long</span> id) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><a name="BDUT9"></a></p><h2 id="5-RequestParam"><a href="#5-RequestParam" class="headerlink" title="5. @RequestParam"></a>5. <em>@RequestParam</em></h2><p>我们使用@RequestParam来访问HTTP请求参数:</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span><span class="hljs-function">Vehicle <span class="hljs-title">getVehicleByParam</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"id"</span>)</span> <span class="hljs-keyword">long</span> id) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>它具有与@PathVariable注解相同的配置选项。<br>除了这些设置，使用@RequestParam，我们可以在Spring在请求中没有发现值或空值时指定注入值。要实现这一点，我们必须设置defaultValue参数。<br>提供默认值隐式设置required为false:</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/buy"</span>)<span class="hljs-function">Car <span class="hljs-title">buyCar</span><span class="hljs-params">(@RequestParam(defaultValue = <span class="hljs-string">"5"</span>)</span> <span class="hljs-keyword">int</span> seatCount) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>除了参数，我们还可以访问其他HTTP请求部分:cookie和头。我们可以分别使用注解@CookieValue和@RequestHeader来访问它们。<br>我们可以像配置@RequestParam一样配置它们。<br><a name="dk8Ws"></a></p><h2 id="6-响应处理注解"><a href="#6-响应处理注解" class="headerlink" title="6. 响应处理注解"></a>6. 响应处理注解</h2><p>在下一节中，我们将看到在Spring MVC中操作HTTP响应的最常见注解。<br><a name="X6lxC"></a></p><h3 id="6-1-ResponseBody"><a href="#6-1-ResponseBody" class="headerlink" title="6.1. @ResponseBody"></a>6.1. <em>@ResponseBody</em></h3><p>如果我们用@ResponseBody标记一个请求处理程序方法，Spring将该方法的结果作为响应本身:</p><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)<span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>;&#125;</code></pre><p>如果我们用这个注解一个@Controller类，所有请求处理程序方法都将使用它。<br><a name="jA56P"></a></p><h3 id="6-2-ExceptionHandler"><a href="#6-2-ExceptionHandler" class="headerlink" title="6.2. @ExceptionHandler"></a>6.2. <em>@ExceptionHandler</em></h3><p>通过这个注解，我们可以声明一个自定义错误处理程序方法。当请求处理程序方法抛出任何指定的异常时，Spring将调用此方法。<br>捕获的异常可以作为参数传递给方法:</p><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(IllegalArgumentException<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">void</span> <span class="hljs-title">onIllegalArgumentException</span>(<span class="hljs-title">IllegalArgumentException</span> <span class="hljs-title">exception</span>) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><a name="XYlN6"></a></p><h3 id="6-3-ResponseStatus"><a href="#6-3-ResponseStatus" class="headerlink" title="6.3. @ResponseStatus"></a>6.3. <em>@ResponseStatus</em></h3><p>如果我们用这个注解一个请求处理程序方法，我们可以指定响应所需的HTTP状态。我们可以使用code参数声明状态代码，或者使用它的别名(value参数)声明状态代码。<br>同样，我们可以使用理由论证来提供一个理由。<br>我们也可以与@ExceptionHandler一起使用:</p><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(IllegalArgumentException<span class="hljs-class">.<span class="hljs-keyword">class</span>)@<span class="hljs-title">ResponseStatus</span>(<span class="hljs-title">HttpStatus</span>.<span class="hljs-title">BAD_REQUEST</span>)<span class="hljs-title">void</span> <span class="hljs-title">onIllegalArgumentException</span>(<span class="hljs-title">IllegalArgumentException</span> <span class="hljs-title">exception</span>) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><br><a name="rFgZ1"></a>## 7. Other Web Annotations有些注解不直接管理HTTP请求或响应。在下一节中，我们将介绍最常见的一些。<a name="AY8Bw"></a>### 7.1. _@Controller_我们可以用@Controller定义Spring MVC控制器。<p><a name="0rBHY"></a></p><h3 id="7-2-RestController"><a href="#7-2-RestController" class="headerlink" title="7.2. @RestController"></a>7.2. <em>@RestController</em></h3><p>@RestController组合了@Controller和@ResponseBody。<br>因此，以下声明是等价的:</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleRestController</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleRestController</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p><a name="2ptsv"></a></p><h3 id="7-3-ModelAttribute"><a href="#7-3-ModelAttribute" class="headerlink" title="7.3. @ModelAttribute"></a>7.3. <em>@ModelAttribute</em></h3><p>通过这个注解，我们可以通过提供模型键来访问已经在MVC @Controller模型中的元素:</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/assemble"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assembleVehicle</span><span class="hljs-params">(@ModelAttribute(<span class="hljs-string">"vehicle"</span>)</span> Vehicle vehicleInModel) </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>就像@PathVariable和@RequestParam一样，如果参数同名，我们不需要指定模型键:</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/assemble"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assembleVehicle</span><span class="hljs-params">(@ModelAttribute Vehicle vehicle)</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>除此之外，@ModelAttribute还有另一个用途:如果我们用它注解一个方法，Spring会自动将该方法的返回值添加到模型中:</p><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span>(<span class="hljs-string">"vehicle"</span>)<span class="hljs-function">Vehicle <span class="hljs-title">getVehicle</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>像以前一样，我们不需要指定模型键，Spring默认使用方法名:</p><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span><span class="hljs-function">Vehicle <span class="hljs-title">vehicle</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>在Spring调用请求处理程序方法之前，它调用类中所有@ModelAttribute注解的方法。<br><a name="K6fLF"></a></p><h3 id="7-4-CrossOrigin"><a href="#7-4-CrossOrigin" class="headerlink" title="7.4. @CrossOrigin"></a>7.4. <em>@CrossOrigin</em></h3><p>@CrossOrigin为带注解的请求处理程序方法启用跨域通信:</p><pre><code class="hljs java"><span class="hljs-meta">@CrossOrigin</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)<span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span>;&#125;</code></pre><p>如果我们用它标记一个类，它将应用于其中的所有请求处理程序方法。<br>我们可以使用这个注解的参数微调CORS行为。</p><p><a name="bpOLE"></a></p><h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h2><p>在本文中，我们了解了如何使用Spring MVC处理HTTP请求和响应。<br></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring核心注解</title>
    <link href="/2020/08/06/spring-core-annotations/"/>
    <url>/2020/08/06/spring-core-annotations/</url>
    
    <content type="html"><![CDATA[<p><a name="sGDYO"></a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>我们可以通过使用 <code>org.springframework.beans.factory.annotation</code> 包和 <code>org.springframework.context.annotation</code> 包中的注解，来使用依赖注入功能。</p><p><a name="gn773"></a></p><h2 id="2-DI注解"><a href="#2-DI注解" class="headerlink" title="2. DI注解"></a>2. DI注解</h2><p><a name="yJW7E"></a></p><h3 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1 @Autowired"></a>2.1 @Autowired</h3><p>我们可以使用 <code>@Autowired</code> 来标记一个依赖项，这个依赖项是Spring要解决和注入的。我们可以将此注释与构造函数、setter或字段注入一起使用。</p><p><strong>构造函数注入</strong><br><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    Engine engine;    <span class="hljs-meta">@Autowired</span>    Car(Engine engine) &#123;        <span class="hljs-keyword">this</span>.engine = engine;    &#125;&#125;</code></pre></p><p><strong>Setter注入</strong><br><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    Engine engine;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setEngine</span><span class="hljs-params">(Engine engine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.engine = engine;    &#125;&#125;</code></pre></p><p><strong>字段注入</strong><br><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    Engine engine;&#125;</code></pre></p><p><code>@Autowired</code> 有一个布尔参数叫做 <code>required</code> ，默认值为 <code>true</code> 。当它找不到合适的bean进行连接时，它会对Spring的行为进行调优。当为真时，抛出异常，否则不连接任何内容。<br>注意，如果我们使用构造函数注入，所有构造函数参数都是强制的。<br>从4.3版本开始，我们不需要显式地用 <code>@Autowired</code> 注解构造函数，除非我们声明至少两个构造函数。</p><p><a name="xtgAs"></a></p><h3 id="2-2-Bean"><a href="#2-2-Bean" class="headerlink" title="2.2. @Bean"></a>2.2. @Bean</h3><p><code>@Bean</code> 标记了一个工厂方法，它实例化一个Spring bean:<br><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function">Engine <span class="hljs-title">engine</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Engine();&#125;</code></pre></p><p>当需要返回类型的新实例时，Spring调用这些方法。</p><p>结果bean的名称与工厂方法相同。如果我们想要命名它不同，我们可以这样做的名称或该注释的值参数(参数值是参数名称的别名):<br><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(<span class="hljs-string">"engine"</span>)<span class="hljs-function">Engine <span class="hljs-title">getEngine</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Engine();&#125;</code></pre></p><p>注意，所有用@Bean注释的方法都必须位于@Configuration类中。</p><p><a name="wJm0r"></a></p><h3 id="2-3-Qualifier"><a href="#2-3-Qualifier" class="headerlink" title="2.3. @Qualifier"></a>2.3. @Qualifier</h3><p>我们使用@Qualifier和@Autowired来提供我们想在不明确的情况下使用的bean id或bean名称。</p><p>例如，下面两个bean实现了相同的接口:<br><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;&#125;</code></pre></p><p>如果Spring需要注入一个Vehicle bean，它最终会得到多个匹配的定义。在这种情况下，我们可以使用@Qualifier注释显式地提供bean的名称。</p><p>使用构造函数注入:<br><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>Biker(<span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"bike"</span>) Vehicle vehicle) &#123;    <span class="hljs-keyword">this</span>.vehicle = vehicle;&#125;</code></pre></p><p>使用setter注入:<br><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setVehicle</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"bike"</span>)</span> Vehicle vehicle) </span>&#123;    <span class="hljs-keyword">this</span>.vehicle = vehicle;&#125;</code></pre></p><p>或者<br><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"bike"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setVehicle</span><span class="hljs-params">(Vehicle vehicle)</span> </span>&#123;    <span class="hljs-keyword">this</span>.vehicle = vehicle;&#125;</code></pre></p><p>使用字段注入<br><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"bike"</span>)Vehicle vehicle;</code></pre></p><p><a name="oEYFg"></a></p><h3 id="2-4-Required"><a href="#2-4-Required" class="headerlink" title="2.4. @Required"></a>2.4. @Required</h3><p>@Required在setter方法上标记我们想要通过XML填充的依赖:<br><pre><code class="hljs java"><span class="hljs-meta">@Required</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>&#123;    <span class="hljs-keyword">this</span>.color = color;&#125;</code></pre></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.baeldung.annotations.Bike"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"green"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>否则，将抛出BeanInitializationException。</p><p><a name="waEUd"></a></p><h3 id="2-5-Value"><a href="#2-5-Value" class="headerlink" title="2.5. @Value"></a>2.5. @Value</h3><p>我们可以使用@Value将属性值注入bean。它兼容构造函数、setter和字段注入。</p><ul><li>构造函数注入<pre><code class="hljs java">Engine(<span class="hljs-meta">@Value</span>(<span class="hljs-string">"8"</span>) <span class="hljs-keyword">int</span> cylinderCount) &#123;    <span class="hljs-keyword">this</span>.cylinderCount = cylinderCount;&#125;</code></pre></li></ul><p>setter方法注入<br><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCylinderCount</span><span class="hljs-params">(@Value(<span class="hljs-string">"8"</span>)</span> <span class="hljs-keyword">int</span> cylinderCount) </span>&#123;    <span class="hljs-keyword">this</span>.cylinderCount = cylinderCount;&#125;</code></pre></p><p>或者<br><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"8"</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCylinderCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cylinderCount)</span> </span>&#123;    <span class="hljs-keyword">this</span>.cylinderCount = cylinderCount;&#125;</code></pre></p><ul><li>字段注入<pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"8"</span>)<span class="hljs-keyword">int</span> cylinderCount;</code></pre></li></ul><p>当然，注入静态值是没有用的。因此，我们可以在@Value中使用占位符字符串来连接在外部源(例如.properties或.yaml文件)中定义的值。</p><p>让我们假设下面的.properties文件:<br><pre><code class="hljs java">engine.fuelType=petrol</code></pre></p><p>我们可以注入引擎的价值。燃料类型与以下:<br><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;engine.fuelType&#125;"</span>)String fuelType;</code></pre></p><p>我们甚至可以在SpEL中使用@Value。</p><p><a name="PCSdw"></a></p><h3 id="2-6-DependsOn"><a href="#2-6-DependsOn" class="headerlink" title="2.6. @DependsOn"></a>2.6. @DependsOn</h3><p>我们可以使用这个注释使Spring在被注释的bean之前初始化其他bean。通常，该行为是自动的，基于bean之间显式的依赖关系。</p><p>我们只在依赖项是隐式的时候才需要这个注释，例如，JDBC驱动程序加载或静态变量初始化。</p><p>我们可以在依赖类上使用@DependsOn来指定依赖bean的名称。注释的value参数需要一个包含依赖项bean名称的数组:<br><pre><code class="hljs java"><span class="hljs-meta">@DependsOn</span>(<span class="hljs-string">"engine"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;&#125;</code></pre></p><p>另外，如果我们用@Bean注释定义一个bean，那么工厂方法应该用@DependsOn注释:<br><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@DependsOn</span>(<span class="hljs-string">"fuel"</span>)<span class="hljs-function">Engine <span class="hljs-title">engine</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Engine();&#125;</code></pre></p><p><a name="6M8m3"></a></p><h3 id="2-7-Lazy"><a href="#2-7-Lazy" class="headerlink" title="2.7. @Lazy"></a>2.7. @Lazy</h3><p>当我们想惰性地初始化我们的bean时，我们使用@Lazy。默认情况下，Spring会在应用程序上下文启动/引导时急切地创建所有单例bean。<br>但是，在某些情况下，我们需要在请求bean时创建它，而不是在应用程序启动时。</p><p>这个注释的行为取决于我们将其精确放置的位置。我们可以把它放在:</p><ul><li>一个带@Bean注释的bean工厂方法，以延迟方法调用(因此创建了bean)</li><li>一个@Configuration类和所有包含的@Bean方法都会受到影响</li><li>一个@Component类(不是@Configuration类)将延迟初始化这个bean</li><li>一个@Autowired构造函数、setter或字段，用来惰性地加载依赖项本身(通过代理)</li></ul><p>该注释有一个名为value的参数，默认值为true。重写默认行为是有用的。</p><p>例如，当全局设置是延迟的时候，将bean标记为急切加载，或者在一个@Configuration类中配置特定的@Bean方法来急切加载，这个@Configuration类标记为@Lazy:<br><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Lazy</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@Lazy</span>(<span class="hljs-keyword">false</span>)    <span class="hljs-function">Engine <span class="hljs-title">engine</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Engine();    &#125;&#125;</code></pre></p><p><a name="DGYVW"></a></p><h3 id="2-8-Lookup"><a href="#2-8-Lookup" class="headerlink" title="2.8. @Lookup"></a>2.8. @Lookup</h3><p>带有@Lookup注释的方法告诉Spring在我们调用该方法时返回该方法的返回类型的实例。</p><p><a name="PNBUo"></a></p><h3 id="2-9-Primary"><a href="#2-9-Primary" class="headerlink" title="2.9. @Primary"></a>2.9. @Primary</h3><p>有时我们需要定义相同类型的多个bean。在这些情况下，注入将不会成功，因为Spring不知道我们需要哪个bean。<br>我们已经看到了处理这个场景的一个选项:用@Qualifier标记所有连接点，并指定所需bean的名称。<br>然而，大多数时候我们需要一个特定的bean，很少需要其他bean。我们可以使用@Primary来简化这种情况:如果我们用@Primary标记最常用的bean，它将在不合格的注入点上被选择:<br><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Primary</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    Vehicle vehicle;&#125;<span class="hljs-meta">@Component</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Biker</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"bike"</span>)    Vehicle vehicle;&#125;</code></pre></p><p>在前面的示例中，Car是主要的车辆。因此，在Driver类中，Spring注入一个Car bean。当然，在Biker bean中，字段vehicle的值将是一个Bike对象，因为它是限定的。<br><a name="voYNt"></a></p><h3 id="2-10-Scope"><a href="#2-10-Scope" class="headerlink" title="2.10. @Scope"></a>2.10. @Scope</h3><p>我们使用@Scope来定义@Component类或@Bean定义的范围。它可以是单例、原型、请求、会话、全局会话或一些自定义范围。<br>例如:<br><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Scope</span>(<span class="hljs-string">"prototype"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> </span>&#123;&#125;</code></pre></p><p><a name="cAupG"></a></p><h2 id="3-上下文配置的注释"><a href="#3-上下文配置的注释" class="headerlink" title="3. 上下文配置的注释"></a>3. 上下文配置的注释</h2><p>我们可以使用本节中描述的注释配置应用程序上下文。</p><p><a name="GKi4n"></a></p><h3 id="3-1-Profile"><a href="#3-1-Profile" class="headerlink" title="3.1. @Profile"></a>3.1. @Profile</h3><p>如果我们希望Spring仅在某个特定的配置文件处于活动状态时才使用@Component类或@Bean方法，我们可以用@Profile标记它。我们可以用注释的值参数来配置配置文件的名称:<br><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Profile</span>(<span class="hljs-string">"sportDay"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Vehicle</span> </span>&#123;&#125;</code></pre></p><p><a name="pTKns"></a></p><h3 id="3-2-Import"><a href="#3-2-Import" class="headerlink" title="3.2. @Import"></a>3.2. @Import</h3><p>我们可以使用特定的@Configuration类，而无需对该注释进行组件扫描。我们可以为这些类提供@Import的value参数:<br><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(VehiclePartSupplier<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre></p><p><a name="1CF5h"></a></p><h3 id="3-3-ImportResource"><a href="#3-3-ImportResource" class="headerlink" title="3.3. @ImportResource"></a>3.3. @ImportResource</h3><p>我们可以使用这个注释导入XML配置。我们可以用locations参数指定XML文件的位置，或者用它的别名value参数:<br><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ImportResource</span>(<span class="hljs-string">"classpath:/annotations.xml"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre></p><p><a name="4nf37"></a></p><h3 id="3-4-PropertySource"><a href="#3-4-PropertySource" class="headerlink" title="3.4. @PropertySource"></a>3.4. @PropertySource</h3><p>通过这个注释，我们可以为应用程序设置定义属性文件:<br><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/annotations.properties"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre></p><p>@PropertySource利用了Java 8的重复注释功能，这意味着我们可以用它多次标记一个类:<br><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/annotations.properties"</span>)<span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/vehicle-factory.properties"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre></p><p><a name="OHAyR"></a></p><h3 id="3-5-PropertySources"><a href="#3-5-PropertySources" class="headerlink" title="3.5. @PropertySources"></a>3.5. @PropertySources</h3><p>我们可以使用这个注释来指定多个@PropertySource配置:<br><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@PropertySources</span>(&#123;    <span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/annotations.properties"</span>),    <span class="hljs-meta">@PropertySource</span>(<span class="hljs-string">"classpath:/vehicle-factory.properties"</span>)&#125;)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VehicleFactoryConfig</span> </span>&#123;&#125;</code></pre></p><p>注意，自从Java 8以来，我们可以通过上面描述的重复注释功能实现相同的功能。</p><p><a name="ZiR8M"></a></p><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>在本文中，我们概述了最常见的Spring core注释。我们了解了如何配置bean连接和应用程序上下文，以及如何标记用于组件扫描的类。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular之自定义组件添加默认样式</title>
    <link href="/2020/01/21/angular-zhi-zi-ding-yi-zu-jian-tian-jia-mo-ren-yang-shi/"/>
    <url>/2020/01/21/angular-zhi-zi-ding-yi-zu-jian-tian-jia-mo-ren-yang-shi/</url>
    
    <content type="html"><![CDATA[<p>Angular的核心思想之一就是：组件化。组件化可以使我们的代码更好的复用。</p><p>在使用官方提供的Angular库<a href="https://material.angular.io/" target="_blank" rel="noopener">Angular Material</a>时，细心的同学就会发现，Material的每一个组件都有它自己样式，如：</p><ul><li><strong>按钮</strong>：<code>mat-button</code></li><li><strong>工具条</strong>：<code>mat-toolbar</code></li><li><strong>表格</strong>：<code>mat-table</code></li><li>etc.</li></ul><p>每个组件添加自己独有的样式，增加css作用域的控制，实现了样式的隔离。</p><p>那么，如果给一个自定义组件添加默认样式呢？接下来我们介绍三种方法来实现我们的目标。</p><h2 id="方法一：host"><a href="#方法一：host" class="headerlink" title="方法一：host"></a>方法一：host</h2><p>在组件的<code>@Component</code>装饰器中提供了<code>host</code>属性，该属性可以为我们提供很多功能的支持，其中一项就是给组件添加样式。</p><p>以Material中的Table为例：</p><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;  moduleId: <span class="hljs-built_in">module</span>.id,  selector: <span class="hljs-string">'mat-table, table[mat-table]'</span>,  exportAs: <span class="hljs-string">'matTable'</span>,  template: CDK_TABLE_TEMPLATE,  styleUrls: [<span class="hljs-string">'table.css'</span>],  host: &#123;    <span class="hljs-string">'class'</span>: <span class="hljs-string">'mat-table'</span>,  &#125;,  providers: [&#123;provide: CdkTable, useExisting: MatTable&#125;],  encapsulation: ViewEncapsulation.None,  <span class="hljs-comment">// See note on CdkTable for explanation on why this uses the default change detection strategy.</span>  <span class="hljs-comment">// tslint:disable-next-line:validate-decorators</span>  changeDetection: ChangeDetectionStrategy.Default,&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MatTable&lt;T&gt; <span class="hljs-keyword">extends</span> CdkTable&lt;T&gt; &#123;  <span class="hljs-comment">/** Overrides the sticky CSS class set by the `CdkTable`. */</span>  <span class="hljs-keyword">protected</span> stickyCssClass = <span class="hljs-string">'mat-table-sticky'</span>;&#125;</code></pre><p>在MatTable的源码中，我们可以看到为host属性设置了<code>&#39;class&#39;: &#39;mat-table&#39;</code>，在我们使用MatTable组件时，就会添加上默认的样式: <code>mat-table</code>.</p><blockquote><p><strong>注意</strong></p><p>虽然在Angular中提供了host属性，并且官方的Material库也是使用该属性实现了很多功能，但是，在Angular编码规范中却不推荐使用该方法。详见：<a href="https://angular.cn/guide/styleguide#hostlistenerhostbinding-decorators-versus-host-metadata" target="_blank" rel="noopener">HostListener 和 HostBinding 装饰器 vs. 组件元数据 host</a></p></blockquote><h2 id="方法二：HostBinding"><a href="#方法二：HostBinding" class="headerlink" title="方法二：HostBinding"></a>方法二：HostBinding</h2><p>如方法一中注意事项中提到的，官方不推荐使用<code>host</code>属性，推荐使用<code>@HostBinding</code>装饰器来实现<code>host</code>的关于dom属性相关的功能。</p><p>还是以MatTable为例，需要做一下改造来实现相应的功能：</p><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;  moduleId: <span class="hljs-built_in">module</span>.id,  selector: <span class="hljs-string">'mat-table, table[mat-table]'</span>,  exportAs: <span class="hljs-string">'matTable'</span>,  template: CDK_TABLE_TEMPLATE,  styleUrls: [<span class="hljs-string">'table.css'</span>],<span class="hljs-comment">//   host: &#123;</span><span class="hljs-comment">//     'class': 'mat-table',</span><span class="hljs-comment">//   &#125;,</span>  providers: [&#123;provide: CdkTable, useExisting: MatTable&#125;],  encapsulation: ViewEncapsulation.None,  <span class="hljs-comment">// See note on CdkTable for explanation on why this uses the default change detection strategy.</span>  <span class="hljs-comment">// tslint:disable-next-line:validate-decorators</span>  changeDetection: ChangeDetectionStrategy.Default,&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MatTable&lt;T&gt; <span class="hljs-keyword">extends</span> CdkTable&lt;T&gt; &#123;  <span class="hljs-comment">/** Overrides the sticky CSS class set by the `CdkTable`. */</span>  <span class="hljs-keyword">protected</span> stickyCssClass = <span class="hljs-string">'mat-table-sticky'</span>;  <span class="hljs-comment">// 使用HostBinding装饰器</span>  <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'class.mat-table'</span>) clz = <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="方法三：Renderer2"><a href="#方法三：Renderer2" class="headerlink" title="方法三：Renderer2"></a>方法三：Renderer2</h2><p><code>Renderer2</code>是Angular的渲染引擎，我们可以通过它来为自定义组件添加默认样式。</p><p>还是以MatTable为例，需要做一下改造来实现相应的功能：</p><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;  moduleId: <span class="hljs-built_in">module</span>.id,  selector: <span class="hljs-string">'mat-table, table[mat-table]'</span>,  exportAs: <span class="hljs-string">'matTable'</span>,  template: CDK_TABLE_TEMPLATE,  styleUrls: [<span class="hljs-string">'table.css'</span>],<span class="hljs-comment">//   host: &#123;</span><span class="hljs-comment">//     'class': 'mat-table',</span><span class="hljs-comment">//   &#125;,</span>  providers: [&#123;provide: CdkTable, useExisting: MatTable&#125;],  encapsulation: ViewEncapsulation.None,  <span class="hljs-comment">// See note on CdkTable for explanation on why this uses the default change detection strategy.</span>  <span class="hljs-comment">// tslint:disable-next-line:validate-decorators</span>  changeDetection: ChangeDetectionStrategy.Default,&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MatTable&lt;T&gt; <span class="hljs-keyword">extends</span> CdkTable&lt;T&gt; &#123;  <span class="hljs-comment">/** Overrides the sticky CSS class set by the `CdkTable`. */</span>  <span class="hljs-keyword">protected</span> stickyCssClass = <span class="hljs-string">'mat-table-sticky'</span>;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">render: Renderer2, eleRef: ElementRef</span>) &#123;      render.addClass(eleRef.nativeElement, <span class="hljs-string">'mat-table'</span>);  &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多时候，实现一个功能的方法有很多，需要我们不断的去挖掘，去思考。条条大路通罗马，只要努力了总会有收获。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码Review最佳实践</title>
    <link href="/2019/11/29/0020-code-review-best-practice/"/>
    <url>/2019/11/29/0020-code-review-best-practice/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/01/21/d4zatYNGZIxVrsS.png" srcset="/img/loading.gif" alt></p><p>在实际工作中，经常会遇到项目交接或者二次开发的情况，在这个过程中，我们经常会听到“这是什么垃圾代码啊”。有时候我们翻看自己几年前写的代码，也会忍不住鄙视自己。</p><p>在软件开发过程中，代码Review是一个可以提高代码质量，统一代码规范，分享技术知识，从而形成增长团队的有效手段。</p><p>在代码Review过程中，存在两个角色：</p><ul><li>提交者。提交者就是代码的提交人，他发起了Review事件。同样也可以称作被审查者。</li><li>审查者。审查者是对代码进行Review的人。</li></ul><p>在本文中，主要涉及了以下内容：</p><ul><li>为什么要代码Review</li><li>何时代码Review</li><li>准备代码Review</li><li>进行代码Review</li><li>代码Review示例</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>通过代码Review可以提供代码质量，并且我们还可以通过代码Review来提高自我的能力。<br>比如：</p><ul><li>通过代码Review，审查人员可以看到本次变更的内容：处理TODO，代码优化等。提交者的代码被认可，可以提升自我成就感。</li><li>可以分享知识：<ul><li>代码Review可以是提交内容更加明确，并且使团队成员更进一步了解项目，为以后的开发做知识积累</li><li>团队成员可以从提交者的代码中学习新的技术、算法等等</li><li>通过代码Review，提交者可以从审查人员的评审中获得相关的技术知识</li><li>可以增加团队交流，形成增长团队</li></ul></li><li>可以形成统一的代码规范，方便阅读和理解</li><li>审查者因为没有完整的上下文，只看到代码片段，更容易发现问题，提高代码片段的可复用率</li><li>更容易检查拼写错误</li><li>可以避免常规的安全问题等</li></ul><h2 id="Review什么"><a href="#Review什么" class="headerlink" title="Review什么"></a>Review什么</h2><p>对于代码Review什么内容，可以有很多的方面，如：变量命名、代码结构、算法、架构、安全等等。具体内容没有一个统一的标准，但是在一个团队中，是需要形成一个统一的标准的，这样更有益于团队的可持续发展。</p><h2 id="什么时候Review"><a href="#什么时候Review" class="headerlink" title="什么时候Review"></a>什么时候Review</h2><p>代码需要在测试、CI之后，在合并上线分支之前。测试、CI等确保了逻辑是正确的。因为需要保证线上的代码是最优的，所以Review需要在合并分支之前。</p><h2 id="准备Review"><a href="#准备Review" class="headerlink" title="准备Review"></a>准备Review</h2><p>提交者需要提交一个便于Review的代码，避免浪费审查者的精力和时间：</p><ul><li>范围和大小。一次提交Review的代码不应过大，如果太大需要耗费一天的时间，那就说明提交Review的代码不够合理，应分解成多次Review提交。</li><li>只提交已完成的，并且自检及自测过的代码。提交Review的代码，一定是已经开发完的，否则Review将没有意义。它也一定是经过自测的代码，对没有通过自测的代码进行Review，同样没有意义。</li><li>重构不应该改变代码行为，同样改变代码行为的不应该包含重构内容。每次提交的变更目标应该是明确的，且是单一的，不能将重构和开发新功能合并到一起提交。</li></ul><h2 id="进行Review"><a href="#进行Review" class="headerlink" title="进行Review"></a>进行Review</h2><p>代码Review一定要及时，不能因为卡在没有进行Review而影响项目进度。如果审查者时间不允许，应立即告知提交者，让他找其他人对代码进行Review。</p><p>作为审查者，有责任执行编码标准并保持质量水准。 审查代码更多是一门艺术，而不是一门科学。 学习它的唯一方法就是去做。 有经验的审查者需要考虑让经验不足的审查者先Review，以此来提高他们的Review经验。<br> <br>假设提交者遵循上面的指南（尤其是关于自我检查并确保代码可以运行的准则），审查者在代码Review过程中应注意的事项应注意一下事项：</p><ul><li>目标<ul><li>这段代码是否达到了提交者的目的？ 每次更改都应有特定的原因（新功能，重构，错误修正等）。 提交的代码是否真的达到了这个目的？</li></ul></li><li>提问<ul><li>函数和类应该存在是有原因的。 当原因对于审查者来说不清楚时，这可能表明该代码需要重写、添加注释等等。</li></ul></li><li>实现<ul><li>考虑一下您将如何解决问题。 如果不同，那为什么呢？ 您的代码可以处理更多（边缘）情况吗？ 它更短、更容易、更清洁、更快、更安全，但在功能上等效吗？ 您发现当前代码未捕获的异常了吗？</li><li>您看到有用的抽象的潜力吗？ 部分重复的代码通常表示可以提取出更抽象或更通用的功能，然后在不同的上下文中重新使用。</li><li>像对手一样思考，但要对此保持友善。 尝试通过提出有问题的配置、输入数据来破坏他们的代码，从而找出程序里面的漏洞。</li><li>考虑库或现有产品代码。 当某人重新实现现有功能时，通常是因为他们不知道该功能已经存在。 有时，有意复制代码或功能，例如，以避免依赖。 在这种情况下，代码注释可以阐明意图。 现有库是否已提供引入的功能？</li><li>更改是否遵循标准模式？ 既定的代码库通常表现出围绕命名约定，程序逻辑分解，数据类型定义等的模式。通常希望根据现有模式来实现更改</li><li>更改是否添加了编译时或运行时依赖项（尤其是在子项目之间）？ 我们希望保持我们的产品松散耦合，并尽可能减少依赖。 对依赖项和构建系统的更改应进行严格审查。</li></ul></li><li>易读性与风格<ul><li>考虑一下您的阅读经验。 您是否在合理的时间内掌握了这些概念？ 流程是否合理，变量和方法名称是否易于理解？ 您是否能够跟踪多个文件或功能？ 您是否因名称不一致而推迟？</li><li>该代码是否遵守编码准则和代码样式？ 代码在样式，API约定等方面是否与项目一致？ 如上所述，我们更喜欢使用自动化工具解决代码规范。</li><li>此代码是否有TODO？ TODO只是堆积在代码中，并且随着时间的流逝变得陈旧。 让作者在GitHub Issues或JIRA上提交记录，并将发行号附加到TODO。 建议的代码更改不应包含注释掉的代码。</li></ul></li><li>可维修性<ul><li>阅读测试。 如果没有测试，应该进行测试，请提交者写一些测试。 真正不可测试的功能很少见，而不幸的是，未经测试的功能实现很常见。 自己检查测试：它们是否涵盖了有趣的案例？ 它们可读吗？ CR是否会降低总体测试覆盖率？ 考虑一下此代码可能如何破解。 测试的样式标准通常与核心代码不同，但仍然很重要。</li><li>此CR是否存在破坏测试代码，登台堆栈或集成测试的风险？ 这些通常不作为预提交/合并检查的一部分进行检查，但是让它们崩溃对每个人来说都是痛苦的。 要查找的特定内容是：删除测试实用程序或模式，配置更改以及工件布局/结构更改。</li><li>此更改会破坏向后兼容性吗？ 如果是这样，此时可以合并更改，还是应该将其推送到更高版本中？ 中断可能包括数据库或架构更改，公共API更改，用户工作流更改等。</li><li>此代码是否需要集成测试？ 有时，单独使用单元测试无法对代码进行充分的测试，尤其是当代码与外部系统或配置交互时。</li><li>留下有关代码级文档，注释和提交消息的反馈。 多余的注释使代码混乱，而简短的提交消息使将来的贡献者迷惑不解。 这并不总是适用，但是高质量的评论和提交消息将使他们自己付出代价。 （想想您曾经看到过出色的或真正可怕的提交信息或评论。）</li><li>外部文档是否已更新？ 如果您的项目维护自述文件，CHANGELOG或其他文档，是否已对其进行更新以反映更改？ 过时的文档可能比没有文档更令人困惑，并且将来对其进行修复要比现在进行更新要花费更多的成本。</li></ul></li><li>安全<ul><li>验证API端点是否执行与其余代码库一致的适当授权和身份验证。 检查其他常见弱点，例如弱配置，恶意用户输入，缺少日志事件等。如有疑问，请向应用程序安全专家咨询Review。</li></ul></li><li>评论<ul><li>简洁、友好、可操作的。不要忘了赞扬简洁、可读、高效、优雅的代码。 相反，拒绝或不批准代码Review并不粗鲁。 如果更改是多余的或无关紧要的，请拒绝并说明。</li></ul></li><li>面对面Review<ul><li>对于大多数代码检查而言，基于异步差异的工具（例如Reviewable，Gerrit或GitHub）都是不错的选择。 当在同一台屏幕或投影仪前亲自进行或通过VTC或屏幕共享工具远程执行时，复杂的更改或具有不同专业知识或经验的各方之间的评论可以更有效。</li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在以下示例中，建议的评论注释在代码块中由 <code>// R：...</code> 注释标识。</p><h3 id="命名不一致"><a href="#命名不一致" class="headerlink" title="命名不一致"></a>命名不一致</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> countTotalPageVisits;  <span class="hljs-comment">//R: 变量命名不一致</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> uniqueUsersCount;&#125;</code></pre><h3 id="方法签名不一致"><a href="#方法签名不一致" class="headerlink" title="方法签名不一致"></a>方法签名不一致</h3><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;  <span class="hljs-comment">/** Returns &#123;<span class="hljs-doctag">@link</span> Optional#empty&#125; if s cannot be extracted. */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;String&gt; <span class="hljs-title">extractString</span><span class="hljs-params">(String s)</span></span>;    <span class="hljs-comment">/** Returns null if &#123;<span class="hljs-doctag">@code</span> s&#125; cannot be rewritten. */</span>  <span class="hljs-comment">//R: 应该协调返回值：在这里也使用Optional &lt;&gt;</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rewriteString</span><span class="hljs-params">(String s)</span></span>;&#125;</code></pre><h3 id="类库使用"><a href="#类库使用" class="headerlink" title="类库使用"></a>类库使用</h3><pre><code class="hljs java"><span class="hljs-comment">//R: 使用Guava's MapJoiner替换以下方法</span><span class="hljs-function">String <span class="hljs-title">joinAndConcatenate</span><span class="hljs-params">(Map&lt;String, String&gt; map, String keyValueSeparator, String keySeparator)</span></span>;</code></pre><h3 id="个人倾向"><a href="#个人倾向" class="headerlink" title="个人倾向"></a>个人倾向</h3><pre><code class="hljs java"><span class="hljs-comment">//R: nit: I usually prefer numFoo over fooCount; up to you,</span><span class="hljs-comment">//  but we should keep it consistent in this project</span><span class="hljs-keyword">int</span> dayCount;</code></pre><h3 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h3><pre><code class="hljs java"><span class="hljs-comment">//R: 代码处理numIterations+1的情况，如果是故意这样处理，是否考虑变更numIterations值</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= numIterations; ++i) &#123;  ...&#125;</code></pre><h3 id="架构疑虑"><a href="#架构疑虑" class="headerlink" title="架构疑虑"></a>架构疑虑</h3><pre><code class="hljs java"><span class="hljs-comment">//R: I think we should avoid the dependency on OtherService.</span><span class="hljs-comment">// Can we discuss this in person?</span>otherService.call();</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过有效的代码Review，可以提高项目代码质量，使团队开发人员形成统一风格，并同步项目细节。同时还可以提高团队人员的知识，提升自我。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Angular核心技术之组件</title>
    <link href="/2019/08/02/angular-he-xin-ji-zhu-zhi-zu-jian/"/>
    <url>/2019/08/02/angular-he-xin-ji-zhu-zhi-zu-jian/</url>
    
    <content type="html"><![CDATA[<h1 id="组件-component"><a href="#组件-component" class="headerlink" title="组件(component)"></a>组件(component)</h1><p>Angular 组件是一个由模板组成的元素，通过组件来渲染我们的应用。</p><p><a name="FEhYx"></a></p><h2 id="一个简单组件"><a href="#一个简单组件" class="headerlink" title="一个简单组件"></a>一个简单组件</h2><p>Angular提供了@Component装饰器来，我们需要使用该装饰器来定义一个组件。</p><p>@Component内置了一些参数：</p><ul><li><code>providers</code> : 用来声明一些资源，这些资源可以在构造函数中通过DI注入。</li><li><code>selector</code> :  在html中适应的查询选择器，Angular会使用定义的组件替换html中的该选择器</li><li><code>styles</code> :  定义一组内联样式，数组类型</li><li><code>styleUrls</code> ：一组样式文件</li><li><code>template</code> ：内联模板</li><li><code>templateUrl</code> ：模板文件</li></ul><p>例子：</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Component</span>(&#123;selector: <span class="hljs-string">'app-required'</span>,  styleUrls: [<span class="hljs-string">'requried.component.scss'</span>],  templateUrl: <span class="hljs-string">'required.component.html'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> RequiredComponent &#123; &#125;</code></pre><p><a name="wtq6O"></a></p><h2 id="模板-amp-样式"><a href="#模板-amp-样式" class="headerlink" title="模板 &amp; 样式"></a>模板 &amp; 样式</h2><p>模板是html文件，里面可以包含一些逻辑。</p><p>我们可以通过两种方式来指定组件的模板：</p><ol><li>通过文件路径来指定模板</li></ol><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;  templateUrl: <span class="hljs-string">'hero.component.html'</span>&#125;)</code></pre><ol start="2"><li>通过使用内联方式指定模板</li></ol><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;  template: <span class="hljs-string">'&lt;div&gt;This is a template.&lt;/div&gt;'</span>&#125;)</code></pre><p>组件中定义的模板可以包含样式，我们可以在@Component中定义当前模板的样式。在组件中定义的样式和应用的style.css中定义是有区别的。组件中定义的任何样式，作用域都被限制在此组件内。<br>例如，我们在组件中添加样式：</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">background</span>: red;&#125;</code></pre><p>组件模板内的所有的div背景都会渲染成红色，但是其他组件中的div不会受到此样式的影响。<br>编译后的代码类似如下这样：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[_ngcontent-c1]</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>我们可以通过两种方式为组件的模板定义样式：</p><ol><li>通过文件的方式</li></ol><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span>(&#123;  styleUrls: [<span class="hljs-string">'hero.component.css'</span>]&#125;)</code></pre><ol start="2"><li>通过内联的方式</li></ol><pre><code class="hljs typescript">styles: [<span class="hljs-string">`div &#123;background: red;&#125;`</span>]</code></pre><p><a name="kG6AR"></a></p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>不论模版还是样式，组件都提供来两种方式来声明它们。理论上我们可以随心所欲，自由组合。但实际的开发过程中我们还是需要有自己的原则：根据实际内容的多少来选择声明方式，内容较多就选择文件方式，这样可以使代码结构更加清晰，整洁。</p><p><a name="H1L5Y"></a></p><h2 id="组件测试"><a href="#组件测试" class="headerlink" title="组件测试"></a>组件测试</h2><p><code>hero.component.html</code> </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"submit($event)"</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"form"</span> <span class="hljs-attr">novalidate</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span> Show hero name<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p><code>hero.component.ts</code> </p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; FromControl, FormGroup, Validators &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;<span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Component</span>(&#123;  slector: <span class="hljs-string">'app-hero'</span>,  templateUrl: <span class="hljs-string">'hero.component.html'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroComponent &#123;  <span class="hljs-keyword">public</span> form = <span class="hljs-keyword">new</span> FormGroup(&#123;    name: <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>, Validators.required)  &#125;);  submit(event) &#123;    <span class="hljs-built_in">console</span>.log(event);    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.form.controls.name.value);  &#125;&#125;</code></pre><p><code>hero.component.spec.ts</code> </p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ComponentFixture, TestBed, <span class="hljs-keyword">async</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/testing'</span>;<span class="hljs-keyword">import</span> &#123; HeroComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'hero.component'</span>;<span class="hljs-keyword">import</span> &#123; ReactiveFormsModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;describe(<span class="hljs-string">'HeroComponent'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> component: HeroComponent;  <span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;HeroComponent&gt;;  beforeEach(<span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    TestBed.configureTestingModule(&#123;      declarations: [HeroComponent],      imports: [ReactiveFormsModule]    &#125;).compileComponents();    fixtrue = TestBed.createComponent(HeroComponent);    component = fixtrue.componentInstance;    fixture.detectChanges();  &#125;));  it(<span class="hljs-string">'should be created'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    expect(component).toBetruthy();  &#125;);  it(<span class="hljs-string">'should log hero name in the console when user submit form'</span>, <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> heroName = <span class="hljs-string">'Saitama'</span>;    <span class="hljs-keyword">const</span> element = &lt;HTMLFormElement&gt;fixture.debugElement.nativeElement.querySelector(<span class="hljs-string">'form'</span>);    spyOn(<span class="hljs-built_in">console</span>, <span class="hljs-string">'log'</span>).and.callThrough();    component.form.controls[<span class="hljs-string">'name'</span>].setValue(heroName);    element.querySelector(<span class="hljs-string">'button'</span>).click();    fixture.whenStable().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      fixture.detectChanges();      expect(<span class="hljs-built_in">console</span>.log).toHaveBeenCalledWith(heroName);    &#125;);  &#125;));  it(<span class="hljs-string">'should validate name field as required'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    component.form.controls[<span class="hljs-string">'name'</span>].setValue(<span class="hljs-string">''</span>);    expect(component.form.invalid).toBeTruthy();  &#125;);&#125;)</code></pre><p><a name="RVpq8"></a></p><h2 id="嵌套组件"><a href="#嵌套组件" class="headerlink" title="嵌套组件"></a>嵌套组件</h2><p>组件是通过selector来渲染的，所以我们就可以通过嵌套的方式来使用所有的组件。</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Component</span>(&#123;  selector: <span class="hljs-string">'app-required'</span>,  template: <span class="hljs-string">`&#123;&#123;name&#125;&#125; is required.`</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> RequiredComponent &#123;  <span class="hljs-meta">@Input</span>()  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;&#125;</code></pre><p>我们就可以在其他的组件中，通过使用app-required标签来嵌套我们的组件。</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Component</span>(&#123;  selector: <span class="hljs-string">'app-sample'</span>,  template: <span class="hljs-string">`  &lt;input type="text" name="heroName" /&gt;&lt;app-required name="Hero Name"&gt;&lt;/app-required&gt;`</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SampleComponent &#123;  <span class="hljs-meta">@Input</span>()  <span class="hljs-keyword">public</span> name = <span class="hljs-string">''</span>;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何实现Angular Material自定义主题</title>
    <link href="/2019/08/02/ru-he-shi-xian-angular-material-zi-ding-yi-zhu-ti/"/>
    <url>/2019/08/02/ru-he-shi-xian-angular-material-zi-ding-yi-zhu-ti/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是主题"><a href="#什么是主题" class="headerlink" title="什么是主题"></a>什么是主题</h2><p><strong>主题</strong>就是一组要应用于 Angular Material 的颜色，也可以理解成应用的皮肤。在以前使用 QQ 空间的时候，腾讯就做好多些空间皮肤（主题）进行出售。现在 Android 手机系统也都有好多主题，让用户自己手机系统的主题。</p><p>在 Angular Material 中，主题由多个调色板组成。具体来说，包括：</p><ul><li>主调色板：那些在所有屏幕和组件中广泛使用的颜色。</li><li>强调调色板：那些用于浮动按钮和可交互元素的颜色。</li><li>警告调色板：那些用于传达出错状态的颜色。</li><li>前景调色板：那些用于问题和图标的颜色。</li><li>背景色调色板：那些用做原色背景色的颜色。</li></ul><p><a name="93502147"></a></p><h2 id="预定义主题"><a href="#预定义主题" class="headerlink" title="预定义主题"></a>预定义主题</h2><p>Angular Material 自带了几个预构建主题的 <code>css</code> 文件。这些主题文件包含了所有核心样式（所有组件中通用的），这样你的应用就只需要包含单个 <code>css</code> 文件了。</p><p>有效的预定义主题有：</p><ul><li><code>deeppurple-amber.css</code></li><li><code>indigo-pink.css</code></li><li><code>pink-bluegrey.css</code></li><li><code>purple-green.css</code></li></ul><p>你可以从 <code>@angular/material/prebuilt-themes</code> 直接把主题文件包含到应用中。</p><p>如果你正在使用 Angular CLI，那么只需要在 <code>styles.css</code> 文件中添加一行就可以了：</p><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">'@angular/material/prebuilt-themes/deeppurple-amber.css'</span>;</code></pre><p>如果你使用的 <code>ng add @angular/material</code> 添加的依赖，Material Schematics 会在控制台给出交互信息，在选择相应的主题后，会自动将样式添加到 <code>angular.json</code> 中：</p><pre><code class="hljs json">"styles": [              "./node_modules/@angular/material/prebuilt-themes/indigo-pink.css",              "src/styles.scss"   ],</code></pre><p><a name="76fe220f"></a></p><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p>自定义主题文件要做两件事：</p><ol><li>导入 <code>mat-core()</code> 混入器。它包括所有功能多个组件使用的公共样式。<strong>在你的应用中，应该只包含一次该混入器。</strong>如果包含多次，你的应用就会出现这些公共样式的多个副本。</li><li>定义一个主题数据结构，它由多个调色板组成。该对象可以用 <code>mat-light-theme</code> 或 <code>mat-dark-theme</code> 函数构建。然后，函数的输出会传给 <code>angular-material-theme</code> 混入器，它会输出所有该主题所对应的样式。</li></ol><p>典型的主题文件定义如下：</p><pre><code class="hljs scss"><span class="hljs-comment">// 引入material的theming，其中包含了混入器</span><span class="hljs-keyword">@import</span> <span class="hljs-string">'~@angular/material/theming'</span>;<span class="hljs-comment">// 导入核心混入器，确保只导入一次</span><span class="hljs-keyword">@include</span> mat-core();<span class="hljs-comment">// 定义主调色板</span><span class="hljs-variable">$candy-app-primary</span>: mat-palette(<span class="hljs-variable">$mat-indigo</span>);<span class="hljs-comment">// 强调调色板</span><span class="hljs-variable">$candy-app-accent</span>:  mat-palette(<span class="hljs-variable">$mat-pink</span>, A200, A100, A400);<span class="hljs-comment">// 警告调色板</span><span class="hljs-variable">$candy-app-warn</span>:    mat-palette(<span class="hljs-variable">$mat-red</span>);<span class="hljs-comment">// 创建一个light主题</span><span class="hljs-variable">$candy-app-theme</span>: mat-light-theme(<span class="hljs-variable">$candy-app-primary</span>, <span class="hljs-variable">$candy-app-accent</span>, <span class="hljs-variable">$candy-app-warn</span>);<span class="hljs-comment">// 启动主题</span><span class="hljs-keyword">@include</span> angular-material-theme(<span class="hljs-variable">$candy-app-theme</span>);</code></pre><p><a name="a54b8e84"></a></p><h2 id="多重主题"><a href="#多重主题" class="headerlink" title="多重主题"></a>多重主题</h2><p>你可以通过多次调用 <code>angular-material-theme</code> 混入器，每次包含一些额外的 CSS 类，来为应用创建多个主题。</p><p>记住，只能包含 <code>@mat-core</code> 一次；不应该让每个主题都包含它一次。</p><p>多重主题的例子：</p><pre><code class="hljs scss"><span class="hljs-comment">// 引入material的theming，其中包含了混入器</span><span class="hljs-keyword">@import</span> <span class="hljs-string">'~@angular/material/theming'</span>;<span class="hljs-comment">// Plus imports for other components in your app.</span><span class="hljs-comment">// 导入核心混入器，确保只导入一次</span><span class="hljs-keyword">@include</span> mat-core();<span class="hljs-comment">// 定义主调色板</span><span class="hljs-variable">$candy-app-primary</span>: mat-palette(<span class="hljs-variable">$mat-indigo</span>);<span class="hljs-comment">// 强调调色板</span><span class="hljs-variable">$candy-app-accent</span>:  mat-palette(<span class="hljs-variable">$mat-pink</span>, A200, A100, A400);<span class="hljs-comment">// 创建一个light主题</span><span class="hljs-variable">$candy-app-theme</span>:   mat-light-theme(<span class="hljs-variable">$candy-app-primary</span>, <span class="hljs-variable">$candy-app-accent</span>);<span class="hljs-comment">// 将candy-app-theme定义成默认主题</span><span class="hljs-keyword">@include</span> angular-material-theme(<span class="hljs-variable">$candy-app-theme</span>);<span class="hljs-comment">// 定义个深色主题.</span><span class="hljs-variable">$dark-primary</span>: mat-palette(<span class="hljs-variable">$mat-blue-grey</span>);<span class="hljs-variable">$dark-accent</span>:  mat-palette(<span class="hljs-variable">$mat-amber</span>, A200, A100, A400);<span class="hljs-variable">$dark-warn</span>:    mat-palette(<span class="hljs-variable">$mat-deep-orange</span>);<span class="hljs-variable">$dark-theme</span>:   mat-dark-theme(<span class="hljs-variable">$dark-primary</span>, <span class="hljs-variable">$dark-accent</span>, <span class="hljs-variable">$dark-warn</span>);<span class="hljs-comment">// 所有在unicorn-dark-theme样式下的组件主题都将是深色的</span><span class="hljs-selector-class">.unicorn-dark-theme</span> &#123;  <span class="hljs-keyword">@include</span> angular-material-theme(<span class="hljs-variable">$dark-theme</span>);&#125;</code></pre><p><a name="be9cb3aa"></a></p><h2 id="基于浮层的组件"><a href="#基于浮层的组件" class="headerlink" title="基于浮层的组件"></a>基于浮层的组件</h2><p>由于某些组件（比如菜单、选择框、对话框等）位于全局的浮层容器中，所以想要让它们被主题的 css 类选择器（比如 <code>.unicorn-dark-theme</code>）影响到还需要做一个额外的步骤。</p><p>要做到这一点，你可以给全局浮层容器添加一个合适的类。比如上面的例子要改成这样：</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;OverlayContainer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/cdk/overlay'</span>;<span class="hljs-meta">@NgModule</span>(&#123;  <span class="hljs-comment">// ...</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> UnicornCandyAppModule &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">overlayContainer: OverlayContainer</span>) &#123;    overlayContainer.getContainerElement().classList.add(<span class="hljs-string">'unicorn-dark-theme'</span>);  &#125;&#125;</code></pre><p>当然，浮层容器也是渲染在 body 中的，所以可以在 body 中添加样式</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"unicorn-dark-theme"</span>&gt;</span>    <span class="hljs-comment">&lt;!--....--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>这样就不需要上面的 <code>ts</code> 类了。</p><p><a name="4b02068c"></a></p><h2 id="主题动态切换"><a href="#主题动态切换" class="headerlink" title="主题动态切换"></a>主题动态切换</h2><p>在上面多主题的基础上，我们实现主题的动态切换。可以通过修改 body 的 class，从而实现主题的切换。</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Inject</span>(DOCUMENT) <span class="hljs-keyword">private</span> <span class="hljs-built_in">document</span>: Document</span>) &#123;&#125;  changeTheme() &#123;    <span class="hljs-keyword">const</span> theme = <span class="hljs-string">'unicorn-dark-theme'</span>;    <span class="hljs-keyword">this</span>.document.body.classList.toggle(theme);  &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Angular开发必不可少的代理配置</title>
    <link href="/2019/08/02/angular-kai-fa-bi-bu-ke-shao-de-dai-li-pei-zhi/"/>
    <url>/2019/08/02/angular-kai-fa-bi-bu-ke-shao-de-dai-li-pei-zhi/</url>
    
    <content type="html"><![CDATA[<p>此处说的代理是 <code>ng serve</code> 提供的代理服务。</p><p>在开发环境中，Angular应用与后端服务联调测试时，Chrome浏览器会对发请求进行跨域检测。通过代理服务，来解决开发模式下的跨域问题。</p><p>接下来我们通过代理服务实现请求 <code>http://localhost:4200/api</code>  时代理到后端服务<code>http://localhost:8080/api</code> </p><p><a name="WehaY"></a></p><h2 id="基本代理"><a href="#基本代理" class="headerlink" title="基本代理"></a>基本代理</h2><p>首先我们需要在项目更目录下创建一个名为 <code>proxy.conf.json</code> 的代理配置文件，内容如下：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"/api"</span>: &#123;    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"http://localhost:8080"</span>,    <span class="hljs-attr">"secure"</span>: <span class="hljs-literal">false</span>  &#125;&#125;</code></pre><p>我们通过 <code>--proxy-config</code> 参数来加载代理配置文件：</p><pre><code class="hljs bash">ng serve --proxy-config=proxy.conf.json</code></pre><p>我们还可以在 <code>angular.json</code> 中通过 <code>proxyConfig</code> 属性来设置代理：</p><pre><code class="hljs json">"architect": &#123;  "serve": &#123;    "builder": "@angular-devkit/build-angular:dev-server",    "options": &#123;      "browserTarget": "your-application-name:build",      "proxyConfig": "proxy.conf.json"    &#125;,</code></pre><blockquote><p><code>angular.json</code> 是Angular CLI的配置文件</p></blockquote><p><a name="B8I6W"></a></p><h2 id="路径重写"><a href="#路径重写" class="headerlink" title="路径重写"></a>路径重写</h2><p>在基本代理中，我们配置了<code>http://localhost:4200/api</code> 代理后端服务 <code>http://localhost:8080/api</code>。而在实际开发中，我们的后端服务可能没有提供 <code>/api</code> 前缀，实际的后端服务可能是这样的：</p><pre><code class="hljs undefined"><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8080/users</span><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8080/orders</span></code></pre><p>在这种情况下，上面配置的基本代理就无法满足我们的需求了，因此后端不存在 <code>http://localhost:8080/api/users</code> 服务。幸运的是， <code>Angular CLI</code> 代理提供了路径重写功能。</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"/api"</span>: &#123;    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"http://localhost:8080"</span>,    <span class="hljs-attr">"secure"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"pathRewrite"</span>: &#123;      <span class="hljs-attr">"^/api"</span>: <span class="hljs-string">""</span>    &#125;  &#125;&#125;</code></pre><p>此时我们在浏览器访问 <code>http://localhost:4200/api/users</code> , 代理服务会给我们代理到后端服务 <code>http://localhost:8080/users</code> 上。</p><p>路径重写功能可以让我们很好的区分前端路由和后端服务。可以一目了然的知道<code>http://localhost:4200/api/users</code>访问的是一个后端服务。</p><p><a name="5vMiu"></a></p><h2 id="非本地域"><a href="#非本地域" class="headerlink" title="非本地域"></a>非本地域</h2><p>随着互联技术的发展，前后端分工越来越明确。前后端的交互就是REST接口。在这样的实际环境中，我们的前端工程师的本地不会运行后端服务，而是使用后端工程师提供的服务，此时，我们的后端服务的域就不会是 <code>localhost</code> , 而可能是 <code>http://test.domain.com/users</code> 。</p><p>此时我们就需要用的代理的另一个参数 <code>changeOrigin</code> 来满足我们的需求：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"/api"</span>: &#123;    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"http://test.domain.com"</span>,    <span class="hljs-attr">"secure"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"pathRewrite"</span>: &#123;      <span class="hljs-attr">"^/api"</span>: <span class="hljs-string">""</span>    &#125;,    <span class="hljs-attr">"changeOrigin"</span>: <span class="hljs-literal">true</span>  &#125;&#125;</code></pre><p>这样，我们访问 <code>http://localhost:4200/api/users</code> 就会被代理到<code>http://test.domain.com/users</code> 。</p><p><a name="P0aeg"></a></p><h2 id="代理日志"><a href="#代理日志" class="headerlink" title="代理日志"></a>代理日志</h2><p>在使用前端代理的过程中，如果想要调试代理是否正常工作，还可以添加 <code>logLevel</code> 选项：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"/api"</span>: &#123;    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"http://test.domain.com"</span>,    <span class="hljs-attr">"secure"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"pathRewrite"</span>: &#123;      <span class="hljs-attr">"^/api"</span>: <span class="hljs-string">""</span>    &#125;,    <span class="hljs-attr">"logLevel"</span>: <span class="hljs-string">"debug"</span>  &#125;&#125;</code></pre><p><code>logLevel</code> 支持的级别选项有 <code>debug</code> , <code>info</code> , <code>warn</code> , <code>silent</code> ，默认是 <code>info</code> 级别.</p><p><a name="n4saq"></a></p><h2 id="多代理入口"><a href="#多代理入口" class="headerlink" title="多代理入口"></a>多代理入口</h2><p>如果前端需要配置多个入口代理到同一个后端服务，不想使用前面的路径重写方式，我们可以创建一个 <code>proxy.conf.js</code> 文件来替代我们上面的 <code>proxy.conf.json</code> ：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> PROXY_CONFIG = [    &#123;        <span class="hljs-attr">context</span>: [            <span class="hljs-string">"/my"</span>,            <span class="hljs-string">"/many"</span>,            <span class="hljs-string">"/endpoints"</span>,            <span class="hljs-string">"/i"</span>,            <span class="hljs-string">"/need"</span>,            <span class="hljs-string">"/to"</span>,            <span class="hljs-string">"/proxy"</span>        ],        <span class="hljs-attr">target</span>: <span class="hljs-string">"http://localhost:3000"</span>,        <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span>    &#125;]<span class="hljs-built_in">module</span>.exports = PROXY_CONFIG;</code></pre><p>修改我们的 <code>angular.json</code> 中的 <code>proxyConfig</code> 为 <code>proxy.conf.js</code> ：</p><pre><code class="hljs json">"architect": &#123;  "serve": &#123;    "builder": "@angular-devkit/build-angular:dev-server",    "options": &#123;      "browserTarget": "your-application-name:build",      "proxyConfig": "proxy.conf.js"    &#125;,</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ed307173ecee?w=900&h=450&f=png&s=153639" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>当ThreadLocal碰上线程池</title>
    <link href="/2019/08/02/dang-threadlocal-peng-shang-xian-cheng-chi/"/>
    <url>/2019/08/02/dang-threadlocal-peng-shang-xian-cheng-chi/</url>
    
    <content type="html"><![CDATA[<p>ThreadLocal可以让线程拥有本地变量，在web环境中，为了方便代码解耦，我们通常用它来保存上下文信息，然后用一个util类提供访问入口，从controller层到service层可以很方便的获取上下文。下面我们通过代码来研究一下ThreadLocal。</p><p>新建一个ThreadContext类，用于保存线程上下文信息</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadContext</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;UserObj&gt; userResource = <span class="hljs-keyword">new</span> ThreadLocal&lt;UserObj&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserObj <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> userResource.get();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindUser</span><span class="hljs-params">(UserObj user)</span> </span>&#123;        userResource.set(user);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserObj <span class="hljs-title">unbindUser</span><span class="hljs-params">()</span> </span>&#123;        UserObj obj = userResource.get();        userResource.remove();        <span class="hljs-keyword">return</span> obj;    &#125;&#125;</code></pre><p>新建一个sessionFilter ，用来操作线程变量</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;    HttpServletRequest request = (HttpServletRequest) servletRequest;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 假设这里是从cookie拿token信息, 调用服务/或者从缓存查询用户信息</span>        <span class="hljs-comment">// 为了避免后续逻辑中多次查询/请求缓存服务器, 这里拿到user后放到线程本地变量中</span>        UserObj user = ThreadContext.getUser();        <span class="hljs-comment">// 如果当前线程中没有绑定user对象,那么绑定一个新的user</span>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;            ThreadContext.bindUser(<span class="hljs-keyword">new</span> UserObj(<span class="hljs-string">"usertest"</span>));        &#125;        filterChain.doFilter(servletRequest, servletResponse);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// ThreadLocal的生命周期不等于一次request请求的生命周期</span>        <span class="hljs-comment">// 每个request请求的响应是tomcat从线程池中分配的线程, 线程会被下个请求复用.</span>        <span class="hljs-comment">// 所以请求结束后必须删除线程本地变量</span>        <span class="hljs-comment">// ThreadContext.unbindUser();</span>    &#125;&#125;</code></pre><p>新建UserUtils工具类</p><pre><code class="hljs java"><span class="hljs-comment">/** * 配合SessionFilter使用,从上下文中取user信息 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserUtils</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserObj <span class="hljs-title">getCurrentUser</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ThreadContext.getUser();    &#125;&#125;</code></pre><p>新建一个servlet测试</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(HelloworldServlet<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        UserObj user = UserUtils.getCurrentUser();        logger.info(user.getName() + user.hashCode());        <span class="hljs-keyword">super</span>.doGet(req, resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">super</span>.doGet(req, resp);    &#125;&#125;</code></pre><p>循环请求servlet，控制台显示结果如下。可以发现tomcat线程池的初始大小是10个，后面的请求复用了前面的线程，ThreadContext中的user对象的hashcode也一样。</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">35.975</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest818202673<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">38.923</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1582591702<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">45.810</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">4</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest55755037<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">46.773</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">5</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1495466807<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">47.345</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">6</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1149360245<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">47.613</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">7</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest518375339<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">47.837</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">8</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest92458992<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">48.012</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">9</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest944867034<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">48.199</span>  INFO <span class="hljs-number">36672</span> --- [io-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">10</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1410972809<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">48.378</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest805332046<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">48.552</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest818202673<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">48.730</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1582591702<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">48.903</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">4</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest55755037<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">49.072</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">5</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1495466807<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">49.247</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">6</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1149360245<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">21</span>:<span class="hljs-number">49.402</span>  INFO <span class="hljs-number">36672</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">7</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest518375339</code></pre><p>去掉注释// ThreadContext.unbindUser(); 重新请求，每次从ThreadLocal中拿到的user对象完全不一样了。</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">37.150</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest413138571<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">42.932</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1402191945<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43.124</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1957579173<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43.313</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">4</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1582591702<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43.501</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">5</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1917479582<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43.679</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">6</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest772036767<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">43.851</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">7</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest162020761<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">44.024</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">8</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest682232950<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">44.225</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">9</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest2140650341<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">44.419</span>  INFO <span class="hljs-number">36903</span> --- [io-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">10</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1327601763<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">44.593</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest647738411<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">44.787</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest944867034<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">45.045</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1886154520<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">45.317</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">4</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1592904273<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">46.380</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">5</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1410972809<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">46.524</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">6</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1705570689<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">46.692</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">7</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1105134375<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">17</span>:<span class="hljs-number">30</span>:<span class="hljs-number">46.802</span>  INFO <span class="hljs-number">36903</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">8</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest407377722</code></pre><p><a name="PAmaK"></a></p><h2 id="ThreadLocal子线程场景"><a href="#ThreadLocal子线程场景" class="headerlink" title="ThreadLocal子线程场景"></a>ThreadLocal子线程场景</h2><p>需求新增， 需要在原有的业务逻辑中增加一个给用户发送邮件的操作。发送邮件我们采用异步处理，新建一个线程来执行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    UserObj user = UserUtils.getCurrentUser();    logger.info(user.getName() + user.hashCode());    SendEmailTask emailThread = <span class="hljs-keyword">new</span> SendEmailTask();    <span class="hljs-keyword">new</span> Thread(emailThread).start();    <span class="hljs-keyword">super</span>.doGet(req, resp);&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendEmailTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        UserObj user = UserUtils.getCurrentUser();        logger.info(<span class="hljs-string">"子线程中:"</span> + (user == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"user为null"</span> : user.getName() + user.hashCode()));    &#125;&#125;</code></pre><p>主线程中创建异步线程，子线程中能拿到吗？通过测试发现是不能的</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">18</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16.482</span>  INFO <span class="hljs-number">38092</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1425505918<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">18</span>:<span class="hljs-number">09</span>:<span class="hljs-number">16.483</span>  INFO <span class="hljs-number">38092</span> --- [       Thread-<span class="hljs-number">4</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:user为<span class="hljs-keyword">null</span><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">18</span>:<span class="hljs-number">09</span>:<span class="hljs-number">20.995</span>  INFO <span class="hljs-number">38092</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1280373552<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">18</span>:<span class="hljs-number">09</span>:<span class="hljs-number">20.996</span>  INFO <span class="hljs-number">38092</span> --- [       Thread-<span class="hljs-number">5</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:user为<span class="hljs-keyword">null</span></code></pre><p>子线程怎么拿到父线程的ThreadLocal数据？jdk给我们提供了解决办法，ThreadLocal有一个子类InheritableThreadLocal，创建ThreadLocal时候我们采用InheritableThreadLocal类可以实现子线程获取到父线程的本地变量。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;UserObj&gt; userResource = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;UserObj&gt;();</code></pre><p>然后子线程中就可以正常拿到user对象了</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">01.518</span>  INFO <span class="hljs-number">39644</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest495550128<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">01.518</span>  INFO <span class="hljs-number">39644</span> --- [       Thread-<span class="hljs-number">4</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest495550128<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">05.839</span>  INFO <span class="hljs-number">39644</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1851717404<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">05.840</span>  INFO <span class="hljs-number">39644</span> --- [       Thread-<span class="hljs-number">5</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest1851717404</code></pre><p><a name="I3PZJ"></a></p><h2 id="ThreadLocal-子线程传递－线程池场景"><a href="#ThreadLocal-子线程传递－线程池场景" class="headerlink" title="ThreadLocal 子线程传递－线程池场景"></a>ThreadLocal 子线程传递－线程池场景</h2><p>当我们执行异步任务时，大多会采用线程池的机制(如Executor)。这样就会存在一个问题，即使父线程已经结束，子线程依然存在并被池化。这样，线程池中的线程在下一次请求被执行的时候，ThreadLocal的get()方法返回的将不是当前线程中设定的变量，因为池中的“子线程”根本不是当前线程创建的，当前线程设定的ThreadLocal变量也就无法传递给线程池中的线程。<br>我们修改一下发送邮件的代码，改用线程池来实现。</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">51</span>:<span class="hljs-number">51.973</span>  INFO <span class="hljs-number">40937</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1417641261<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">51</span>:<span class="hljs-number">51.974</span>  INFO <span class="hljs-number">40937</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest1417641261<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">51</span>:<span class="hljs-number">55.746</span>  INFO <span class="hljs-number">40937</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1116537955<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">51</span>:<span class="hljs-number">55.746</span>  INFO <span class="hljs-number">40937</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest1417641261<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.825</span>  INFO <span class="hljs-number">40937</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1489938856<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">19</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.826</span>  INFO <span class="hljs-number">40937</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest1417641261</code></pre><p>可以发现发送邮件的任务三次用的都是同一个线程[pool-1-thread-1]，第一次子线程和父线程中的user对象相同，后面的“子线程”（前面提到过，后面的已经不是子线程了）中的user对象都是和第一个父线程中的相同。<br>那么在线程池的场景下，怎么能让“子线程”正常拿到父线程传递过来的变量呢？如果我们能在创建task的时候主动传递过去就好了。按照这个想法我们来实施一下。<br>继续修改代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    UserObj user = UserUtils.getCurrentUser();    logger.info(user.getName() + user.hashCode());    SendEmailTask emailThread = <span class="hljs-keyword">new</span> SendEmailTask();    executor.execute(<span class="hljs-keyword">new</span> UserRunnable(emailThread, user));    <span class="hljs-keyword">super</span>.doGet(req, resp);&#125;<span class="hljs-comment">/** * 做一个wrapper, 将目标任务做一层包装, 在run方法中传递线程本地变量 */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-comment">/**     * 目标任务对象     */</span>    Runnable runnable;    <span class="hljs-comment">/**     * 要绑定的user对象     */</span>    UserObj user;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserRunnable</span><span class="hljs-params">(Runnable runnable, UserObj user)</span> </span>&#123;        <span class="hljs-keyword">this</span>.runnable = runnable;        <span class="hljs-keyword">this</span>.user = user;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        ThreadContext.bindUser(user);        runnable.run();        ThreadContext.unbindUser();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendEmailTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        UserObj user = UserUtils.getCurrentUser();        logger.info(<span class="hljs-string">"子线程中:"</span> + (user == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"user为null"</span> : user.getName() + user.hashCode()));    &#125;&#125;</code></pre><p>重新请求，得到我们想要的结果</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">12.153</span>  INFO <span class="hljs-number">41258</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1565180744<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">12.154</span>  INFO <span class="hljs-number">41258</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest1565180744<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14.142</span>  INFO <span class="hljs-number">41258</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest481396704<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14.142</span>  INFO <span class="hljs-number">41258</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest481396704<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15.248</span>  INFO <span class="hljs-number">41258</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest400717395<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15.249</span>  INFO <span class="hljs-number">41258</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest400717395</code></pre><p>到此为止，ThreadLocal常见的场景和对应解决方案应该可以满足了。接下来就是怎么在实际应用中运用了。</p><p>为了引出此文的初衷以及后面要讲的东西，针对最后一个解决方案，我们可以进一步完善一下。</p><pre><code class="hljs java">ThreadContext.bindUser(user);runnable.run();ThreadContext.unbindUser();</code></pre><p>这个地方在bind的时候是直接覆盖，无法对线程之前的状态进行保存和恢复。要实现这一点，我们可以抽象一个ThreadState来保存线程的状态，在bind之前保存original，任务执行完以后进行restore。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThreadState</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserThreadState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadState</span> </span>&#123;    <span class="hljs-keyword">private</span> UserObj original;    <span class="hljs-keyword">private</span> UserObj user;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserThreadState</span><span class="hljs-params">(UserObj user)</span> </span>&#123;        <span class="hljs-keyword">this</span>.user = user;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.original = ThreadContext.getUser();        ThreadContext.bindUser(<span class="hljs-keyword">this</span>.user);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restore</span><span class="hljs-params">()</span> </span>&#123;        ThreadContext.bindUser(<span class="hljs-keyword">this</span>.original);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        ThreadContext.unbindUser();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;    UserObj user = UserUtils.getCurrentUser();    logger.info(user.getName() + user.hashCode());    SendEmailTask emailThread = <span class="hljs-keyword">new</span> SendEmailTask();    executor.execute(<span class="hljs-keyword">new</span> UserRunnable(emailThread, <span class="hljs-keyword">new</span> UserThreadState(user)));    <span class="hljs-keyword">super</span>.doGet(req, resp);&#125;<span class="hljs-comment">/** * 做一个wrapper, 将目标任务做一层包装, 在run方法中传递线程本地变量 */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-comment">/**     * 目标任务对象     */</span>    Runnable runnable;    <span class="hljs-comment">/**     * 要绑定的user对象     */</span>    UserThreadState userThreadState;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserRunnable</span><span class="hljs-params">(Runnable runnable, UserThreadState userThreadState)</span> </span>&#123;        <span class="hljs-keyword">this</span>.runnable = runnable;        <span class="hljs-keyword">this</span>.userThreadState = userThreadState;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        userThreadState.bind();        runnable.run();        userThreadState.restore();        UserObj userOrig = UserUtils.getCurrentUser();        logger.info(<span class="hljs-string">"original:"</span> + userOrig.getName() + userOrig.hashCode());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendEmailTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        UserObj user = UserUtils.getCurrentUser();        logger.info(<span class="hljs-string">"子线程中:"</span> + (user == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"user为null"</span> : user.getName() + user.hashCode()));    &#125;&#125;</code></pre><p>实现效果是相同的，至于为什么三次的original对象都是一样的，通过前面的说明应该能够理解</p><pre><code class="hljs java"><span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">48.694</span>  INFO <span class="hljs-number">41671</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest114760676<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">48.699</span>  INFO <span class="hljs-number">41671</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest114760676<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">48.700</span>  INFO <span class="hljs-number">41671</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : original:usertest114760676<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">57.123</span>  INFO <span class="hljs-number">41671</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest941302199<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">57.123</span>  INFO <span class="hljs-number">41671</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest941302199<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">57.123</span>  INFO <span class="hljs-number">41671</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : original:usertest114760676<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">20</span>:<span class="hljs-number">04.385</span>  INFO <span class="hljs-number">41671</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">3</span>] com.zallds.xy.servlet.HelloworldServlet  : usertest1489938856<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">20</span>:<span class="hljs-number">04.385</span>  INFO <span class="hljs-number">41671</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : 子线程中:usertest1489938856<span class="hljs-number">2016</span>-<span class="hljs-number">11</span>-<span class="hljs-number">29</span> <span class="hljs-number">20</span>:<span class="hljs-number">20</span>:<span class="hljs-number">04.385</span>  INFO <span class="hljs-number">41671</span> --- [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] com.zallds.xy.servlet.HelloworldServlet  : original:usertest114760676</code></pre><p>由于在使用shiro框架的SecurityUtils.getSubject()过程中碰到问题，才有了本文的示例，例子中的部分代码参考了shiro框架的实现机制。后面会再研究一下shiro的subject相关设计。</p><p><a href="http://shiro.apache.org/subject.html" target="_blank" rel="noopener">http://shiro.apache.org/subject.html</a></p><blockquote><p>作者： 99793933e682<br>原文地址： <a href="https://www.jianshu.com/p/85d96fe9358b" target="_blank" rel="noopener">https://www.jianshu.com/p/85d96fe9358b</a></p></blockquote><hr><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/269363/1564727847078-00283633-d15e-4603-833c-be0c4c7ad83b.jpeg#align=left&display=inline&height=450&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190719095938.jpg&originHeight=450&originWidth=900&size=36931&status=done&width=900" srcset="/img/loading.gif" alt="微信图片_20190719095938.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Prettier来规范你的Angular项目</title>
    <link href="/2019/06/27/shi-yong-prettier-lai-gui-fan-ni-de-angular-xiang-mu/"/>
    <url>/2019/06/27/shi-yong-prettier-lai-gui-fan-ni-de-angular-xiang-mu/</url>
    
    <content type="html"><![CDATA[<p>在实际项目中，我们经常会遇到团队人员写的代码风格不统一，尤其是前端代码。比如在JavaScript中，字符串可以是使用单引号<code>&#39;This is string&#39;</code>，也可以使用双引号<code>&quot;This is string&quot;</code>。对于JavaScript语言来说，这两种格式都是正确的，但是对于一个项目来讲，这就是没有规范的表现。</p><p>今天，我们就来分享一个叫prettier的前端工具，来实现我们前端项目的规范化。</p><h2 id="接下来，我们一步一步的在Angular项目中集成prettier"><a href="#接下来，我们一步一步的在Angular项目中集成prettier" class="headerlink" title="接下来，我们一步一步的在Angular项目中集成prettier"></a>接下来，我们一步一步的在Angular项目中集成prettier</h2><p>创建一个Angular项目</p><pre><code class="hljs sh">ng new prettierProject</code></pre><h2 id="1-安装prettier"><a href="#1-安装prettier" class="headerlink" title="1. 安装prettier"></a>1. 安装prettier</h2><pre><code class="hljs sh">npm install --save-dev --save-exact prettier</code></pre><h2 id="2-配置prettier"><a href="#2-配置prettier" class="headerlink" title="2. 配置prettier"></a>2. 配置prettier</h2><p>在项目的根目录下创建<code>.prettierrc</code>文件</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"singleQuote"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">"tabWidth"</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">"trailingComma"</span>: <span class="hljs-string">"none"</span>,  <span class="hljs-attr">"semi"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">"bracketSpacing"</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">"printWidth"</span>: <span class="hljs-number">140</span>,  <span class="hljs-attr">"overrides"</span>: [    &#123;      <span class="hljs-attr">"files"</span>: [        <span class="hljs-string">"*.json"</span>,        <span class="hljs-string">".eslintrc"</span>,        <span class="hljs-string">".tslintrc"</span>,        <span class="hljs-string">".prettierrc"</span>      ],      <span class="hljs-attr">"options"</span>: &#123;        <span class="hljs-attr">"parser"</span>: <span class="hljs-string">"json"</span>,        <span class="hljs-attr">"tabWidth"</span>: <span class="hljs-number">2</span>      &#125;    &#125;,    &#123;      <span class="hljs-attr">"files"</span>: [        <span class="hljs-string">"*.ts"</span>      ],      <span class="hljs-attr">"options"</span>: &#123;        <span class="hljs-attr">"parser"</span>: <span class="hljs-string">"typescript"</span>      &#125;    &#125;  ]&#125;</code></pre><h2 id="3-配置prettier-ignore"><a href="#3-配置prettier-ignore" class="headerlink" title="3. 配置prettier ignore"></a>3. 配置prettier ignore</h2><p>在项目的根目录下创建<code>.prettierignore</code>文件:</p><pre><code class="hljs text">package.jsonpackage-lock.jsondist.angulardoc.json.vscode/*</code></pre><p>这个文件会告诉prettier那些文件不需要它进行格式化。</p><h2 id="4-VS-Code集成prettier"><a href="#4-VS-Code集成prettier" class="headerlink" title="4. VS Code集成prettier"></a>4. VS Code集成prettier</h2><p>安装插件</p><p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier — Code formatter</a></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/269363/1561624825143-assets/web-upload/47f86bf5-f1e0-4335-8dc3-72442b366a74.png" srcset="/img/loading.gif" alt="Prettier — Code formatter"></p><p>在项目根目录创建<code>.vscode/settings.json</code>文件：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"editor.formatOnSave"</span>: <span class="hljs-literal">true</span>&#125;</code></pre><p>通过这个配置可以让我们在保存文件的时候，VS Code自动帮我们格式化，这样我们在写代码的时候，就可以不必为调格式浪费太多的时间。</p><h2 id="5-配置prettier和tslint共存"><a href="#5-配置prettier和tslint共存" class="headerlink" title="5. 配置prettier和tslint共存"></a>5. 配置prettier和tslint共存</h2><pre><code class="hljs sh">npm install --save-dev tslint-config-prettier</code></pre><p>在<code>tslint.json</code>文件中添加下面的配置：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"extends"</span>: [        <span class="hljs-string">"tslint:latest"</span>,        <span class="hljs-string">"tslint-config-prettier"</span>    ]&#125;</code></pre><h2 id="6-配置git-hook"><a href="#6-配置git-hook" class="headerlink" title="6. 配置git hook"></a>6. 配置git hook</h2><p>安装<code>husky</code>，创建一个Git hook</p><pre><code class="hljs sh">npm install  --save-dev pretty-quick husky</code></pre><p>在<code>package.json</code>中添加下面的配置:</p><pre><code class="hljs json">"husky": &#123;    "hooks": &#123;      "pre-commit": "pretty-quick --staged"    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebStorm VSCode集成cmder</title>
    <link href="/2019/06/26/webstorm-vscode-ji-cheng-cmder/"/>
    <url>/2019/06/26/webstorm-vscode-ji-cheng-cmder/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，更爽的是可以使用linux的命令,shell命令。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>去<a href="https://cmder.net/" target="_blank" rel="noopener">cmder官网</a>下载压缩包</li><li>解压下载的cmder</li><li>(可选)将您自己的可执行文件放入<code>bin</code>文件夹中，以便注入到系统的<code>Path</code>中</li><li>运行cmder.exe</li></ol><h2 id="VS-Code配置Cmder"><a href="#VS-Code配置Cmder" class="headerlink" title="VS Code配置Cmder"></a>VS Code配置Cmder</h2><p>使用<code>ctrl+,</code>快捷键打开设置页面，选择右上角的<code>{}</code>切换到<code>settings.json</code>文件，添加下面的配置即可</p><pre><code class="hljs json">&#123;    ...    "terminal.integrated.shell.windows": "C:\\windows\\System32\\cmd.exe",    "terminal.integrated.shellArgs.windows": [        "/k D:\\Tools\\cmder_mini\\vendor\\init.bat"    ],    ...&#125;</code></pre><h2 id="WebStorm配置Cmder"><a href="#WebStorm配置Cmder" class="headerlink" title="WebStorm配置Cmder"></a>WebStorm配置Cmder</h2><p><code>ctrl+alt+s</code>打开设置窗口，选择<code>Tools&gt;Terminal</code></p><p>设置</p><pre><code class="hljs text">&quot;cmd.exe&quot; /k &quot;&quot;%Cmder%\vendor\init.bat&quot;&quot;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2019/png/269363/1561552882498-assets/web-upload/380d4999-0a28-4c73-8d54-e7055d85fc41.png" srcset="/img/loading.gif" alt="Cmder"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用webpack-bundle-analyzer分析Angular应用</title>
    <link href="/2019/06/26/shi-yong-webpack-bundle-analyzer-fen-xi-angular-ying-yong/"/>
    <url>/2019/06/26/shi-yong-webpack-bundle-analyzer-fen-xi-angular-ying-yong/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>webpack-bundle-analyzer</code>是一个前端分析工具，可以生成可视化大小的webpack输出文件与互动缩放树形图，为开发人员对Application进行优化提供更为直观的指导依据。</p><h2 id="Angular集成webpack-bundle-analyzer"><a href="#Angular集成webpack-bundle-analyzer" class="headerlink" title="Angular集成webpack-bundle-analyzer"></a>Angular集成webpack-bundle-analyzer</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>webpack-bundle-analyzer</code>是一个开发者工具，实际发布的Application并不依赖于它，因此，我们需要将<code>webpack-bundle-analyzer</code>安装到<code>devDependencies</code>:</p><pre><code class="hljs bash">npm i -D webpack-bundle-analyzer</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改package.json文件，在scripts中，增加新的执行命令：</p><pre><code class="hljs json">"scripts": &#123;  "bundle-report": "ng build --configuration=production --stats-json &amp;&amp; webpack-bundle-analyzer dist/stats.json"&#125;,</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>此时就可以使用新添加的命令对Angular Application进行分析了：</p><pre><code class="hljs bash">npm run bundle-report</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2019/png/269363/1561538113639-assets/web-upload/c6b3fa2a-2b5f-44aa-b14b-27d5f1cbe0e8.png" srcset="/img/loading.gif" alt></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过使用<code>webpack-bundle-analyzer</code>，我们可以直观的看到那些模块体积比较大，这样我们就可以有针对性的对其进行优化。对应Web应用来说，文件越小是越好的，性能也会更优。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular打包优化之momentjs瘦身</title>
    <link href="/2019/06/26/angular-da-bao-you-hua-zhi-momentjs-shou-shen/"/>
    <url>/2019/06/26/angular-da-bao-you-hua-zhi-momentjs-shou-shen/</url>
    
    <content type="html"><![CDATA[<p>项目中使用到了moment.js，编译后发现moment的locale文件全部被打包到发布文件中，且moment的大部分都是locale文件，实际上我们只需要zh-cn这个语言包。</p><p>使用<code>webpack-bundle-analyzer</code>分析见图:</p><p><img src="https://i.loli.net/2020/07/29/QwCLiAhmzOusfak.png" srcset="/img/loading.gif" alt="321acf7d-a2f8-4649-ad76-dcf826773709.png"></p><p>moment.js 并不是一个现代化的模块化的库， 无法对其进行Tree Shaking优化。</p><p>我们需要借助第三方的builder组件: <code>@angular-builders/custom-webpack</code>，来扩展Angular的编译过程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>npm i -D @angular-builders/custom-webpack</p></blockquote><p>因为是开发中需要的包，我们要把<code>@angular-builders/custom-webpack</code>添加到<code>devDependencies</code>中。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改angular.json中builder，将其替换为我们新安装的<code>@angular-builders/custom-webpack</code>:</p><pre><code class="hljs json">..."architect": &#123;        "build": &#123;          "builder": "@angular-builders/custom-webpack:browser",          "options": &#123;            "customWebpackConfig": &#123;              "path": "./extra-webpack.config.js",              "replaceDuplicatePlugins": true,              "mergeStrategies": &#123;                "externals": "prepend"              &#125;            &#125;,            ....          &#125;        &#125;&#125;</code></pre><p>在上面的配置中，我们用到自定义的<code>extra-webpack.config.js</code>，因此我们需要手动创建该文件，内容为：</p><pre><code class="hljs javascript"><span class="hljs-meta">'use strict'</span>;<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>);<span class="hljs-comment">// https://webpack.js.org/plugins/context-replacement-plugin/</span><span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.ContextReplacementPlugin(<span class="hljs-regexp">/moment[/\\]locale$/</span>, /zh-cn/)]&#125;;</code></pre><p>至此，我们的moment.js的优化配置已完成。</p><p>再次执行<code>webpack-bundle-analyzer</code>分析：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/269363/1561537017238-assets/web-upload/ffc4b654-ab56-4185-8b4b-df925e8052d1.png" srcset="/img/loading.gif" alt="PIC"></p><p>我们会发现，新编辑的文件中locale文件只剩下了我们需要的zh-cn。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用Angular Reactive Form的实现领域模型one-to-many</title>
    <link href="/2019/06/14/ru-he-yong-angular-reactive-form-de-shi-xian-ling-yu-mo-xing-one-to-many/"/>
    <url>/2019/06/14/ru-he-yong-angular-reactive-form-de-shi-xian-ling-yu-mo-xing-one-to-many/</url>
    
    <content type="html"><![CDATA[<p>在应用系统中，必不可少的一样功能就是表单录入。在Angular中，提供了两种表单模式：<strong>响应式表单</strong>和<strong>模板驱动表单</strong>。</p><h2 id="Angular表单"><a href="#Angular表单" class="headerlink" title="Angular表单"></a>Angular表单</h2><h3 id="模板驱动表单"><a href="#模板驱动表单" class="headerlink" title="模板驱动表单"></a>模板驱动表单</h3><p>模板驱动表单是通过使用<code>ngModel</code>创建双向数据绑定，以读取和写入输入控件的值。如下：</p><p>首先ts文件里面创建模型：</p><pre><code class="hljs typescript">model = <span class="hljs-keyword">new</span> Hero(<span class="hljs-number">18</span>, <span class="hljs-string">'Dr IQ'</span>, <span class="hljs-keyword">this</span>.powers[<span class="hljs-number">0</span>], <span class="hljs-string">'Chuck Overstreet'</span>);</code></pre><p>然后再html文件中，通过ngModel指令，实现模型数据的双向绑定:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>       <span class="hljs-attr">required</span>       [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"model.name"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span>&gt;</span></code></pre><p>应为在<code>input</code>上通过<code>ngModel</code>实现了对<code>model.name</code>的双向绑定，此时，我们在界面的<code>input</code>中输入的内容会实时的反应到ts中的<code>model</code>中。</p><h3 id="响应式表单"><a href="#响应式表单" class="headerlink" title="响应式表单"></a>响应式表单</h3><p>响应式表单使用显式的、不可变的方式，管理表单在特定的时间点上的状态。对表单状态的每一次变更都会返回一个新的状态，这样可以在变化时维护模型的整体性。响应式表单是围绕 Observable 的流构建的，表单的输入和值都是通过这些输入值组成的流来提供的，它可以同步访问。</p><p>当使用响应式表单时，FormControl 类是最基本的构造块。要注册单个的表单控件，请在组件中导入 FormControl 类，并创建一个 FormControl 的新实例，把它保存在类的某个属性中。</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; FormControl &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;<span class="hljs-meta">@Component</span>(&#123;  selector: <span class="hljs-string">'app-name-editor'</span>,  templateUrl: <span class="hljs-string">'./name-editor.component.html'</span>,  styleUrls: [<span class="hljs-string">'./name-editor.component.css'</span>]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NameEditorComponent &#123;  name = <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>);&#125;</code></pre><p>在组件类中创建了控件之后，你还要把它和模板中的一个表单控件关联起来。修改模板，为表单控件添加 formControl 绑定，formControl 是由 ReactiveFormsModule 中的 FormControlDirective 提供的。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>  Name:  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> [<span class="hljs-attr">formControl</span>]=<span class="hljs-string">"name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></code></pre><h2 id="one-to-many的领域模型"><a href="#one-to-many的领域模型" class="headerlink" title="one-to-many的领域模型"></a>one-to-many的领域模型</h2><p>我们现在有个数据字典的数据模型，每个字典又包含了多个字典项。我们用TypeScript描述下我们的模型:</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Dict &#123;    id: <span class="hljs-built_in">number</span>;    code: <span class="hljs-built_in">string</span>;    name: <span class="hljs-built_in">string</span>;    items: Item[];&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Item &#123;    code: <span class="hljs-built_in">string</span>;    value: <span class="hljs-built_in">string</span>;&#125;</code></pre><p>在这个数据字典的模型中，<code>Dict</code>和<code>Item</code>的关系就是<code>one-to-many</code>。</p><h2 id="响应式表单实现字典模型"><a href="#响应式表单实现字典模型" class="headerlink" title="响应式表单实现字典模型"></a>响应式表单实现字典模型</h2><p>如果只是字典模型，没有字典项<code>Item</code>的话，在Angular的官方文档中已经给出了这样的模型实现方式：</p><pre><code class="hljs typescript"><span class="hljs-comment">// 使用FormBuilder来实现</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ReactiveFormDemoComponent <span class="hljs-keyword">implements</span> OnInit &#123;  formGroup: FormGroup = <span class="hljs-keyword">this</span>.fb.group(&#123;    id: [<span class="hljs-string">''</span>],    code: [<span class="hljs-string">''</span>],    name: [<span class="hljs-string">''</span>]  &#125;);  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> fb: FormBuilder</span>) &#123; &#125;  ngOnInit() &#123;  &#125;  doSubmit() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.formGroup.value);  &#125;&#125;</code></pre><p>在上面的代码中，我们通过<code>FormBuilder</code>来创建<code>FormGroup</code>，然后我们就可以在html中使用它：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"formGroup"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"doSubmit()"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>code<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"code"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span> Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>这种常规的模型实现起来还是比较简单的。</p><p>那么对于one-to-many的模型我们应该怎么去实现呢？</p><p>首先，我们来分析这个Dict模型。我们会发现items是一个Item[]，此时，我们可以在官方文档中找到，在响应式表单中有一个FormArray用来表示FormControl的数组模式。</p><p>接下来我们看Item，其实它本身也是一个简单模型，我们可以用FormGroup来与之对应。</p><p>现在我们对上面的代码进行改造：</p><pre><code class="hljs typescript"><span class="hljs-comment">// 使用FormBuilder来实现</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ReactiveFormDemoComponent <span class="hljs-keyword">implements</span> OnInit &#123;  formGroup: FormGroup = <span class="hljs-keyword">this</span>.fb.group(&#123;    id: [<span class="hljs-string">''</span>],    code: [<span class="hljs-string">''</span>],    name: [<span class="hljs-string">''</span>]，    items: <span class="hljs-keyword">this</span>.fb.array([])  <span class="hljs-comment">// 使用FormBuilder创建一个FormArray</span>  &#125;);  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> fb: FormBuilder</span>) &#123; &#125;  ngOnInit() &#123;  &#125;  doSubmit() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.formGroup.value);  &#125;  <span class="hljs-keyword">get</span> items() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formGroup.get(<span class="hljs-string">'items'</span>) <span class="hljs-keyword">as</span> FormArray;  &#125;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"formGroup"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"doSubmit()"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>code<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"code"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">formArrayName</span>=<span class="hljs-string">"items"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>CODE<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let form of list.controls"</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"form"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"code"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"value"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span> Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>复杂的东西都是由简单的组成的。就是Java中的基本数据类型一样。通过数据结构+算法，我们可以组装出复杂的对象，最后以应用的方式展示出来。所以，任何复杂的东西，只要我们认真分析，总能找到简单的实现方法。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript编码指南</title>
    <link href="/2019/06/05/0019-typescript-guidelines/"/>
    <url>/2019/06/05/0019-typescript-guidelines/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript编码指南"><a href="#TypeScript编码指南" class="headerlink" title="TypeScript编码指南"></a>TypeScript编码指南</h1><p><img src="https://cdn.pixabay.com/photo/2016/10/20/08/39/business-1754904_960_720.jpg" srcset="/img/loading.gif" alt></p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ol><li><p>使用 <code>PascalCase</code> 方式对类进行命名.</p></li><li><p>接口命名中不要使用前缀字母 <code>I</code> .</p></li><li><p>使用 <code>PascalCase</code> 方式对枚举值进行命名.</p></li><li><p>使用 <code>camelCase</code> 方式对函数进行命名.</p></li><li><p>使用 <code>camelCase</code> 方式对属性和本地变量进行命名.</p></li><li><p>私有属性命名不要使用前缀 <code>_</code> .</p></li><li><p>尽可能在命名中使用整个单词 .</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#components" target="_blank" rel="noopener"></a>组件</h2></li><li><p>每个逻辑组件一个文件 (例如： parser, scanner, emitter, checker).</p></li><li><p>不要添加新文件. :)</p></li><li><p>带有”.generated.*”后缀的文件是自动生成的，不要手动去修改.</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#types" target="_blank" rel="noopener"></a>类型</h2></li><li><p>除非您需要跨多个组件共享，否则不要导出类型/函数.</p></li><li><p>不要向全局命名空间引入新类型/值.</p></li><li><p>共享类型应在 <code>types.ts</code> 中定义.</p></li><li><p>在文件中，应首先输入类型定义.</p><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#null-and-undefined" target="_blank" rel="noopener"></a><code>null</code> 和 <code>undefined</code></h2></li><li><p>使用 <code>undefined</code> , 不要使用 <code>null</code> .</p></li></ol><h2 id="一般假设"><a href="#一般假设" class="headerlink" title="一般假设"></a>一般假设</h2><ol><li>将节点，符号等对象视为创建它们的组件之外的不可变对象。 不要改变它们。</li><li>创建后，默认情况下将数组视为不可变.</li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#classes" target="_blank" rel="noopener"></a>类</h2><ol><li>为保持一致性，请不要在核心编译器管道中使用类。 请改用函数闭包.</li></ol><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#flags" target="_blank" rel="noopener"></a>标志</h2><ol><li>应该将类型上超过2个相关的布尔属性转换为标志。</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#comments" target="_blank" rel="noopener"></a>注释</h2><ol><li>对函数，接口，枚举和类使用JSDoc样式注释。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#strings" target="_blank" rel="noopener"></a>字符串</h2><ol><li>使用双引号.</li><li>用户可见的所有字符串都需要进行本地化（在diagnosticMessages.json中创建一个条目）。</li></ol><h2 id="诊断信息"><a href="#诊断信息" class="headerlink" title="诊断信息"></a>诊断信息</h2><ol><li>在句子末尾使用句号.</li><li>对不确定的实体使用不定的文章.</li><li>应该命名确定的实体（这是为变量名，类型名等等。）.</li><li>在陈述规则时，主题应该是单数的 (e.g. “An external module cannot…” instead of “External modules cannot…”).</li><li>使用现在时.</li></ol><h2 id="诊断消息代码"><a href="#诊断消息代码" class="headerlink" title="诊断消息代码"></a>诊断消息代码</h2><p>诊断分为一般范围。 如果添加新的诊断消息，请使用大于相应范围中最后使用的数字的第一个整数。</p><ul><li>1000 句法消息的范围</li><li>2000 用于语义消息</li><li>4000 用于声明发出消息</li><li>5000 用于编译器选项消息</li><li>6000 用于命令行编译器消息</li><li>7000 对于noImplicitAny消息</li></ul><h2 id="一般构造"><a href="#一般构造" class="headerlink" title="一般构造"></a>一般构造</h2><p>出于各种原因，我们避免某些结构，并使用我们自己的一些结构。 其中：</p><ol><li>不要使用 <code>for..in</code> 语句; 相反，使用 <code>ts.forEach</code> ， <code>ts.forEachKey</code> 和 <code>ts.forEachValue</code> 。 请注意它们的语义略有不同。</li><li>当它不是非常不方便时，尝试使用 <code>ts.forEach</code> ， <code>ts.map</code> 和 <code>ts.filter</code> 而不是循环。</li></ol><h2 id="风格"><a href="#风格" class="headerlink" title="风格"></a><a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#style" target="_blank" rel="noopener"></a>风格</h2><ol><li>使用箭头函数而不是匿名函数。必要时仅限制环绕箭头功能参数。例如， <code>（x）=&gt; x + x</code> 错误，但以下是正确的:<ol><li><code>x =&gt; x + x</code></li><li><code>(x,y) =&gt; x + y</code></li><li><code>&lt;T&gt;(x: T, y: T) =&gt; x === y</code></li></ol></li><li>始终用花括号环绕循环和条件体。 允许在同一行上的语句省略大括号.</li><li>开放的花括号总是与任何必要条件都在同一条线上.</li><li>带括号的构造应该没有周围的空格。单个空格在这些构造中使用逗号，冒号和分号。 例如：<ol><li><code>for (var i = 0, n = str.length; i &lt; 10; i++) { }</code></li><li><code>if (x &lt; 10) { }</code></li><li><code>function f(x: number, y: string): void { }</code></li></ol></li><li>每个变量语句使用一个声明 <br>(i.e. 使用<code>var x = 1; var y = 2;</code> 而不是 <code>var x = 1, y = 2;</code>).</li><li><code>else</code> 与闭合的大括号分开.</li><li>每个缩进使用4个空格.</li></ol><blockquote><p>原文地址: <a href="https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际开发过程中，可能有些编码风格和文中的有不同，但只要风格统一就好。不要不同的风格混搭使用。<br>比如：</p><ol><li>字符串不要一会使用单引号，一会使用双引号</li><li>缩进有的文件使用2个空格，有的文件使用4个</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Docker 部署 Spring Boot</title>
    <link href="/2019/04/17/0018-shi-yong-docker-bu-shu-spring-boot/"/>
    <url>/2019/04/17/0018-shi-yong-docker-bu-shu-spring-boot/</url>
    
    <content type="html"><![CDATA[<p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot 其实非常简单，这篇文章我们就来简单学习下。</p><p>首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。</p><h2 id="一个简单-Spring-Boot-项目"><a href="#一个简单-Spring-Boot-项目" class="headerlink" title="一个简单 Spring Boot 项目"></a>一个简单 Spring Boot 项目</h2><p>在 <code>pom.xml</code> 中 ，使用 Spring Boot 2.0 相关依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre><p>添加 web 和测试依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><pre><code class="hljs undefined"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DockerController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">"/"</span>)</span>    <span class="hljs-keyword">public</span> String index() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Docker!"</span>;    &#125;&#125;</code></pre><p>启动类</p><pre><code class="hljs undefined"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DockerApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(DockerApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>添加完毕后启动项目，启动成功后浏览器放问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="Spring-Boot-项目添加-Docker-支持"><a href="#Spring-Boot-项目添加-Docker-支持" class="headerlink" title="Spring Boot 项目添加 Docker 支持"></a>Spring Boot 项目添加 Docker 支持</h2><p>在 <code>pom.xml-properties</code>中添加 Docker 镜像名称</p><pre><code class="hljs undefined">&lt;<span class="hljs-built_in">properties</span>&gt;    &lt;docker.<span class="hljs-built_in">image</span>.<span class="hljs-built_in">prefix</span>&gt;springboot&lt;/docker.<span class="hljs-built_in">image</span>.<span class="hljs-built_in">prefix</span>&gt;&lt;/<span class="hljs-built_in">properties</span>&gt;</code></pre><p>plugins 中添加 Docker 构建插件：</p><pre><code class="hljs undefined"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Docker maven plugin --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;docker.image.prefix&#125;</span><span class="xml">/$</span><span class="hljs-template-variable">&#123;project.artifactId&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>src/main/docker<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.build.directory&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;project.build.finalName&#125;</span><span class="xml">.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Docker maven plugin --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span></code></pre><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><pre><code class="hljs undefined"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-alpine<span class="hljs-keyword">VOLUME</span><span class="bash"> /tmp</span><span class="hljs-keyword">ADD</span><span class="bash"> spring-boot-docker-1.0.jar app.jar</span><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]</span></code></pre><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的 Tomcat 容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote><h2 id="构建打包环境"><a href="#构建打包环境" class="headerlink" title="构建打包环境"></a>构建打包环境</h2><p>我们需要有一个 Docker 环境来打包 Spring Boot 项目，在 Windows 搭建 Docker 环境很麻烦，因此我这里以 Centos 7 为例。</p><h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><p>安装</p><pre><code class="hljs undefined">yum <span class="hljs-keyword">install</span> docker</code></pre><p>安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动：</p><pre><code class="hljs undefined">ervice docker <span class="hljs-built_in">start</span>chkconfig docker <span class="hljs-keyword">on</span><span class="hljs-comment">#LCTT 译注：此处采用了旧式的 sysv 语法，如采用CentOS 7中支持的新式 systemd 语法，如下：</span>systemctl  <span class="hljs-built_in">start</span> docker.servicesystemctl  enable docker.service</code></pre><p>使用 Docker 中国加速器</p><pre><code class="hljs undefined">vi  <span class="hljs-string">/etc/docker/daemon.json</span><span class="hljs-comment">#添加后：</span>&#123;    <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://registry.docker-cn.com"</span>],    <span class="hljs-string">"live-restore"</span>: <span class="hljs-literal">true</span>&#125;</code></pre><p>重新启动 docker</p><pre><code class="hljs undefined"><span class="hljs-attribute">systemctl restart docker</span></code></pre><p>输入<code>docker version</code> 返回版本信息则安装正常。</p><h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><pre><code class="hljs undefined"><span class="hljs-selector-tag">yum</span> <span class="hljs-selector-tag">-y</span> <span class="hljs-selector-tag">install</span> <span class="hljs-selector-tag">java-1</span><span class="hljs-selector-class">.8</span><span class="hljs-selector-class">.0-openjdk</span>*</code></pre><p>配置环境变量<br>打开 <code>vim /etc/profile</code><br>添加一下内容</p><pre><code class="hljs undefined">export JAVA_HOME=/usr/lib/jvm/java-<span class="hljs-number">1.8</span><span class="hljs-number">.0</span>-openjdk-<span class="hljs-number">1.8</span><span class="hljs-number">.0</span><span class="hljs-number">.161</span>-<span class="hljs-number">0.b14</span>.el7_4.x86_64export PATH=$PATH:$JAVA_HOME/bin</code></pre><p>修改完成之后，使其生效</p><pre><code class="hljs undefined"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile</code></pre><p>输入<code>java -version</code> 返回版本信息则安装正常。</p><h3 id="安装-MAVEN"><a href="#安装-MAVEN" class="headerlink" title="安装 MAVEN"></a>安装 MAVEN</h3><p>下载：<code>http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz</code></p><pre><code class="hljs undefined">## 解压tar vxf apache-maven<span class="hljs-number">-3.5</span><span class="hljs-number">.2</span>-bin.tar.gz## 移动mv apache-maven<span class="hljs-number">-3.5</span><span class="hljs-number">.2</span> /usr/local/maven3</code></pre><p>修改环境变量， 在<code>/etc/profile</code>中添加以下几行</p><pre><code class="hljs undefined"><span class="hljs-attribute">MAVEN_HOME</span>=/usr/local/maven3<span class="hljs-builtin-name">export</span> MAVEN_HOME<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;PATH&#125;</span>:$&#123;MAVEN_HOME&#125;/bin</code></pre><p>记得执行<code>source /etc/profile</code>使环境变量生效。</p><p>输入<code>mvn -version</code> 返回版本信息则安装正常。</p><blockquote><p>这样整个构建环境就配置完成了。</p></blockquote><h2 id="使用-Docker-部署-Spring-Boot-项目"><a href="#使用-Docker-部署-Spring-Boot-项目" class="headerlink" title="使用 Docker 部署 Spring Boot 项目"></a>使用 Docker 部署 Spring Boot 项目</h2><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><pre><code class="hljs undefined"><span class="hljs-meta">#打包</span>mvn package<span class="hljs-meta">#启动</span>java -jar target/spring-boot-docker<span class="hljs-number">-1.0</span>.jar</code></pre><p>看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><pre><code class="hljs undefined">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">docker:build</span></code></pre><p>第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</p><pre><code class="hljs undefined"><span class="hljs-built_in">..</span>.<span class="hljs-keyword">Step</span> 1 : <span class="hljs-keyword">FROM</span> openjdk:8-jdk-alpine ---&gt; 224765a6bdbe<span class="hljs-keyword">Step</span> 2 : VOLUME /tmp ---&gt; Using cache ---&gt; b4e86cc8654e<span class="hljs-keyword">Step</span> 3 : <span class="hljs-builtin-name">ADD</span> spring-boot-docker-1.0.jar app.jar ---&gt; a20fe75963abRemoving intermediate container 593ee5e1ea51<span class="hljs-keyword">Step</span> 4 : ENTRYPOINT java -Djava.security.<span class="hljs-attribute">egd</span>=file:/dev/./urandom -jar /app.jar ---&gt; Running <span class="hljs-keyword">in</span> 85d558a10cd4 ---&gt; 7102f08b5e95Removing intermediate container 85d558a10cd4Successfully built 7102f08b5e95[<span class="hljs-builtin-name">INFO</span>] Built springboot/spring-boot-docker[<span class="hljs-builtin-name">INFO</span>] ------------------------------------------------------------------------[<span class="hljs-builtin-name">INFO</span>] BUILD SUCCESS[<span class="hljs-builtin-name">INFO</span>] ------------------------------------------------------------------------[<span class="hljs-builtin-name">INFO</span>] Total time: 54.346 s[<span class="hljs-builtin-name">INFO</span>] Finished at: 2018-03-13T16:20:15+08:00[<span class="hljs-builtin-name">INFO</span>] Final Memory: 42M/182M[<span class="hljs-builtin-name">INFO</span>] ------------------------------------------------------------------------</code></pre><p>使用<code>docker images</code>命令查看构建好的镜像：</p><pre><code class="hljs undefined">docker imagesREPOSITORY                      <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZEspringboot/spring-boot-docker   latest              <span class="hljs-number">99</span>ce9468da74        <span class="hljs-number">6</span> seconds ago       <span class="hljs-number">117.5</span> MB</code></pre><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><pre><code class="hljs undefined">docker <span class="hljs-keyword">run</span><span class="bash"> -p 8080:8080 -t springboot/spring-boot-docker</span></code></pre><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><pre><code class="hljs undefined"><span class="hljs-string">docker</span> <span class="hljs-string">ps</span><span class="hljs-string">CONTAINER</span> <span class="hljs-string">ID</span>        <span class="hljs-string">IMAGE</span>                           <span class="hljs-string">COMMAND</span>                  <span class="hljs-string">CREATED</span>             <span class="hljs-string">STATUS</span>              <span class="hljs-string">PORTS</span>                    <span class="hljs-string">NAMES</span><span class="hljs-string">049570da86a9</span>        <span class="hljs-string">springboot/spring-boot-docker</span>   <span class="hljs-string">"java -Djava.security"</span>   <span class="hljs-number">30</span> <span class="hljs-string">seconds</span> <span class="hljs-string">ago</span>      <span class="hljs-string">Up</span> <span class="hljs-number">27</span> <span class="hljs-string">seconds</span>       <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:8080-&gt;8080/tcp</span>   <span class="hljs-string">determined_mahavira</span></code></pre><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>, 返回</p><pre><code class="hljs undefined">Hello Docker!</code></pre><p>说明使用 Docker 部署 Spring Boot 项目成功！</p><p><strong><a href="https://github.com/ityouknow/spring-boot-examples" target="_blank" rel="noopener">示例代码 - github</a></strong></p><p><strong><a href="https://gitee.com/ityouknow/spring-boot-examples" target="_blank" rel="noopener">示例代码 - 码云</a></strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">Spring Boot with Docker</a><br><a href="https://lw900925.github.io/docker/docker-springboot.html" target="_blank" rel="noopener">Docker：Spring Boot 应用发布到 Docker</a></p><blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码</p><p>原文地址 <a href="https://www.cnblogs.com/ityouknow/p/8599093.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/8599093.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员如何精确评估开发时间？</title>
    <link href="/2019/04/16/0017-accurate-assessment-of-working-hours/"/>
    <url>/2019/04/16/0017-accurate-assessment-of-working-hours/</url>
    
    <content type="html"><![CDATA[<p>一个程序员能否精确评估开发时间，是一件非常重要的事情。如果你掌握了这项技能，你在别人的眼里就会是这样：</p><ul><li>靠谱</li><li>经验十足</li><li>对需求很了解</li><li>延期风险小</li><li>合格的软件工程师</li><li>正规军，不是野路子</li></ul><h3 id="评估开发时间的重要性"><a href="#评估开发时间的重要性" class="headerlink" title="评估开发时间的重要性"></a>评估开发时间的重要性</h3><p>首先，在一个项目中，所有的环节都是承上启下的，上一个环节结束的时间节点正是下一个环节开始的节点。那么在一个项目或者一次迭代正式启动前，所有的环节都应该有个时间评估。以一次APP需求迭代为例，项目计划像这样：</p><ul><li>UI设计图 11.01 - 11.03（3工作日）</li><li>API接口讨论与设计 11.04（1工作日）</li><li>移动端开发 11.05 - 11.15（8工作日）</li><li>后端具备联调条件：11.11</li><li>产品体验 11.16 - 11.17（2工作日）</li><li>测试11.18 - 11.25（5工作日）</li><li>发布11.26</li></ul><p>根据项目计划，各个部门自己要分配人员和时间。如果其中一个环节延期了，那么后面的各个环节都要顺延，就会造成损失。</p><p>其次，对于程序员来说，一个清晰的开发计划有助于自己有条不紊地开展工作，也能避免疏漏某个功能点。评估时间的过程，也是对需求详细拆分的过程，了解要做什么，做成什么样子。在评估的过程中，根据专业知识和经验，充分预估会遇到的风险，怎样的解决方案，预留多少时间？都想好了的话，项目也就没啥风险了。</p><p>然而，开发时间评估，最大的好处是程序员受益。认真地评估开发时间，会让你在开始动手写代码之前搞清楚要怎么写，每个模块的设计心理得有个谱。从宏观上拆分模块，然后详细地分解任务，具体到一个很小的功能点。这样你就能清晰地设计代码，而不是堆代码。也避免了很多时候写着写着发现不对，然后拉到重来的境地。就是要让你动手写代码之前胸有成竹！</p><h3 id="初学者为什么评估不准？"><a href="#初学者为什么评估不准？" class="headerlink" title="初学者为什么评估不准？"></a>初学者为什么评估不准？</h3><p>如果你的项目经常delay，那么八成是时间评估不准。</p><p>刚毕业的学生被问到什么时候可以完成的时候，脑门一拍：“三天”，实际上两个星期过去了还没完成。</p><p>这里有一张表，看看你是不是这样子，对号入座：</p><p><img src="https://wx1.sinaimg.cn/mw690/806e3151ly1g24quvbhswj20ia0ipk5w.jpg" srcset="/img/loading.gif" alt></p><p>越是老程序员越是“胆小”，评估时间越准。</p><h3 id="如何精确评估开发时间"><a href="#如何精确评估开发时间" class="headerlink" title="如何精确评估开发时间"></a>如何精确评估开发时间</h3><p>最近几年，我都是以小时为单位进行时间评估的，有没有觉得有点恐怖？长期以来这样的习惯让我收获颇多。这得感谢我之前的领导，三年前强迫我们这样做，刚开始很抵触，后来才体会到其中的甜头。</p><p><strong>1、任务拆分</strong></p><p>拿到新需求后，对其进行充分了解，不清楚的就去问清楚，然后对其进行模块化。之后，再进行技术上的拆分。由大到小，再到细节。细到什么程度呢？细到一个按钮的实现，细到一个点击动作是要用按钮还是要用手势的定夺，最好能细到代码块的划分。</p><p>这个能力是需要锻炼的，做好拆分，然后在实际开发过程中根据实际时间花销，回顾时间评估的准确性，以便让下次更准确。慢慢地，就会越来越精确，评估时间有依有据，不再是拍脑门给出的时间。下面看一个例子：</p><p><img src="https://wx2.sinaimg.cn/mw690/806e3151ly1g24quz2fa6j20je040gnc.jpg" srcset="/img/loading.gif" alt></p><p><strong>2、合理认知时间</strong></p><p>一天工作八小时，但你不可能专注地连续八小时在编写代码。一天的工作中，有开会、讨论、阶段性休息（刷新闻、喝咖啡、发呆）的时间开销，真正有效时间其实不足六小时，杂事多的话可能是四五个小时。</p><p><strong>3、预留buffer(缓冲区)</strong></p><p>首先明确，预留buffer不是让你随便增加预估量，而是要明确知道buffer是给那些事情用的。要考虑到一下几点：</p><p>首先是沟通时间，你开发的时候不可能是闷着头一直写代码。要和UI设计师沟通，要和产品经理沟通，有可能还需要和组内的人沟通技术上的事情，以及和别的技术小组对接的问题。</p><p>等待时间。如果牵扯多部门协作，会有很多等待时间，因为你不能保证别的部门就能准确按照计划时间完成的。虽然等待过程中你可以安排其他任务，但你不能保证其他任务就能刚好填充等待时间，更何况任务切换也需要时间成本。</p><p>突发状况。例如，bug修改、需求微调、对接人请假。</p><p>不确定时间。和其他部门有交集的工作，最好多预留buffer。比如移动端和后台联调。后端信誓旦旦给你说11.11号可以进行联调，这次联调总共5个接口。如果你简单地认为他们给你提供的接口没问题，并且能顺利请求回来数据，预计一天联调时间足以，那你就等着delay吧。11.10号你已经准备好了所有联调准备，如果数据能正确返回，你的解析功能都是OK的，因为你之前用假数据已经处理的好好的。到了11号，你请求第一个接口就报错了，然后在即时通讯软件上问他们怎么回事，半个小时后给你回了“不好意思，地址变了，你用这个试试”。又错了……。终于回来数据了，然后发现缺少两个字段……。就这样，第一个接口调通已经快下班了。（当然很多后端技术人员也是很靠谱的，举这个例子只是为了让多考虑）</p><p>以上是可能会出现的状况，实际中有可能只是出现了一部分，这要根据实际情况而定。并不是让你能多预留buffer就多留，毕竟每个项目的时间都是很紧张的。一般buffer留在15%-25%。</p><p><strong>4、回头看</strong></p><p>在实际开发过程中，测量实际花费时间，并与估算相比较。如果有些地方相差较大，就要看差在哪里，然后在下次预估中避免相同的差错。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>编程经验不等同于估算经验。一个不被包含在估算流程中的开发者将不会擅长估算。同样，如果实际的时间花费不被测量和用于与估算比较，那么将没有反馈来学习。</p><p>最后，每个程序员都应该具备估算的技能。为磨练这个技能，接手每个任务时，先决定你要做什么。然后在开始之前估算任务所需时间。最后测量实际花费时间，并与估算相比较。同样比较你实际完成的与计划完成的。这样你将会既提高你对一个任务包含细节的理解，同样也提高了你的估算技能。</p><p>尽管进行了精确估算，也不能保证每个项目都会100%精确。偶尔会遇到一些突发情况和没预估到的风险是不可避免的。那么面对风险，有一些原则可以帮助你：</p><ul><li>报风险时间置前，如果开发开始或者任何过程有可能导致项目延期或者需求无法实现的时候就报警，不要等加班能实现或者存在侥幸心理；</li><li>对于不确定的需求，一定要沟通到位；</li><li>涉及到交互细节，必须提前沟通好，充分明确细节；</li><li>技术可行性方案提前调查清楚。</li></ul><p>完结<del>~</del>~~</p><blockquote><p>来源：Eric_LG</p><p>blog.csdn.net/gang544043963/article/details/83934015</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Angular项目中集成Font Awesome图标</title>
    <link href="/2019/04/15/0015-angular-font-awesome/"/>
    <url>/2019/04/15/0015-angular-font-awesome/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2019/png/269363/1555038251526-53b022c7-d2ea-4e41-adcd-dd4a4454c98b.png#align=left&display=inline&height=420&name=%E7%B4%A0%E6%9D%90%E5%88%B6%E4%BD%9C.png&originHeight=720&originWidth=1280&size=588090&status=done&width=746" srcset="/img/loading.gif" alt="素材制作.png"><br><br>通过三部操作就可以在Angular项目中使用Font Awesome图标：</p><ol><li>安装</li><li>样式配置</li><li>使用</li></ol><p><a name="e655a410"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过 <code>NPM</code> 安装，并保存到 <code>package.json</code> </p><pre><code class="hljs undefined">npm install --<span class="hljs-built_in">save</span> <span class="hljs-built_in">font</span>-awesome</code></pre><p><a name="9ae6f0a6"></a></p><h1 id="配置样式-css"><a href="#配置样式-css" class="headerlink" title="配置样式 css"></a>配置样式 css</h1><p>在 <code>style.css</code> </p><pre><code class="hljs css"><span class="hljs-keyword">@import</span> <span class="hljs-string">'~font-awesome/css/font-awesome.css'</span>;</code></pre><p><a name="ca2b37d4"></a></p><h1 id="配置样式-scss"><a href="#配置样式-scss" class="headerlink" title="配置样式 scss"></a>配置样式 scss</h1><p>在 <code>style.scss</code> </p><pre><code class="hljs css">$fa-font-path: "../node_modules/font-awesome/fonts";@import '~font-awesome/scss/font-awesome.scss';</code></pre><p><a name="1e1072c7"></a></p><h1 id="在Angular使用"><a href="#在Angular使用" class="headerlink" title="在Angular使用"></a>在Angular使用</h1><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-area-chart"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></code></pre><p><a name="c7feb89a"></a></p><h1 id="配合Angular-Material"><a href="#配合Angular-Material" class="headerlink" title="配合Angular Material"></a>配合Angular Material</h1><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">matIconRegistry: MatIconRegistry</span>) &#123;    matIconRegistry.registerFontClassAlias(<span class="hljs-string">'fontawesome'</span>, <span class="hljs-string">'fa'</span>);  &#125;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span> <span class="hljs-attr">fontSet</span>=<span class="hljs-string">"fontawesome"</span> <span class="hljs-attr">fontIcon</span>=<span class="hljs-string">"fa-area-chart"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2019/02/21/0016-mian-xiang-dui-xiang/"/>
    <url>/2019/02/21/0016-mian-xiang-dui-xiang/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。</p><p>面向过程(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。</p><h3 id="面向对象的三大基本特征"><a href="#面向对象的三大基本特征" class="headerlink" title="面向对象的三大基本特征"></a>面向对象的三大基本特征</h3><p>面向对象的三个基本特征是：封装、继承、多态。</p><p><img src="http://www.cnitblog.com/images/cnitblog_com/lily/1972/o_OOBase.gif" srcset="/img/loading.gif" alt></p><p>面向对象的三大基本特征和五大基本原则</p><p><strong>封装</strong></p><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。</p><p>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><p><strong>继承</strong></p><p>面向对象编程(OOP)语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>。被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p><p>继承的过程，就是从一般到特殊的过程。</p><p>要实现继承，可以通过<code>继承（Inheritance）</code>和<code>组合（Composition）</code>来实现。<br>在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p><p>继承概念的实现方式有三类：实现继承、接口继承和可视继承。</p><ul><li>实现继承是指使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</li><li>可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。</li></ul><p>在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是<strong>属于</strong>关系。例如，<code>Employee</code>是一个人，<code>Manager</code>也是一个人，因此这两个类都可以继承<code>Person</code>类。但是<code>Leg</code> 类却不能继承<code>Person</code>类，因为腿并不是一个人。</p><p>抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 <code>interface</code> 而不是<code>class</code>。</p><p>OO开发范式大致为：划分对象-&gt;抽象类-&gt;将类组织成为层次化结构(继承和合成) -&gt;用类与实例进行设计和实现几个阶段。</p><p><strong>多态</strong></p><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p><p>实现多态，有二种方式: <strong>覆盖</strong>、<strong>重载</strong>。</p><ul><li><strong>覆盖</strong>，是指子类重新定义父类的虚函数的做法。</li><li><strong>重载</strong>，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</li></ul><p>其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：<code>function func(p:integer):integer;</code>和<code>function func(p:string):integer;</code>。那么编译器做过修饰后的函数名称可能是这样的：<code>int_func</code>、<code>str_func</code>。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”</p><p>那么，多态的作用是什么呢？</p><p>我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p><h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><p>Java是平台无关的语言是指用Java写的应用程序不用修改就可在不同的软硬件平台上运行。平台无关有两种：源代码级和目标代码级。C和C++具有一定程度的源代码级平台无关，表明用C或C++写的应用程序不用修改只需重新编译就可以在不同平台上运行。</p><p>Java主要靠Java虚拟机（JVM）在目标码级实现平台无关性。JVM是一种抽象机器，它附着在具体操作系统之上，本身具有一套虚机器指令，并有自己的栈、寄存器组等。但JVM通常是在软件上而不是在硬件上实现。（目前，SUN系统公司已经设计实现了Java芯片，主要使用在网络计算机NC上。另外，Java芯片的出现也会使Java更容易嵌入到家用电器中。）JVM是Java平台无关的基础，在JVM上，有一个Java解释器用来解释Java编译器编译后的程序。Java编程人员在编写完软件后，通过Java编译器将Java源程序编译为JVM的字节代码。任何一台机器只要配备了Java解释器，就可以运行这个程序，而不管这种字节码是在何种平台上生成的（过程如图1所示）。另外，Java采用的是基于IEEE标准的数据类型。通过JVM保证数据类型的一致性，也确保了Java的平台无关性。</p><p>Java的平台无关性具有深远意义。首先，它使得编程人员所梦寐以求的事情（开发一次软件在任意平台上运行）变成事实，这将大大加快和促进软件产品的开发。其次Java的平台无关性正好迎合了 “网络计算机 “思想。如果大量常用的应用软件（如字处理软件等）都用Java重新编写，并且放在某个Internet服务器上，那么具有NC的用户将不需要占用大量空间安装软件，他们只需要一个Java解释器，每当需要使用某种应用软件时，下载该软件的字节代码即可，运行结果也可以发回服务器。目前，已有数家公司开始使用这种新型的计算模式构筑自己的企业信息系统。</p><h4 id="JVM-还支持哪些语言"><a href="#JVM-还支持哪些语言" class="headerlink" title="JVM 还支持哪些语言"></a>JVM 还支持哪些语言</h4><p><strong>Kotlin</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-1-660x344.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="https://kotlinlang.org/" target="_blank" rel="noopener">https://kotlinlang.org/</a></p><p>由JetBrains于2010年创建，并于2012年开源， Kotlin比Java更加简洁和安全。 您完全可以将Kotlin视为是一种“更加简单但高效的Java”。Kotlin的编译速度通常比Java代码快，而且在其创建之初，就非常明确的支持了函数式编程，这一点，Java是到Java 8才开始支持的。</p><p>特别的，因为有了Google的加持，越来越多的Android开发人员，开始选择Kotlin来开发应用程序，与此同时，独立的超越JVM的行动也已经在展开，通过一项名为LLVM的项目，Kotlin正在努力实现代码编译的本地化，而不在基于JVM 。</p><p>但无论如何，至少现在，它还活在JVM中。</p><p><strong>Scala</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-2-660x274.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="http://www.scala-lang.org/" target="_blank" rel="noopener">http://www.scala-lang.org/</a></p><p>和Kotlin一样， Scala也是为了让Java开发人员提高工作效率而创建的。 作为一种完全的面向对象语言和一种完全的函数式编程语言，Scala巧妙的将这两种编程范式结合到了一起。</p><p>特别是在函数式编程方面，Scala几乎支持函数式编程语言中所有已知的特性，比如，模式匹配（Pattern matching）、延迟初始化（Lazy initialization）、偏函数（Partial Function）、不变性（Immutability）等等等等，</p><p>因此，虽然Scala的类Lisp的语法会让初学者倍感迷惑，但花时间在这上面，永远是值得的，很快，就会让你体会到那种只需要关注 What（做什么），而不用关注How（如何做）的酸爽。</p><p>一个最新的关于Scala的消息是，它似乎也在和Kotlin一样，在加速准备逃离JVM的控制，这对于JVM，恐怕不是一个什么特别好的消息，虽然，其距离用于生产可能还为时尚早。</p><p><strong>Clojure</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-3.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="https://clojure.org/" target="_blank" rel="noopener">https://clojure.org/</a></p><p>Clojure是由开发人员Rich Hickey在JVM下，所创建的一种Lisp方言，借助于JVM的执行效率越来越高，Clojure也常被嵌入在Java中，用于编写其中需要高并发、高性能的部分 。</p><p><strong>Groovy</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-4-660x291.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="http://www.groovy-lang.org/" target="_blank" rel="noopener">http://www.groovy-lang.org/</a></p><p>Groovy是在Java现有基础上，吸收Python和Ruby等动态语言的特性，而创建的一种新型语言，也是Jenkins持续集成服务器，所直接支持的语言之一，并且最关键的一点，通过基于Groovy的Web开发框架Grails，可以快速的完成相关Web项目的构建 。</p><p>在未来，Groovy则拟包含Java和JVM的一些更新的特性，比如如Java 8的lambda语法等。</p><p><strong>Jython</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-5.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="http://www.jython.org/" target="_blank" rel="noopener">http://www.jython.org/</a></p><p>Jython是JVM的Python实现，与Python的2.x分支兼容，可以动态编译为Java字节码，并且可以与其他JVM语言（特别是Java）自由交互操作。</p><p> <strong>JRuby</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-6-660x206.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="http://jruby.org" target="_blank" rel="noopener">http://jruby.org</a></p><p>JRuby几乎就是Jython的翻版，所不同的是，JRuby所对标的语言是Ruby，当前所支持的语法规范则和Ruby 2.3兼容。</p><p><strong>Ceylon</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-7.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="https://www.ceylon-lang.org" target="_blank" rel="noopener">https://www.ceylon-lang.org</a></p><p>这个以大象为Logo的语言，其创建初衷可不是像大象一样笨拙，恰恰相反，语言的创始人 Gavin King，是出于对Java所存在问题的深刻认识，如泛型等特性的复杂性、粗劣的注解语法、不完善的块结构、对 XML 的依赖性等等，才萌生了创建一种新的静态类型语言语言，即Ceylon来一劳永逸的解决这些问题的想法。</p><p>Ceylon保留了一些好的 Java 语言特性，改进了语言的可读性和内置的模块性，还吸收了高阶函数等函数语言特性，此外，Ceylon 还融合了 C 和 Smalltalk 的一些特性。与 Java 语言一样，这种新语言也以业务计算为重点，但是它在其他领域也很灵活、很有用。并且，通过这些年的努力，Ceylon已经跨出了其自身跨平台的第一步，其代码已经可以在JVM，Dart VM或Node.js上进行编译或运行。</p><p><strong>Eta</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-8.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="https://eta-lang.org/" target="_blank" rel="noopener">https://eta-lang.org/</a></p><p>我们的名单中怎么能少了时下最能装酷，也是被Node.js的创建者称为觉得暂无能力驾驭的语言Haskell的JVM实现？</p><p>它来了，就是Eta，它的优势，不仅仅在于它可以在JVM下执行，更在于它可以使用Haskell的软件包仓库中的软件包，最大程度的兼容了整个Haskell生态系统。</p><p><strong>Haxe</strong></p><p><img src="https://ss.csdn.net/p?http://codebay.cn/wp-content/uploads/2018/05/image.php_-9.gif" srcset="/img/loading.gif" alt></p><p>官方站点：<a href="http://haxe.org" target="_blank" rel="noopener">http://haxe.org</a></p><p>Haxe的口号是：One Language，Everywhere！是不是有点熟悉？是的，在非常久远的过去，这其实正是Java的初心。</p><p>但是，这二者又是如此的迥异。Java的策略是，我做一个平台JVM，给出一种规范，你们来生成我需要的代码；Haxe的策略则正好相反，既然芸芸众生，语言纷杂，每个人都各有偏好，那好，来吧，我可以把我的代码，生成任何一种你们想要的语言下的代码！</p><p>多么疯狂的想法！就为这点疯狂，就值得我们每个开发人员去膜拜一番了，毕竟，在Haxe看来，JVM，不过是其可以编译的一个“小”对象而已。</p><h3 id="值传递、引用传递"><a href="#值传递、引用传递" class="headerlink" title="值传递、引用传递"></a>值传递、引用传递</h3><p><strong>值传递</strong>：(形式参数类型是基本数据类型)：方法调用时，实际参数把它的值传递给对应的形式参数，形式参数只是用实际参数的值初始化自己的存储单元内容，是两个不同的存储单元，所以方法执行中形式参数值的改变不影响实际参数的值。</p><p><strong>引用传递</strong>：(形式参数类型是引用数据类型参数)：也称为传地址。方法调用时，实际参数是对象(或数组)，这时实际参数与形式参数指向同一个地址，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，这个结果在方法结束后被保留了下来，所以方法执行中形式参数的改变将会影响实际参数。</p><p>说明：</p><p>（1）：“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。</p><p>（2）：在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。就是直接使用双引号定义字符串方式：String str = “Java私塾”;</p><p>为什么说 Java 中只有值传递: <a href="https://blog.csdn.net/bjweimengshu/article/details/79799485" target="_blank" rel="noopener">https://blog.csdn.net/bjweimengshu/article/details/79799485</a></p><hr><blockquote><p>附参考</p><ul><li><a href="https://www.cnblogs.com/autumn001/p/9036148.html" target="_blank" rel="noopener">https://www.cnblogs.com/autumn001/p/9036148.html</a></li><li><a href="https://blog.csdn.net/B9Q8e64lO6mm/article/details/80235376" target="_blank" rel="noopener">https://blog.csdn.net/B9Q8e64lO6mm/article/details/80235376</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用Angular6创建各种动画效果</title>
    <link href="/2019/02/15/0015-ru-he-yong-angular6-chuang-jian-ge-chong-dong-hua-xiao-guo/"/>
    <url>/2019/02/15/0015-ru-he-yong-angular6-chuang-jian-ge-chong-dong-hua-xiao-guo/</url>
    
    <content type="html"><![CDATA[<h1 id="如何用Angular-6创建各种动画效果"><a href="#如何用Angular-6创建各种动画效果" class="headerlink" title="如何用Angular 6创建各种动画效果"></a>如何用Angular 6创建各种动画效果</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>就技术角度而言，动画可以被定义为从初始状态到最终状态的转换过程。如今它已是各种Web应用不可或缺的组成部分。通过动画，我们不仅能创建出各种酷炫的UI，同时它们也能增加应用程序的趣味性。因此，设计精美的动画在吸引用户眼球的同时，也增强了他们的浏览体验。</p><p>Angular能够让我们创建出具有原生表现效果的动画。我们将通过本文学习到如何使用Angular 6来创建各种动画效果。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装vs code和 Angular cli。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://stackblitz.com/edit/tk-angular-animations-01" target="_blank" rel="noopener">https://stackblitz.com/edit/tk-angular-animations-01</a></p><h2 id="理解Angular动画的不同状态"><a href="#理解Angular动画的不同状态" class="headerlink" title="理解Angular动画的不同状态"></a>理解Angular动画的不同状态</h2><p>动画是某个元素从一种状态向另一种状态的转变，Angular为单个元素定义出了三种不同的状态。</p><ol><li>void状态：void状态表示某个元素处于不是DOM一部分的状态。当一个元素被创建且尚未放到DOM中、或者该元素从DOM中移除时，就处于该状态。此状态特别实用，特别是当我们想通过添加或删除DOM中的元素，来创建动画的时候，我们在代码中使用关键字void来定义这种状态。</li><li>wildcard状态：又称元素的默认状态。不管当前的动画状态如何，各种样式都用这种状态来定义元素。我们在代码中用符号*来定义这种状态。</li><li>Custom状态：元素的这种状态需要在代码中被明确定义。我们在代码中可以使用任何自定义的名称来表示这种状态。</li></ol><h2 id="动画转换定时"><a href="#动画转换定时" class="headerlink" title="动画转换定时"></a>动画转换定时</h2><p>我们在自己的应用中，通过定义动画转换的定时，来显示从一个状态过度到另一个状态。Angular为我们提供了如下三种与时间相关的属性：</p><ol><li>持续时间(Duration)</li></ol><p>此属性表示我们的动画从开始(初始状态)到完成(最终状态)所需的时间。我们可以用以下三种方式来定义动画的持续时间：</p><ul><li>使用一个整数值，来表示以毫秒为单位的时间，例如：500</li><li>使用一个字符串值，来表示以毫秒为单位的时间，例如：’500ms’</li><li>使用一个字符串值，来表示以秒为单位的时间。例如：’0.5’</li></ul><ol start="2"><li>延迟(Delay)</li></ol><p>此属性代表动画从触发到和实际转换开始之间的时间间隔。该属性遵循与上述持续时间相同的语法规则。要定义延迟，我们需要在持续时间值的后面，以字符串的形式添加延迟的数值，即：’Duration Delay’。例如’ 0.3s 500ms’，表示转换将等待500毫秒，然后运行0.3秒。</p><ol start="3"><li>滑动(Easing)</li></ol><p>此属性表示动画在其执行过程中是如何被加速或减速的。我们可以在持续时间和延迟的字符串后面，添加第三个变量。当然，如果延迟数值不存在的话，那么Easing将成为第二个数值。这同样也是一个可选属性。例如：</p><ul><li>‘0.3s 500ms ease-in’。这意味着转换将等待500毫秒，然后运行0.3秒(300毫秒)，实现滑入的效果。</li><li>‘300ms ease-out’。这意味着转换将运行300毫秒(0.3秒)，实现滑出的效果。</li></ul><h2 id="创建Angular-6应用"><a href="#创建Angular-6应用" class="headerlink" title="创建Angular 6应用"></a>创建Angular 6应用</h2><p>请在您的计算机上打开命令提示行，并执行以下命令集：</p><ul><li>mkdir ngAnimationDemo</li><li>cd ngAnimationDemo</li><li>ng new ngAnimation</li></ul><p>这些命令将创建一个名为ngAnimationDemo的目录，然后在该目录内创建一个名为ngAnimation的Angular应用。</p><p>请使用Visual Studio Code打开ngAnimation应用。接着我们将创建自己的组件。</p><p>请依次进入View &gt;&gt; Integrated Terminal，这将打开Visual Studio Code的终端窗口。</p><p>请执行以下命令，以创建相应的组件：</p><pre><code class="hljs undefined"><span class="hljs-attribute">ng g c animationdemo</span></code></pre><p>它将在/src/app文件夹内创建我们的组件–animationdemo。</p><p>为了用到Angular动画，我们需要在应用中导入特定的动画模块–BrowserAnimationsModule。请打开app.module.ts文件，并添加如下的导入定义：</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; BrowserAnimationsModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser/animations'</span>;  <span class="hljs-comment">// other import definitions  </span><span class="hljs-meta">@NgModule</span>(&#123; imports: [BrowserAnimationsModule <span class="hljs-comment">// other imports]&#125;)</span></code></pre><h2 id="理解Angular动画的语法"><a href="#理解Angular动画的语法" class="headerlink" title="理解Angular动画的语法"></a>理解Angular动画的语法</h2><p>下面，我们在组件的元数据中编写动画代码。其语法如下：</p><pre><code class="hljs ts"><span class="hljs-meta">@Component</span>(&#123;<span class="hljs-comment">// other component properties.</span>  animations: [    trigger(<span class="hljs-string">'triggerName'</span>), [      state(<span class="hljs-string">'stateName'</span>, style())      transition(<span class="hljs-string">'stateChangeExpression'</span>, [Animation Steps])    ]  ]&#125;)</code></pre><p>此处，我们用到了名为animations的属性。该属性的输入是一个阵列，此阵列包含一个或多个“触发器”。同时，每个触发器都带有唯一的名称、和用来定义动画的状态和各种转换的具体实现。</p><p>另外，每一个状态函数都会通过“stateName”来唯一地识别其状态、并用样式函数来显示在该状态下的元素样式。</p><p>当然，每个转换函数也都通过stateChangeExpression，来定义元素状态转换、并定义动画的不同步骤所对应的阵列，从而能够显示出转换是如何发生的。在此，我们就可以用逗号分隔的数值，来将多个触发器函数包括到动画的属性之中。</p><p>由于这些功能(触发、状态、和转换)都被定义在@angular/animations模块之中，因此，我们需要在自己的组件导入该模块。</p><p>为了将动画应用到某个元素之上，我们需要在元素的定义中包含触发器的名称，即：在元素的标签里使用@后面加触发器名称的格式。对应的代码示例如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">changeSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>这是将触发器changeSize应用到元素的上。</p><p>下面，让我们创建更多的动画，以更好地理解Angular的动画概念吧。</p><p>更改大小的动画</p><p>我们将创建一个动画，来实现一键改变的大小。</p><p>请打开animationdemo.component.ts文件，将如下代码添加到导入定义之中。</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; trigger, state, style, animate, transition &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/animations'</span>;</code></pre><p>在组件的元数据中添加如下的动画属性定义。</p><pre><code class="hljs ts">animations: [  trigger(<span class="hljs-string">'changeDivSize'</span>, [    state(<span class="hljs-string">'initial'</span>, style(&#123;      backgroundColor: <span class="hljs-string">'green'</span>,      width: <span class="hljs-string">'100px'</span>,      height: <span class="hljs-string">'100px'</span>    &#125;)),    state(<span class="hljs-string">'final'</span>, style(&#123;      backgroundColor: <span class="hljs-string">'red'</span>,      width: <span class="hljs-string">'200px'</span>,      height: <span class="hljs-string">'200px'</span>    &#125;)),    transition(<span class="hljs-string">'initial=&gt;final'</span>, animate(<span class="hljs-string">'1500ms'</span>)),    transition(<span class="hljs-string">'final=&gt;initial'</span>, animate(<span class="hljs-string">'1000ms'</span>))  ]),]</code></pre><p>在此，我们定义了一个触发器—changeDivSize，而且该触发器里的两个功能函数。该元素在“初始”状态时呈现绿色，并随着宽度和高度的增加，在“最终”状态时呈现为红色。</p><p>同时，我们定义了状态的转换规则：从“初始”态到“最终”态将持续1500毫秒，而从“最终”态返回“初始”态则为1000毫秒。</p><p>为了改变元素的状态，我们在组件的类定义中定义了一个功能函数。我们将如下代码包含在AnimationdemoComponent类中：</p><pre><code class="hljs ts">currentState = <span class="hljs-string">'initial'</span>;changeState() &#123;  <span class="hljs-keyword">this</span>.currentState = <span class="hljs-keyword">this</span>.currentState === <span class="hljs-string">'initial'</span> ? <span class="hljs-string">'final'</span> : <span class="hljs-string">'initial'</span>;&#125;</code></pre><p>此处，我们定义了一个changeState方法，来切换元素的状态。</p><p>请打开animationdemo.component.html文件，并添加以下代码：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Change the div size<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"changeState()"</span>&gt;</span>Change Size<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [@<span class="hljs-attr">changeDivSize</span>]=<span class="hljs-string">currentState</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span></code></pre><p>我们定义了一个按钮，来调用点击时的changeState函数。由于我们前面已经定义了元素，并对它应用了changeDivSize动画触发器，因此当按钮被点击时，它会更新元素的状态，其大小则会伴随着转换效果而发生变化。</p><p>在执行该应用之前，我们也需要将引用包含在app.component.html文件内的Animationdemo组件中。</p><p>打开app.component.html文件，您会发现该文件中已包含了一些默认的HTML代码。请删除所有的代码，并按照下图所示放置组件的选择器：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-animationdemo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-animationdemo</span>&gt;</span></code></pre><p>请在Visual Studio Code的终端窗口里运行ng serve命令，以执行该代码。运行完毕后，它会提示您在浏览器中打开<a href="http://localhost:4200。随后，您就会在浏览器中看到如下点击按钮的动画效果。" target="_blank" rel="noopener">http://localhost:4200。随后，您就会在浏览器中看到如下点击按钮的动画效果。</a></p><h2 id="气球动画效果"><a href="#气球动画效果" class="headerlink" title="气球动画效果"></a>气球动画效果</h2><p>在前面的动画示例中，转化仅发生在两个方向。而在本节中，我们将学习如何改变所有方向上的尺寸。这与气球的充、放气比较类似，故称为气球动画效果。</p><p>请在动画属性中添加如下的触发器定义。</p><pre><code class="hljs ts">trigger(<span class="hljs-string">'balloonEffect'</span>, [   state(<span class="hljs-string">'initial'</span>, style(&#123;     backgroundColor: <span class="hljs-string">'green'</span>,     transform: <span class="hljs-string">'scale(1)'</span>   &#125;)),   state(<span class="hljs-string">'final'</span>, style(&#123;     backgroundColor: <span class="hljs-string">'red'</span>,     transform: <span class="hljs-string">'scale(1.5)'</span>   &#125;)),   transition(<span class="hljs-string">'final=&gt;initial'</span>, animate(<span class="hljs-string">'1000ms'</span>)),   transition(<span class="hljs-string">'initial=&gt;final'</span>, animate(<span class="hljs-string">'1500ms'</span>)) ]),</code></pre><p>在此，我们使用转换属性来更改所有方向的尺寸大小。当该元素的状态发生变化时转换随即发生。</p><p>请在app.component.html文件中添加如下HTML代码。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Balloon Effect<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"changeState()"</span>    <span class="hljs-attr">style</span>=<span class="hljs-string">"width:100px;height:100px; border-radius: 100%; margin: 3rem; background-color: green"</span>  [@<span class="hljs-attr">balloonEffect</span>]=<span class="hljs-string">currentState</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>在此，我们定义了一个div，并通过CSS样式来定义成一个圆圈。我们将通过点击div去调用changeState，从而实现元素状态的切换。</p><p>下图便是该动画在浏览器中的运行效果：</p><p>淡入和淡出动画</p><p>有时候，我们需要在显示动画的同时，对DOM添加或移除元素。下面，我们来看看如何通过对一个列表添加或删除条目，以实现淡入和淡出的动画效果。</p><p>请将如下代码插入AnimationdemoComponent类的定义之中。</p><pre><code class="hljs ts">listItem = [];list_order: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;addItem() &#123;  <span class="hljs-keyword">var</span> listitem = <span class="hljs-string">"ListItem "</span> + <span class="hljs-keyword">this</span>.list_order;  <span class="hljs-keyword">this</span>.list_order++;  <span class="hljs-keyword">this</span>.listItem.push(listitem);&#125;removeItem() &#123;  <span class="hljs-keyword">this</span>.listItem.length -= <span class="hljs-number">1</span>;&#125;</code></pre><p>请在该动画的属性中添加如下的触发器定义。</p><pre><code class="hljs ts">trigger(<span class="hljs-string">'fadeInOut'</span>, [  state(<span class="hljs-string">'void'</span>, style(&#123;    opacity: <span class="hljs-number">0</span>  &#125;)),  transition(<span class="hljs-string">'void &lt;=&gt; *'</span>, animate(<span class="hljs-number">1000</span>)),]),</code></pre><p>在此，我们定义了触发器fadeInOut。当该元素被添加到DOM时，它的状态就从void转换为wildcard，我们表示为void =&gt; <em>。而当该元素从DOM删除时，它的状态就从wildcard转换为void，我们表示为</em> =&gt; void。</p><p>我们给动画的不同方向使用相同的动画定时，其语法为&lt;=&gt;。正如该触发器所定义的，动画从void =&gt; * 和 * =&gt; void，都需要1000毫秒才能完成。</p><p>请在app.component.html文件中添加如下HTML代码。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Fade-In and Fade-Out animation<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addItem()"</span>&gt;</span>Add List<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"removeItem()"</span>&gt;</span>Remove List<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:200px; margin-left: 20px"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let list of listItem"</span> [@<span class="hljs-attr">fadeInOut</span>]&gt;</span>      &#123;&#123;list&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>在此，我们定义了两个按钮来添加和删除条目。我们将fadeInOut触发器与元素绑定，以实现在对DOM进行添加、删除时，能够出现淡入和淡出的效果。</p><p>下图便是该动画在浏览器中的运行效果：</p><p>进入和离开动画</p><p>此外，我们还能够通过对DOM的添加，实现某个元素从左边进入屏幕;而在删除时，能让该元素从右边离开屏幕。</p><p>由于从void =&gt; * 和 * =&gt; void 的转换十分常见。因此，Angular为这些动画提供了别名机制：</p><ul><li>对于 void =&gt; * ，我们可以用’:enter’</li><li>对于 * =&gt; void ，我们可以用’:leave’</li></ul><p>这两个别名使得此类转换更具可读性，也更容易被理解。</p><p>请在动画的属性中添加如下触发器的定义。</p><pre><code class="hljs ts">trigger(<span class="hljs-string">'EnterLeave'</span>, [  state(<span class="hljs-string">'flyIn'</span>, style(&#123; transform: <span class="hljs-string">'translateX(0)'</span> &#125;)),  transition(<span class="hljs-string">':enter'</span>, [    style(&#123; transform: <span class="hljs-string">'translateX(-100%)'</span> &#125;),    animate(<span class="hljs-string">'0.5s 300ms ease-in'</span>)  ]),  transition(<span class="hljs-string">':leave'</span>, [    animate(<span class="hljs-string">'0.3s ease-out'</span>, style(&#123; transform: <span class="hljs-string">'translateX(100%)'</span> &#125;))  ])])</code></pre><p>在此，我们定义了触发器EnterLeave。那么’:enter’的转换需要等待300毫秒，然后运行0.5秒，并实现滑入的效果;而’:leave’的转换只运行0.3秒，实现滑出的效果。</p><p>请在app.component.html文件中添加如下HTML代码。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Enter and Leave animation<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"addItem()"</span>&gt;</span>Add List<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"removeItem()"</span>&gt;</span>Remove List<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width:200px; margin-left: 20px"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let list of listItem"</span> [@<span class="hljs-attr">EnterLeave</span>]=<span class="hljs-string">"'flyIn'"</span>&gt;</span>      &#123;&#123;list&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>在此，我们定义了两个按钮来对列表添加和删除条目。我们将EnterLeave触发器与元素绑定，以实现在对DOM进行添加、删除时，出现滑入和滑出的效果。</p><p>下图便是该动画在浏览器中的运行效果：</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，我们针对Angular 6的动画效果，探讨了动画状态和转换的概念，也通过一个应用示例展示了实际的动画代码与效果。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Nexus系列】之npm私服库配置</title>
    <link href="/2018/12/21/0014-create-npm-repository-with-nexus/"/>
    <url>/2018/12/21/0014-create-npm-repository-with-nexus/</url>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fyd08s62ypj20xc0dwwmr.jpg" srcset="/img/loading.gif" alt></p><h1 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h1><p>Nexus Repository Manager 3 可以用于多种类型的包管理。 因工作需要，需要配置基于Nexus 3的npm包管理。</p><blockquote><p>Nexus默认账号: admin/admin123</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fycz6n4q9cj20xr0hrac9.jpg" srcset="/img/loading.gif" alt></p><ol><li>选择配置页面</li><li>选择左侧的Repositories</li><li>点击Create repository功能</li></ol><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fycz8kaf4jj20gk0o7ta9.jpg" srcset="/img/loading.gif" alt></p><p>这样就会看到Nexus 3支持的repository类型。对于Java开发者maven2的应该就很熟悉了。</p><p>仔细观察会发现，每一种repository都包含三种类型可以创建, group, hosted,proxy。下面分别对每种做说明：</p><ul><li>proxy</li></ul><p>根据proxy名字，就可以想象的出这种类型的repository是用来坐代理的。比如我们在建Maven私服，需要和中央库连通，此时就需要用proxy来创建repository。见Nexus模式的maven-central库。</p><ul><li>hosted</li></ul><p>这种repository可以简单的理解为用于私有的，内部的repository。我们工作中开发的一些工具，组件库等不方便放到中央库，但是却又需要在公司内部共享，就需要创建hosted类型的repository，用于发布公司内部的组件。见maven-releases, maven-snapshots。</p><ul><li>group</li></ul><p>最后来说说group类型。其实这种类型是一种虚拟的repository，用于将proxy和hosted类型的repository组合成一个，方便使用者使用。如maven-public, 在里面既包含了maven-central，同时也包含了maven-releases, maven-snapshots,这样，不管是网上中央库的jar包，还是我们自己发布的jar都可以通过maven-public来获取到。</p><p>结合maven repository配置的经验，对于npm repository也采用同样的套路配置。</p><ol><li>配置proxy库</li></ol><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fyczoph1jbj20kj0dbdgk.jpg" srcset="/img/loading.gif" alt><br>在proxy类型的配置界面，发现里面的Name、Remote storage是必填的。Name可以随便填。Remote storage需要填类似maven中央库的地址，这里npm的选择淘宝的私服地址<code>https://registry.npm.taobao.org</code></p><ol start="2"><li>配置hosted库<br><img src="https://ws1.sinaimg.cn/large/806e3151ly1fyczsmhcnbj20is0i6wf5.jpg" srcset="/img/loading.gif" alt></li></ol><p>hosted库配置比较简单，只需要填写name就可以了。</p><ol start="3"><li>配置Group库</li></ol><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fycztxee51j20l50l1mxw.jpg" srcset="/img/loading.gif" alt></p><p>在group配置中，name同样是必须的。此外还多了一个members的配置，将左侧的npm-hosted,npm-proxy添加到右侧的members中，这样就可以通过group同时访问npm-hosted,npm-proxy中的资源了。</p><h1 id="发布到npm私服"><a href="#发布到npm私服" class="headerlink" title="发布到npm私服"></a>发布到npm私服</h1><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fyczztbu5ij20k009jgp4.jpg" srcset="/img/loading.gif" alt></p><p>首先，需要配置权限，将npm Bearer Token Realm启用。</p><p>配置本机的npm登陆</p><pre><code class="hljs undefined">npm login --registry=http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8888</span><span class="hljs-regexp">/repository/</span>npm-hosted<span class="hljs-regexp">/</span></code></pre><p>然后输入用户名密码，邮箱，成功后会在<code>.npmrc</code>文件中生成一条记录</p><pre><code class="hljs undefined">/<span class="hljs-regexp">/localhost:8888/repository</span><span class="hljs-regexp">/npm-hosted/</span><span class="hljs-symbol">:_authToken=NpmToken</span>.<span class="hljs-number">16b06</span>a38-cae5<span class="hljs-number">-32</span>ca<span class="hljs-number">-8a5</span>f<span class="hljs-number">-2310</span>ef16e156</code></pre><p>在确保项目有 package.json 前提下，执行：</p><pre><code class="hljs undefined">npm publish  --registry=http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8888</span><span class="hljs-regexp">/repository/</span>npm-hosted<span class="hljs-regexp">/</span></code></pre><p>即可在私服中查询到已发的npm组件<br><img src="https://ws1.sinaimg.cn/large/806e3151ly1fyd02la9jnj21h60ez3zv.jpg" srcset="/img/loading.gif" alt></p><hr><blockquote><p>Author ：笑笑粑粑<br>曾用网名：TinyKing<br>微信公众号：Java码农<br>知乎专栏： <a href="https://zhuanlan.zhihu.com/tinyking" target="_blank" rel="noopener">爱笑笑爱分享</a><br>个人博客： <a href="https://www.wangjianchao.cn/" target="_blank" rel="noopener">爱笑笑，爱生活</a><br>自我评价： 一个爱好广泛的CRUD程序猿 ^_^   </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Npm</tag>
      
      <tag>Nexus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular的@Output与@Input浅析</title>
    <link href="/2018/12/04/0013-angular-output-input-analysis/"/>
    <url>/2018/12/04/0013-angular-output-input-analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="Output与-Input理解"><a href="#Output与-Input理解" class="headerlink" title="@Output与@Input理解"></a>@Output与@Input理解</h1><p>Output和Input是两个装饰器，是Angular2专门用来实现跨组件通讯，双向绑定等操作所用的。</p><h2 id="Input"><a href="#Input" class="headerlink" title="@Input"></a>@Input</h2><p>Component本身是一种支持 nest 的结构，Child和Parent之间，如果Parent需要把数据传输给child并在child自己的页面中显示，则需要在Child的对应 directive 标示为 input。</p><p>例如：</p><pre><code class="hljs undefined"><span class="hljs-keyword">@Input</span>() <span class="hljs-attribute">name:</span> string;</code></pre><p>我们通过一个例子来分析下<code>@Input</code>的流程。</p><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fxtu0ia0t7j216m0pgjwe.jpg" srcset="/img/loading.gif" alt></p><p>流程：</p><ol><li>child_component.ts内有students，并且是被@Input标记的，那么这个属性就作为输入属性</li><li>在parent_component.html内直接使用了students，那是因为在parent.module.ts内将child组件import进来了</li><li>[students]这种形式叫属性绑定，绑定的值为school.schoolStudents属性</li><li>Angular会把schoolStudents的值赋值给students，然后影响到子组件的显示</li></ol><p>所以我们可以总结，child_component中有数据要显示，但是这个数据的来源是通过parent_component.html中通过属性绑定的形式作为child组件的输入，要想child组件内的students属性能够成功赋值，那么必须使用@Input。</p><p><code>@Input</code>还可以使用typescript的get set存取器的方式来设置属性</p><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> _name: string;<span class="hljs-meta">@Input</span> <span class="hljs-keyword">get</span> name() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;&#125;<span class="hljs-keyword">set</span>(name:string) &#123;<span class="hljs-keyword">this</span>._name = name;&#125;</code></pre><h2 id="Output"><a href="#Output" class="headerlink" title="@Output"></a>@Output</h2><p>Output的数据流方向与input是相反的，所以那就是child控制parent的数据显示，input是parent控制child的数据显示。</p><p><strong>注意</strong><br>Angular 2中，@Output的实现必须使用EventEmitter来实现。<br>并且当你使用了tslint之后，变量不能加on，但是可以通过加入这样一段注释</p><pre><code class="hljs undefined"><span class="hljs-regexp">//</span> tslint:disable-next-line:<span class="hljs-literal">no</span>-output-<span class="hljs-literal">on</span>-prefix@Output() onRemoveElement = <span class="hljs-keyword">new</span> EventEmitter&lt;Element&gt;();</code></pre><p>形如：</p><pre><code class="hljs undefined"><span class="hljs-comment">// 要将EventEmitter先import进来。</span><span class="hljs-keyword">import</span> &#123; Component, Input, Output, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;...<span class="hljs-meta">@Output</span>() mySignal = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">boolean</span>&gt;();</code></pre><p>EventEmitter();中间的boolean参数是你需要传递数据的类型，当然可以是基本类型，也可以是自定义类型。</p><p>我们还是老样子，通过一个例子来分析一下吧。</p><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fxtu7s2pydj218a0ueq92.jpg" srcset="/img/loading.gif" alt></p><p>我们通过这张图可以看到，整个事件的流程，那我们来分析一下：</p><p>child组件内有一个Output customClick的事件，事件的数据类型是number<br>child组件内有一个onClicked方法，这个是应用在html中button控件的click事件中，通过(click)=”onClicked()”进行方法绑定<br>parent组件内有一个public的属性showMsg,Angular的ts类默认不写关键字就是public。</p><p>parent组件内有一个onCustomClicked方法，这个也是要用在html中的，是和child组件内的output标记的customClick事件进行绑定的<br>步骤为child的html的button按钮被点击-&gt;onClicked方法被调用-&gt;emit(99)触发customClick-&gt;Angular通过Output数据流识别出发生变化并通知parent的html中(customClick)-&gt;onCustomClicked(event)被调用，event)被调用，event为数据99-&gt;改变了showMsg属性值-&gt;影响到了parent的html中的显示由1变为99。</p><p><strong>小知识：</strong></p><p>其实双向绑定就是这么实现的，只是将input和output一起使用即可达到目的。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular material中自定义分页信息</title>
    <link href="/2018/12/03/0012-custom-material-paginator-label/"/>
    <url>/2018/12/03/0012-custom-material-paginator-label/</url>
    
    <content type="html"><![CDATA[<p>在项目开发中，用到了Material的分页组件，需要对该组件进行汉化。</p><p><img src="https://ws1.sinaimg.cn/large/806e3151ly1fxtkeefsycj20gt065jrd.jpg" srcset="/img/loading.gif" alt></p><p>首先创建自定义汉化类：</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;MatPaginatorIntl&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MatPaginatorIntlCro <span class="hljs-keyword">extends</span> MatPaginatorIntl  &#123;  <span class="hljs-comment">/** A label for the page size selector. */</span>  itemsPerPageLabel = <span class="hljs-string">'每页条数: '</span>;  <span class="hljs-comment">/** A label for the button that increments the current page. */</span>  nextPageLabel = <span class="hljs-string">'下一页'</span>;  <span class="hljs-comment">/** A label for the button that decrements the current page. */</span>  previousPageLabel = <span class="hljs-string">'上一页'</span>;  <span class="hljs-comment">/** A label for the button that moves to the first page. */</span>  firstPageLabel = <span class="hljs-string">'首页'</span>;  <span class="hljs-comment">/** A label for the button that moves to the last page. */</span>  lastPageLabel = <span class="hljs-string">'尾页'</span>;  <span class="hljs-comment">/** A label for the range of items within the current page and the length of the whole list. */</span>  getRangeLabel =  <span class="hljs-function">(<span class="hljs-params">page: <span class="hljs-built_in">number</span>, pageSize: <span class="hljs-built_in">number</span>, length: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (length === <span class="hljs-number">0</span> || pageSize === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">'0 od'</span> + length;    &#125;    length = <span class="hljs-built_in">Math</span>.max(length, <span class="hljs-number">0</span>);    <span class="hljs-keyword">const</span> startIndex = page * pageSize;    <span class="hljs-keyword">const</span> endIndex = startIndex &lt; length                      ? <span class="hljs-built_in">Math</span>.min(startIndex + pageSize, length)                      : startIndex + pageSize;    <span class="hljs-keyword">return</span> <span class="hljs-string">`第<span class="hljs-subst">$&#123;startIndex + <span class="hljs-number">1</span>&#125;</span>-<span class="hljs-subst">$&#123;endIndex&#125;</span>条, 总共<span class="hljs-subst">$&#123;length&#125;</span>条`</span>;  &#125;&#125;</code></pre><p>在<code>app.module.ts</code>中声明该Provider：</p><pre><code class="hljs typescript">providers: [   &#123;provide: MatPaginatorIntl, useClass: MatPaginatorIntlCro &#125;   ]</code></pre><p>这样在再使用分页组件时，相关信息将显示中文。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态代理：JDK动态代理和CGLIB代理的区别</title>
    <link href="/2018/11/26/0011-jdk-and-cglib-proxy/"/>
    <url>/2018/11/26/0011-jdk-and-cglib-proxy/</url>
    
    <content type="html"><![CDATA[<p>代理模式：代理类和被代理类实现共同的接口（或继承），代理类中存有被代理类的索引，实际执行时通过调用代理类的方法，实际执行的是被代理类的方法。</p><p><img src="http://img.hb.aicdn.com/29f71c9def992be7b94c3566c6a7fd03bdcb93df32f3-49dKXs_fw658" srcset="/img/loading.gif" alt></p><p>而AOP，是通过动态代理实现的。</p><p>一、简单来说：</p><p>　　JDK动态代理只能对实现了接口的类生成代理，而不能针对类</p><p>　　CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）</p><p>二、Spring在选择用JDK还是CGLiB的依据：</p><p>   (1)当Bean实现接口时，Spring就会用JDK的动态代理</p><p>   (2)当Bean没有实现接口时，Spring使用CGlib是实现</p><p>　  (3)可以强制使用CGlib（在spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;）</p><p>三、CGlib比JDK快？</p><p>　 (1)使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>　 (2)在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p><blockquote><p>作者：Big_Monkey<br>原文地址: <a href="https://www.cnblogs.com/bigmonkeys/p/7823268.html" target="_blank" rel="noopener">动态代理：JDK动态代理和CGLIB代理的区别</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Zuul集成静态资源</title>
    <link href="/2018/11/23/0010-spring-cloud-zuul-integrate-static-resource/"/>
    <url>/2018/11/23/0010-spring-cloud-zuul-integrate-static-resource/</url>
    
    <content type="html"><![CDATA[<p>项目中需要将前端的静态资源打包集成到zuul中，直接将静态资源放到zuul项目的/src/main/resources/static下，通过浏览器访问，发现无法访问。原因是zuul对所有的请求都进行了路由转发。</p><p>一开始的配置如下：</p><pre><code class="hljs undefined"><span class="hljs-string">zuul:</span>    servlet-<span class="hljs-string">path:</span> /    sensitive-<span class="hljs-string">headers:</span></code></pre><p>在这种配置下，zuul对于后台其他restful服务进行的自动转发：</p><p>如eureka中注册了a服务，当访问<code>/a/service</code>时，zuul自动将该请求转发到a服务上。</p><p>通过修改配置，实现了静态资源的集成，配置如下：</p><pre><code class="hljs undefined"><span class="hljs-symbol">zuul:</span><span class="hljs-meta"># servlet-path: /</span>    sensitive-headers:    ignored-services: <span class="hljs-string">'*'</span><span class="hljs-symbol">    routes:</span><span class="hljs-symbol">        a:</span> <span class="hljs-meta-keyword">/a/</span>**<span class="hljs-symbol">        b:</span> <span class="hljs-meta-keyword">/b/</span>**</code></pre><p>禁用zuul的自动路由配置，通过指定路由，去掉<code>serlvet-path</code></p><p>实现集成静态资源。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zuul</tag>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql建表语句中显示双引号</title>
    <link href="/2018/11/20/0009-msyql-use-double-quotes/"/>
    <url>/2018/11/20/0009-msyql-use-double-quotes/</url>
    
    <content type="html"><![CDATA[<p>在工作中使用Mysql数据库，发现建表后的ddl显示表名、字段都是双引号。这样的ddl在线上工单系统无法通过，需要将双引号转成反引号(`)才行。</p><p>通过执行命令<code>show VARIABLES like &#39;%sql%&#39;</code>发现，<code>sql_mode</code>的值是<code>ANSI_QUOTES</code>。</p><p>查看my.cnf配置文件，发现有如下配置:</p><pre><code class="hljs undefined"><span class="hljs-comment"># 对本地的mysql客户端的配置</span><span class="hljs-section">[client]</span><span class="hljs-comment">#default-character-set = utf8</span><span class="hljs-comment"># 对其他远程连接的mysql客户端的配置</span><span class="hljs-section">[mysql]</span><span class="hljs-attr">default-character-set</span> = utf8<span class="hljs-comment"># 本地mysql服务的配置</span><span class="hljs-section">[mysqld]</span><span class="hljs-attr">datadir</span>=/var/lib/mysql<span class="hljs-attr">socket</span>=/var/lib/mysql/mysql.sock<span class="hljs-attr">user</span>=mysql<span class="hljs-comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span><span class="hljs-attr">symbolic-links</span>=<span class="hljs-number">0</span><span class="hljs-attr">character-set-server</span> = utf8<span class="hljs-attr">sql_mode</span>=<span class="hljs-string">'ANSI_QUOTES'</span><span class="hljs-attr">default-storage-engine</span>=INNODB<span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span><span class="hljs-attr">log-bin</span>=mysql-bin<span class="hljs-attr">binlog_format</span>=MIXED<span class="hljs-attr">expire_logs_days</span>=<span class="hljs-number">30</span><span class="hljs-section">[mysqld_safe]</span><span class="hljs-attr">log-error</span>=/var/log/mysqld.log</code></pre><p>将mysqld下的sql_mode配置去掉，重启服务即可。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx功能解密</title>
    <link href="/2018/11/20/0008-nginx-all/"/>
    <url>/2018/11/20/0008-nginx-all/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在用最通俗的语言讲述最枯燥的基本知识</p></blockquote><p>Nginx作为一个高性能的web服务器，想必大家垂涎已久，蠢蠢欲动，想学习一番了吧，语法不多说，网上一大堆。下面博主就nginx<br>的非常常用的几个功能做一些讲述和分析，学会了这几个功能，平常的开发和部署就不是什么问题了。因此希望大家看完之后，能自己装个nginx来学习配置测试，这样才能真正的掌握它。</p><blockquote><p>文章提纲：</p><ol><li>正向代理</li><li>反向代理</li><li>透明代理</li><li>负载均衡</li><li>静态服务器</li><li>Nginx的安装</li></ol></blockquote><hr><h3 id="1-正向代理"><a href="#1-正向代理" class="headerlink" title="1. 正向代理"></a>1. 正向代理</h3><blockquote><p>正向代理：内网服务器主动去请求外网的服务的一种行为</p></blockquote><p>光看概念，可能有读者还是搞不明白：什么叫做“正向”，什么叫做“代理”，我们分别来理解一下这两个名词。</p><blockquote><p>正向：相同的或一致的方向<br>代理：自己做不了的事情或者自己不打算做的事情，委托或依靠别人来完成。</p></blockquote><p>借助解释，回归到nginx的概念，正向代理其实就是说客户端无法主动或者不打算完成主动去向某服务器发起请求，而是委托了nginx代理服务器去向服务器发起请求，并且获得处理结果，返回给客户端。<br>从下图可以看出：<strong>客户端向目标服务器发起的请求，是由代理服务器代替它向目标主机发起，得到结果之后，通过代理服务器返回给客户端。</strong></p><p><img src="https://www.itcodemonkey.com/data/upload/portal/20181114/1542195547528384.jpg" srcset="/img/loading.gif" alt="img"></p><p>举个栗子：广大社会主义接班人都知道，为了保护祖国的花朵不受外界的乌烟瘴气熏陶，国家对网络做了一些“优化”，正常情况下是不能外网的，但作为程序员的我们如果没有谷歌等搜索引擎的帮助，再销魂的代码也会因此失色，因此，网络上也曾出现过一些fan qiang技术和软件供有需要的人使用，如某VPN等，其实VPN的原理大体上也类似于一个正向代理，也就是需要访问外网的电脑，发起一个访问外网的请求，通过本机上的VPN去寻找一个可以访问国外网站的代理服务器，代理服务器向外国网站发起请求，然后把结果返回给本机。</p><blockquote><p>正向代理的配置:</p></blockquote><pre><code class="hljs undefined"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment">#指定DNS服务器IP地址  </span>    <span class="hljs-attribute">resolver</span> <span class="hljs-number">114.114.114.114</span>;       <span class="hljs-comment">#指定代理端口    </span>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;      <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-comment">#设定代理服务器的协议和地址（固定不变）    </span>        <span class="hljs-attribute">proxy_pass</span> http://<span class="hljs-variable">$http_host</span><span class="hljs-variable">$request_uri</span>;    &#125;  &#125;</code></pre><p>这样就可以做到内网中端口为8080的服务器主动请求到1.2.13.4的主机上，如在Linux下可以：</p><pre><code class="hljs undefined"><span class="hljs-number">1</span>curl --proxy <span class="hljs-string">proxy_server:</span><span class="hljs-number">8080</span> <span class="hljs-string">http:</span><span class="hljs-comment">//www.taobao.com/</span></code></pre><p>正向代理的关键配置：</p><blockquote><ol><li>resolver：DNS服务器IP地址</li><li>listen：主动发起请求的内网服务器端口</li><li>proxy_pass：代理服务器的协议和地址</li></ol></blockquote><h3 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2. 反向代理"></a>2. 反向代理</h3><blockquote><p>反向代理：reverse proxy，是指用代理服务器来接受客户端发来的请求，然后将请求转发给内网中的上游服务器，上游服务器处理完之后，把结果通过nginx返回给客户端。</p></blockquote><p>上面讲述了正向代理的原理，相信对于反向代理，就很好理解了吧。<br>反向代理是对于来自外界的请求，先通过nginx统一接受，然后按需转发给内网中的服务器，并且把处理请求返回给外界客户端，此时代理服务器对外表现的就是一个web服务器，客户端根本不知道“上游服务器”的存在。</p><p><img src="https://www.itcodemonkey.com/data/upload/portal/20181114/1542195548421886.jpg" srcset="/img/loading.gif" alt="img"></p><p>举个栗子：一个服务器的80端口只有一个，而服务器中可能有多个项目，如果A项目是端口是8081，B项目是8082，C项目是8083，假设指向该服务器的域名为<a href="http://www.xxx.com，此时访问B项目是www.xxx.com:8082，以此类推其它项目的URL也是要加上一个端口号，这样就很不美观了，这时我们把80端口给nginx服务器，给每个项目分配一个独立的子域名，如A项目是a.xxx.com，并且在nginx中设置每个项目的转发配置，然后对所有项目的访问都由nginx服务器接受，然后根据配置转发给不同的服务器处理。具体流程如下图所示：" target="_blank" rel="noopener">www.xxx.com，此时访问B项目是www.xxx.com:8082，以此类推其它项目的URL也是要加上一个端口号，这样就很不美观了，这时我们把80端口给nginx服务器，给每个项目分配一个独立的子域名，如A项目是a.xxx.com，并且在nginx中设置每个项目的转发配置，然后对所有项目的访问都由nginx服务器接受，然后根据配置转发给不同的服务器处理。具体流程如下图所示：</a></p><p><img src="https://www.itcodemonkey.com/data/upload/portal/20181114/1542195548507062.jpg" srcset="/img/loading.gif" alt="img"></p><blockquote><p>反向代理配置:</p></blockquote><pre><code class="hljs undefined"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment">#监听端口</span>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-comment">#服务器名称，也就是客户端访问的域名地址</span>    <span class="hljs-attribute">server_name</span>  a.xxx.com;    <span class="hljs-comment">#nginx日志输出文件</span>    <span class="hljs-attribute">access_log</span>  logs/nginx.access.log  main;    <span class="hljs-comment">#nginx错误日志输出文件</span>    <span class="hljs-attribute">error_log</span>  logs/nginx.<span class="hljs-literal">error</span>.log;    <span class="hljs-attribute">root</span>   html;    <span class="hljs-attribute">index</span>  index.html index.htm index.php;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-comment">#被代理服务器的地址</span>        <span class="hljs-attribute">proxy_pass</span>  http://localhost:8081;        <span class="hljs-comment">#对发送给客户端的URL进行修改的操作</span>        <span class="hljs-attribute">proxy_redirect</span>     <span class="hljs-literal">off</span>;        <span class="hljs-attribute">proxy_set_header</span>   Host             <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP        <span class="hljs-variable">$remote_addr</span>;        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-For  <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        <span class="hljs-attribute">proxy_next_upstream</span> <span class="hljs-literal">error</span> timeout invalid_header http_500 http_502 http_503 http_504;        <span class="hljs-attribute">proxy_max_temp_file_size</span> <span class="hljs-number">0</span>;   &#125;&#125;</code></pre><p>这样就可以通过a.xxx.com来访问a项目对应的网站了，而不需要带上难看的端口号。<br>反向代理的配置关键点是：</p><blockquote><ol><li>server_name：代表客户端向服务器发起请求时输入的域名</li><li>proxy_pass：代表源服务器的访问地址，也就是真正处理请求的服务器（localhost+端口号）。</li></ol></blockquote><h3 id="3-透明代理"><a href="#3-透明代理" class="headerlink" title="3. 透明代理"></a>3. 透明代理</h3><blockquote><p>透明代理：也叫做简单代理，意思客户端向服务端发起请求时，请求会先到达透明代理服务器，代理服务器再把请求转交给真实的源服务器处理，也就是是客户端根本不知道有代理服务器的存在。</p></blockquote><p>举个栗子：它的用法有点类似于拦截器，如某些制度严格的公司里的办公电脑，无论我们用电脑做了什么事情，安全部门都能拦截我们对外发送的任何东西，这是因为电脑在对外发送时，实际上先经过网络上的一个透明的服务器，经过它的处理之后，才接着往外网走，而我们在网上冲浪时，根本没有感知到有拦截器拦截我们的数据和信息。</p><p><img src="https://www.itcodemonkey.com/data/upload/portal/20181114/1542195548380599.jpg" srcset="/img/loading.gif" alt="img"></p><p>有人说透明代理和反向代理有点像，都是由代理服务器先接受请求，再转发到源服务器。其实本质上是有区别的，透明代理是客户端感知不到代理服务器的存在，而反向代理是客户端感知只有一个代理服务器的存在，因此他们一个是隐藏了自己，一个是隐藏了源服务器。事实上，透明代理和正向代理才是相像的，都是由客户端主动发起请求，代理服务器处理；他们差异点在于：正向代理是代理服务器代替客户端请求，而透明代理是客户端在发起请求时，会先经过透明代理服务器，再达到服务端，在这过程中，客户端是感知不到这个代理服务器的。</p><h3 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h3><p>负载均衡：将服务器接收到的请求按照规则分发的过程，称为负载均衡。负载均衡是反向代理的一种体现。</p><p>可能绝大部分人接触到的web项目，刚开始时都是一台服务器就搞定了，但当网站访问量越来越大时，单台服务器就扛不住了，这时候需要增加服务器做成集群来分担流量压力，而在架设这些服务器时，nginx就充当了接受流量和分流的作用了，当请求到nginx服务器时，nginx就可以根据设置好的负载信息，把请求分配到不同的服务器，服务器处理完毕后，nginx获取处理结果返回给客户端，这样，用nginx的反向代理，即可实现了负载均衡。</p><p><img src="https://www.itcodemonkey.com/data/upload/portal/20181114/1542195549241458.jpg" srcset="/img/loading.gif" alt="img"></p><p>nginx实现负载均衡有几种模式：</p><blockquote><ol><li>轮询：每个请求按时间顺序逐一分配到不同的后端服务器，也是nginx的默认模式。轮询模式的配置很简单，只需要把服务器列表加入到upstream模块中即可。</li></ol></blockquote><p>下面的配置是指：<strong>负载中有三台服务器，当请求到达时，nginx按照时间顺序把请求分配给三台服务器处理。</strong></p><pre><code class="hljs undefined">upstream serverList &#123;   <span class="hljs-built_in"> server </span>1.2.3.4;   <span class="hljs-built_in"> server </span>1.2.3.5;   <span class="hljs-built_in"> server </span>1.2.3.6;&#125;</code></pre><blockquote><ol><li>ip_hash：每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</li></ol></blockquote><p>下面的配置是指：<strong>负载中有三台服务器，当请求到达时，nginx优先按照ip_hash的结果进行分配，也就是同一个IP的请求固定在某一台服务器上，其它则按时间顺序把请求分配给三台服务器处理。</strong></p><pre><code class="hljs undefined">upstream serverList &#123;    ip_hash   <span class="hljs-built_in"> server </span>1.2.3.4;   <span class="hljs-built_in"> server </span>1.2.3.5;   <span class="hljs-built_in"> server </span>1.2.3.6;&#125;</code></pre><blockquote><ol><li>url_hash：按访问url的hash结果来分配请求，相同的url固定转发到同一个后端服务器处理。</li></ol></blockquote><pre><code class="hljs undefined">upstream serverList &#123;   <span class="hljs-built_in"> server </span>1.2.3.4;   <span class="hljs-built_in"> server </span>1.2.3.5;   <span class="hljs-built_in"> server </span>1.2.3.6;    hash <span class="hljs-variable">$request_uri</span>;    hash_method crc32;&#125;</code></pre><blockquote><ol><li>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</li></ol></blockquote><pre><code class="hljs undefined">upstream serverList &#123;   <span class="hljs-built_in"> server </span>1.2.3.4;   <span class="hljs-built_in"> server </span>1.2.3.5;   <span class="hljs-built_in"> server </span>1.2.3.6;    fair;&#125;</code></pre><p>而在每一种模式中，每一台服务器后面的可以携带的参数有：</p><blockquote><ol><li>down: 当前服务器暂不参与负载</li><li>weight: 权重，值越大，服务器的负载量越大。</li><li>max_fails：允许请求失败的次数，默认为1。</li><li>fail_timeout:max_fails次失败后暂停的时间。</li><li>backup：备份机， 只有其它所有的非backup机器down或者忙时才会请求backup机器。</li></ol></blockquote><p>如下面的配置是指：<strong>负载中有三台服务器，当请求到达时，nginx按时间顺序和权重把请求分配给三台服务器处理，例如有100个请求，有30%是服务器4处理，有50%的请求是服务器5处理，有20%的请求是服务器6处理。</strong></p><pre><code class="hljs undefined">upstream serverList &#123;   <span class="hljs-built_in"> server </span>1.2.3.4 <span class="hljs-attribute">weight</span>=30;   <span class="hljs-built_in"> server </span>1.2.3.5 <span class="hljs-attribute">weight</span>=50;   <span class="hljs-built_in"> server </span>1.2.3.6 <span class="hljs-attribute">weight</span>=20;&#125;</code></pre><p>如下面的配置是指：<strong>负载中有三台服务器，服务器4的失败超时时间为60s，服务器5暂不参与负载，服务器6只用作备份机。</strong></p><pre><code class="hljs undefined">upstream serverList &#123;   <span class="hljs-built_in"> server </span>1.2.3.4 <span class="hljs-attribute">fail_timeout</span>=60s;   <span class="hljs-built_in"> server </span>1.2.3.5 down;   <span class="hljs-built_in"> server </span>1.2.3.6 backup;&#125;</code></pre><blockquote><p>下面是一个配置负载均衡的示例（只写了关键配置）：<br>其中：</p><ol><li>upstream：是负载的配置模块，serverList是名称，随便起</li><li>server_name：是客户端请求的域名地址</li><li>proxy_pass：是指向负载的列表的模块，如serverList</li></ol></blockquote><pre><code class="hljs undefined"><span class="hljs-attribute">upstream</span> serverList &#123;    <span class="hljs-attribute">server</span> <span class="hljs-number">1.2.3.4</span> weight=<span class="hljs-number">30</span>;    <span class="hljs-attribute">server</span> <span class="hljs-number">1.2.3.5</span> down;    <span class="hljs-attribute">server</span> <span class="hljs-number">1.2.3.6</span> backup;&#125;   <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  www.xxx.com;    <span class="hljs-attribute">root</span>   html;    <span class="hljs-attribute">index</span>  index.html index.htm index.php;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">proxy_pass</span>  http://serverList;        <span class="hljs-attribute">proxy_redirect</span>     <span class="hljs-literal">off</span>;        <span class="hljs-attribute">proxy_set_header</span>   Host             <span class="hljs-variable">$host</span>;   &#125;&#125;</code></pre><h3 id="5-静态服务器"><a href="#5-静态服务器" class="headerlink" title="5. 静态服务器"></a>5. 静态服务器</h3><p>现在很多项目流行前后分离，也就是前端服务器和后端服务器分离，分别部署，这样的方式能让前后端人员能各司其职，不需要互相依赖，而前后分离中，前端项目的运行是不需要用Tomcat、Apache等服务器环境的，因此可以直接用nginx来作为静态服务器。</p><blockquote><p>静态服务器的配置如下,其中关键配置为：</p><ol><li>root：直接静态项目的绝对路径的根目录。</li><li>server_name : 静态网站访问的域名地址。</li></ol></blockquote><pre><code class="hljs undefined"><span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;                                                                 <span class="hljs-attribute">server_name</span>  www.xxx.com;                                                       <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">1024M</span>;        <span class="hljs-attribute">location</span> / &#123;               <span class="hljs-attribute">root</span>   /var/www/xxx_static;               <span class="hljs-attribute">index</span>  index.html;           &#125;    &#125;</code></pre><h3 id="6-nginx的安装"><a href="#6-nginx的安装" class="headerlink" title="6. nginx的安装"></a>6. nginx的安装</h3><p>学了这么多nginx的配置用法之后，我们需要对每一个知识点做一下测试，才能印象深刻，在此之前，我们需要知道nginx是怎么安装，下面以Linux环境为例，简述yum方式安装nginx的步骤：</p><ol><li>安装依赖：</li></ol><pre><code class="hljs undefined">//一键安装上面四个依赖yum -y install gcc <span class="hljs-literal">zlib</span> <span class="hljs-literal">zlib</span>-devel pcre-devel openssl openssl-devel</code></pre><ol><li>安装nginx：</li></ol><pre><code class="hljs undefined">yum <span class="hljs-keyword">install</span> nginx</code></pre><ol><li>检查是否安装成功：</li></ol><pre><code class="hljs undefined"><span class="hljs-attribute">nginx -v</span></code></pre><ol><li>启动/挺尸nginx：</li></ol><pre><code class="hljs undefined">/etc/init.d/nginx <span class="hljs-literal">start</span>/etc/init.d/nginx <span class="hljs-literal">stop</span></code></pre><ol><li>编辑配置文件：</li></ol><pre><code class="hljs undefined"><span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf</span></code></pre><p>这些步骤都完成之后，我们就可以进入nginx的配置文件nginx.conf对上面的各个知识点，进行配置和测试了。</p><blockquote><p>来自：<a href="https://mp.weixin.qq.com/s/DDbLVj0jxpfOmJDZxt9SYg" target="_blank" rel="noopener">编程无界</a>（微信号：qianshic），作者：假不理</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合SpringSecurity简单实现登入登出从零搭建</title>
    <link href="/2018/11/12/0007-spring-boot-integrate-security/"/>
    <url>/2018/11/12/0007-spring-boot-integrate-security/</url>
    
    <content type="html"><![CDATA[<p>1 . 新建一个spring-security-login的maven项目 ，pom.xml添加基本依赖 :</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.wuxicloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-login<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>EalenXie<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>SpringBoot整合SpringSecurity实现简单登入登出<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--alibaba--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>2 . 准备你的数据库，设计表结构，要用户使用登入登出，新建用户表。</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`user`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span>  (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`user_uuid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">70</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`email`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`telephone`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`role`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`image`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`last_ip`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`last_time`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT = <span class="hljs-number">2</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number">1</span>;</code></pre><p>3 . 用户对象User.java :</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.persistence.*;<span class="hljs-comment">/** * Created by EalenXie on 2018/7/5 15:17 */</span><span class="hljs-meta">@Entity</span><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"USER"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String user_uuid;   <span class="hljs-comment">//用户UUID</span>    <span class="hljs-keyword">private</span> String username;    <span class="hljs-comment">//用户名</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">//用户密码</span>    <span class="hljs-keyword">private</span> String email;       <span class="hljs-comment">//用户邮箱</span>    <span class="hljs-keyword">private</span> String telephone;   <span class="hljs-comment">//电话号码</span>    <span class="hljs-keyword">private</span> String role;        <span class="hljs-comment">//用户角色</span>    <span class="hljs-keyword">private</span> String image;       <span class="hljs-comment">//用户头像</span>    <span class="hljs-keyword">private</span> String last_ip;     <span class="hljs-comment">//上次登录IP</span>    <span class="hljs-keyword">private</span> String last_time;   <span class="hljs-comment">//上次登录时间</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRole</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> role;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRole</span><span class="hljs-params">(String role)</span> </span>&#123;        <span class="hljs-keyword">this</span>.role = role;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getImage</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> image;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImage</span><span class="hljs-params">(String image)</span> </span>&#123;        <span class="hljs-keyword">this</span>.image = image;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> email;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(String email)</span> </span>&#123;        <span class="hljs-keyword">this</span>.email = email;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTelephone</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> telephone;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTelephone</span><span class="hljs-params">(String telephone)</span> </span>&#123;        <span class="hljs-keyword">this</span>.telephone = telephone;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUser_uuid</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> user_uuid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser_uuid</span><span class="hljs-params">(String user_uuid)</span> </span>&#123;        <span class="hljs-keyword">this</span>.user_uuid = user_uuid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLast_ip</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> last_ip;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast_ip</span><span class="hljs-params">(String last_ip)</span> </span>&#123;        <span class="hljs-keyword">this</span>.last_ip = last_ip;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLast_time</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> last_time;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLast_time</span><span class="hljs-params">(String last_time)</span> </span>&#123;        <span class="hljs-keyword">this</span>.last_time = last_time;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +                <span class="hljs-string">"id="</span> + id +                <span class="hljs-string">", user_uuid='"</span> + user_uuid + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", username='"</span> + username + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", password='"</span> + password + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", email='"</span> + email + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", telephone='"</span> + telephone + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", role='"</span> + role + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", image='"</span> + image + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", last_ip='"</span> + last_ip + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", last_time='"</span> + last_time + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre><p>4 . application.yml配置一些基本属性</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">resources:</span>    <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/</span>  <span class="hljs-attr">freemarker:</span>    <span class="hljs-attr">template-loader-path:</span> <span class="hljs-string">classpath:/templates/</span>    <span class="hljs-attr">suffix:</span> <span class="hljs-string">.html</span>    <span class="hljs-attr">content-type:</span> <span class="hljs-string">text/html</span>    <span class="hljs-attr">charset:</span> <span class="hljs-string">UTF-8</span>  <span class="hljs-attr">datasource:</span>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/yourdatabase</span>      <span class="hljs-attr">username:</span> <span class="hljs-string">yourname</span>      <span class="hljs-attr">password:</span> <span class="hljs-string">yourpass</span>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span>  <span class="hljs-attr">error:</span>    <span class="hljs-attr">whitelabel:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span></code></pre><p>5 . 考虑我们应用的效率 , 可以配置数据源和线程池 :</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud.config;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<span class="hljs-keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;<span class="hljs-keyword">import</span> com.alibaba.druid.support.http.WebStatFilter;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;<span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.core.env.*;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DB_PREFIX = <span class="hljs-string">"spring.datasource."</span>;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Environment environment;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = DB_PREFIX)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;        Properties dbProperties = <span class="hljs-keyword">new</span> Properties();        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : ((AbstractEnvironment) environment).getPropertySources()) &#123;            getPropertiesFromSource(propertySource, map);        &#125;        dbProperties.putAll(map);        DruidDataSource dds;        <span class="hljs-keyword">try</span> &#123;            dds = (DruidDataSource) DruidDataSourceFactory.createDataSource(dbProperties);            dds.init();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"load datasource error, dbProperties is :"</span> + dbProperties, e);        &#125;        <span class="hljs-keyword">return</span> dds;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getPropertiesFromSource</span><span class="hljs-params">(PropertySource&lt;?&gt; propertySource, Map&lt;String, Object&gt; map)</span> </span>&#123;        <span class="hljs-keyword">if</span> (propertySource <span class="hljs-keyword">instanceof</span> MapPropertySource) &#123;            <span class="hljs-keyword">for</span> (String key : ((MapPropertySource) propertySource).getPropertyNames()) &#123;                <span class="hljs-keyword">if</span> (key.startsWith(DB_PREFIX))                    map.put(key.replaceFirst(DB_PREFIX, <span class="hljs-string">""</span>), propertySource.getProperty(key));                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.startsWith(DB_PREFIX))                    map.put(key.replaceFirst(DB_PREFIX, <span class="hljs-string">""</span>), propertySource.getProperty(key));            &#125;        &#125;        <span class="hljs-keyword">if</span> (propertySource <span class="hljs-keyword">instanceof</span> CompositePropertySource) &#123;            <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; s : ((CompositePropertySource) propertySource).getPropertySources()) &#123;                getPropertiesFromSource(s, map);            &#125;        &#125;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">druidServlet</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(), <span class="hljs-string">"/druid/*"</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean filterRegistrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean();        filterRegistrationBean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">"/*"</span>);        filterRegistrationBean.addInitParameter(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"</span>);        <span class="hljs-keyword">return</span> filterRegistrationBean;    &#125;&#125;</code></pre><p>配置线程池 :</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;<span class="hljs-keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;<span class="hljs-keyword">import</span> java.util.concurrent.Executor;<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAsync</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getExecutor</span><span class="hljs-params">()</span> </span>&#123;        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();        executor.setCorePoolSize(<span class="hljs-number">5</span>);<span class="hljs-comment">//线程池维护线程的最少数量</span>        executor.setMaxPoolSize(<span class="hljs-number">30</span>);<span class="hljs-comment">//线程池维护线程的最大数量</span>        executor.setQueueCapacity(<span class="hljs-number">8</span>); <span class="hljs-comment">//缓存队列</span>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()); <span class="hljs-comment">//对拒绝task的处理策略</span>        executor.setKeepAliveSeconds(<span class="hljs-number">60</span>);<span class="hljs-comment">//允许的空闲时间</span>        executor.initialize();        <span class="hljs-keyword">return</span> executor;    &#125;&#125;</code></pre><p>6.用户需要根据用户名进行登录，访问数据库 :</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.wuxicloud.model.User;<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="hljs-comment">/** * Created by EalenXie on 2018/7/11 14:23 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>, <span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function">User <span class="hljs-title">findByUsername</span><span class="hljs-params">(String username)</span></span>;&#125;</code></pre><p>7.构建真正用于SpringSecurity登录的安全用户(UserDetails)，我这里使用新建了一个POJO来实现 :</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud.security;<span class="hljs-keyword">import</span> com.wuxicloud.model.User;<span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SecurityUser</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.setUser_uuid(user.getUser_uuid());            <span class="hljs-keyword">this</span>.setUsername(user.getUsername());            <span class="hljs-keyword">this</span>.setPassword(user.getPassword());            <span class="hljs-keyword">this</span>.setEmail(user.getEmail());            <span class="hljs-keyword">this</span>.setTelephone(user.getTelephone());            <span class="hljs-keyword">this</span>.setRole(user.getRole());            <span class="hljs-keyword">this</span>.setImage(user.getImage());            <span class="hljs-keyword">this</span>.setLast_ip(user.getLast_ip());            <span class="hljs-keyword">this</span>.setLast_time(user.getLast_time());        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        Collection&lt;GrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        String username = <span class="hljs-keyword">this</span>.getUsername();        <span class="hljs-keyword">if</span> (username != <span class="hljs-keyword">null</span>) &#123;            SimpleGrantedAuthority authority = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(username);            authorities.add(authority);        &#125;        <span class="hljs-keyword">return</span> authorities;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>8 . 核心配置，配置SpringSecurity访问策略，包括登录处理，登出处理，资源访问，密码基本加密。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud.config;<span class="hljs-keyword">import</span> com.wuxicloud.dao.UserRepository;<span class="hljs-keyword">import</span> com.wuxicloud.model.User;<span class="hljs-keyword">import</span> com.wuxicloud.security.SecurityUser;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;<span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.logout.LogoutSuccessHandler;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">/** * Created by EalenXie on 2018/1/11. */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableWebSecurity</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(WebSecurityConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">//配置策略</span>        http.csrf().disable();        http.authorizeRequests().                antMatchers(<span class="hljs-string">"/static/**"</span>).permitAll().anyRequest().authenticated().                and().formLogin().loginPage(<span class="hljs-string">"/login"</span>).permitAll().successHandler(loginSuccessHandler()).                and().logout().permitAll().invalidateHttpSession(<span class="hljs-keyword">true</span>).                deleteCookies(<span class="hljs-string">"JSESSIONID"</span>).logoutSuccessHandler(logoutSuccessHandler()).                and().sessionManagement().maximumSessions(<span class="hljs-number">10</span>).expiredUrl(<span class="hljs-string">"/login"</span>);    &#125;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureGlobal</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        auth.userDetailsService(userDetailsService()).passwordEncoder(passwordEncoder());        auth.eraseCredentials(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> BCryptPasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//密码加密</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">4</span>);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LogoutSuccessHandler <span class="hljs-title">logoutSuccessHandler</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//登出处理</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    SecurityUser user = (SecurityUser) authentication.getPrincipal();                    logger.info(<span class="hljs-string">"USER : "</span> + user.getUsername() + <span class="hljs-string">" LOGOUT SUCCESS !  "</span>);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    logger.info(<span class="hljs-string">"LOGOUT EXCEPTION , e : "</span> + e.getMessage());                &#125;                httpServletResponse.sendRedirect(<span class="hljs-string">"/login"</span>);            &#125;        &#125;;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SavedRequestAwareAuthenticationSuccessHandler <span class="hljs-title">loginSuccessHandler</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//登入处理</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SavedRequestAwareAuthenticationSuccessHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;                User userDetails = (User) authentication.getPrincipal();                logger.info(<span class="hljs-string">"USER : "</span> + userDetails.getUsername() + <span class="hljs-string">" LOGIN SUCCESS !  "</span>);                <span class="hljs-keyword">super</span>.onAuthenticationSuccess(request, response, authentication);            &#125;        &#125;;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//用户登录实现</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDetailsService() &#123;            <span class="hljs-meta">@Autowired</span>            <span class="hljs-keyword">private</span> UserRepository userRepository;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;                User user = userRepository.findByUsername(s);                <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"Username "</span> + s + <span class="hljs-string">" not found"</span>);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SecurityUser(user);            &#125;        &#125;;    &#125;&#125;</code></pre><p>9.至此，已经基本将配置搭建好了，从上面核心可以看出，配置的登录页的url 为/login，可以创建基本的Controller来验证登录了。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud.web;<span class="hljs-keyword">import</span> com.wuxicloud.model.User;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContext;<span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-comment">/** * Created by EalenXie on 2018/1/11. */</span><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/login"</span>, method = RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;    &#125;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">root</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//为了session从获取用户信息,可以配置如下</span>        User user = <span class="hljs-keyword">new</span> User();        SecurityContext ctx = SecurityContextHolder.getContext();        Authentication auth = ctx.getAuthentication();        <span class="hljs-keyword">if</span> (auth.getPrincipal() <span class="hljs-keyword">instanceof</span> UserDetails) user = (User) auth.getPrincipal();        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpServletRequest <span class="hljs-title">getRequest</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();    &#125;&#125;</code></pre><p>11 . SpringBoot基本的启动类 Application.class</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-comment">/** * Created by EalenXie on 2018/7/11 15:01 */</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>11.根据Freemark和Controller里面可看出配置的视图为 /templates/index.html和/templates/index.login。所以创建基本的登录页面和登录成功页面。</p><p>login.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>用户登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    用户名 : <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>/&gt;</span>    密码 : <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>注意 : 这里方法必须是POST，因为GET在controller被重写了，用户名的name属性必须是username，密码的name属性必须是password</p><p>index.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">#assign</span>  <span class="hljs-attr">user</span>=<span class="hljs-string">Session.SPRING_SECURITY_CONTEXT.authentication.principal/</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>欢迎你,$&#123;user.username&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/logout"</span>&gt;</span>注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>注意 : 为了从session中获取到登录的用户信息，根据配置SpringSecurity的用户信息会放在Session.SPRING_SECURITY_CONTEXT.authentication.principal里面，根据FreeMarker模板引擎的特点，可以通过这种方式进行获取 : &lt;#assign user=Session.SPRING_SECURITY_CONTEXT.authentication.principal/&gt;</p><p>12 . 为了方便测试，我们在数据库中插入一条记录，注意，从WebSecurity.java配置可以知道密码会被加密，所以我们插入的用户密码应该是被加密的。</p><p>这里假如我们使用的密码为admin，则加密过后的字符串是 $2a$04$1OiUa3yEchBXQBJI8JaMyuKZNlwzWvfeQjKAHnwAEQwnacjt6ukqu</p><p>　测试类如下 :</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wuxicloud.security;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<span class="hljs-comment">/** * Created by EalenXie on 2018/7/11 15:13 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestEncoder</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encoder</span><span class="hljs-params">()</span> </span>&#123;        String password = <span class="hljs-string">"admin"</span>;        BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">4</span>);        String enPassword = encoder.encode(password);        System.out.println(enPassword);    &#125;&#125;</code></pre><p>测试登录，从上面的加密的密码我们插入一条数据到数据库中。</p><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`USER`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'d242ae49-4734-411e-8c8d-d2b09e87c3c8'</span>, <span class="hljs-string">'EalenXie'</span>, <span class="hljs-string">'$2a$04$petEXpgcLKfdLN4TYFxK0u8ryAzmZDHLASWLX/XXm8hgQar1C892W'</span>, <span class="hljs-string">'SSSSS'</span>, <span class="hljs-string">'ssssssssss'</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'g'</span>, <span class="hljs-string">'0:0:0:0:0:0:0:1'</span>, <span class="hljs-string">'2018-07-11 11:26:27'</span>);</code></pre><p>13 . 启动项目进行测试 ，访问 localhost:8083</p><p><img src="https://images2018.cnblogs.com/blog/994599/201807/994599-20180711154124007-1732228495.png" srcset="/img/loading.gif" alt="img"></p><p>点击登录，登录失败会留在当前页面重新登录，成功则进入index.html</p><p>登录如果成功，可以看到后台打印登录成功的日志 :</p><p><img src="https://images2018.cnblogs.com/blog/994599/201807/994599-20180711154258208-1381186085.png" srcset="/img/loading.gif" alt="img"></p><p>页面进入index.html :</p><p><img src="https://images2018.cnblogs.com/blog/994599/201807/994599-20180711154337891-1871092340.png" srcset="/img/loading.gif" alt="img"></p><p>点击注销 ，则回重新跳转到login.html，后台也会打印登出成功的日志 :</p><p><img src="https://images2018.cnblogs.com/blog/994599/201807/994599-20180711154539312-15547252.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>技术栈 : SpringBoot + SpringSecurity + jpa + freemark ，完整项目地址 : <a href="https://github.com/EalenXie/spring-security-login" target="_blank" rel="noopener">https://github.com/EalenXie/spring-security-login</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea下maven package时，javadoc乱码</title>
    <link href="/2018/10/30/0006-idea-maven-javadoc-charset/"/>
    <url>/2018/10/30/0006-idea-maven-javadoc-charset/</url>
    
    <content type="html"><![CDATA[<p>在idea中，使用maven打包应用的，javadoc在console输出乱码。解决方法如下：</p><ol><li>设置环境变量JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8</li><li>在idea64.exe.vmoptions中设置-Dfile.encoding=UTF-8</li></ol><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Security自定义Provider如何获取更多用户信息</title>
    <link href="/2018/10/30/0005-obtain-principal-with-custom-provider/"/>
    <url>/2018/10/30/0005-obtain-principal-with-custom-provider/</url>
    
    <content type="html"><![CDATA[<p>在使用Spring Security集成Oauth2.0做Auth server时，使用自定义的UserDetailsService实现时，在Controller层通过自动注入，可以获取详细的用户信息。</p><a id="more"></a><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Principal <span class="hljs-title">user</span><span class="hljs-params">(Principal user)</span> </span>&#123;  <span class="hljs-keyword">return</span> user;&#125;</code></pre><p>但是，使用自定义的Provider去做账户校验时，获取的Principal就只含有用户名信息。</p><p>分析原码发现</p><pre><code class="hljs java"><span class="hljs-comment">// org.springframework.security.oauth2.provider.token.DefaultUserAuthenticationConverter</span><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">extractAuthentication</span><span class="hljs-params">(Map&lt;String, ?&gt; map)</span> </span>&#123;  <span class="hljs-keyword">if</span> (map.containsKey(USERNAME)) &#123;    Object principal = map.get(USERNAME);    Collection&lt;? extends GrantedAuthority&gt; authorities = getAuthorities(map);    <span class="hljs-keyword">if</span> (userDetailsService != <span class="hljs-keyword">null</span>) &#123;      UserDetails user = userDetailsService.loadUserByUsername((String) map.get(USERNAME));      authorities = user.getAuthorities();      principal = user;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(principal, <span class="hljs-string">"N/A"</span>, authorities);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>通过jwt方式进行认证的会执行<code>DefaultUserAuthenticationConverter</code>代码，其中的userDetailsService是null，所以返回的principal就只有用户名。</p><p>可以通过在创建<code>DefaultUserAuthenticationConverter</code>时，给他set上userDetailsService，这样就获取更多的信息了。</p><p>如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;    JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();    jwtAccessTokenConverter.setSigningKey(<span class="hljs-string">"demo"</span>);    <span class="hljs-keyword">final</span> AccessTokenConverter accessTokenConverter = jwtAccessTokenConverter.getAccessTokenConverter();    <span class="hljs-keyword">if</span> (accessTokenConverter <span class="hljs-keyword">instanceof</span> DefaultAccessTokenConverter) &#123;        ((DefaultAccessTokenConverter) accessTokenConverter).setUserTokenConverter(userAuthenticationConverter());    &#125;    <span class="hljs-keyword">return</span> jwtAccessTokenConverter;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserAuthenticationConverter <span class="hljs-title">userAuthenticationConverter</span><span class="hljs-params">()</span> </span>&#123;    DefaultUserAuthenticationConverter defaultUserAuthenticationConverter = <span class="hljs-keyword">new</span> DefaultUserAuthenticationConverter();    defaultUserAuthenticationConverter.setUserDetailsService(userDetailsService);    <span class="hljs-keyword">return</span> defaultUserAuthenticationConverter;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Guide To OAuth 2.0 Grants</title>
    <link href="/2018/10/26/0004-a-guide-to-oauth2-grants/"/>
    <url>/2018/10/26/0004-a-guide-to-oauth2-grants/</url>
    
    <content type="html"><![CDATA[<p>The <a href="http://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0 specification</a> is a flexibile authorization framework that describes a number of grants (“methods”) for a client application to acquire an access token (which represents a user’s permission for the client to access their data) which can be used to authenticate a request to an API endpoint.</p><a id="more"></a><p>The specification describes five grants for acquiring an access token:</p><ul><li>Authorization code grant</li><li>Implicit grant</li><li>Resource owner credentials grant</li><li>Client credentials grant</li><li>Refresh token grant</li></ul><p>In this post I’m going to describe each of the above grants and their appropriate use cases.</p><p>As a refresher here is a quick glossary of OAuth terms (taken from the core spec):</p><ul><li><strong>Resource owner (a.k.a. the User)</strong> - An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user.</li><li><strong>Resource server (a.k.a. the API server)</strong> - The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.</li><li><strong>Client</strong> - An application making protected resource requests on behalf of the resource owner and with its authorization. The term client does not imply any particular implementation characteristics (e.g. whether the application executes on a server, a desktop, or other devices).</li><li><strong>Authorization server</strong> - The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.</li></ul><h2 id="Authorisation-Code-Grant-section-4-1"><a href="#Authorisation-Code-Grant-section-4-1" class="headerlink" title="Authorisation Code Grant (section 4.1)"></a>Authorisation Code Grant (<a href="http://tools.ietf.org/html/rfc6749#section-4.1" target="_blank" rel="noopener">section 4.1</a>)</h2><p>The authorization code grant should be very familiar if you’ve ever signed into an application using your Facebook or Google account.</p><h3 id="The-Flow-Part-One"><a href="#The-Flow-Part-One" class="headerlink" title="The Flow (Part One)"></a>The Flow (Part One)</h3><p>The client will redirect the user to the authorization server with the following parameters in the query string:</p><ul><li><code>response_type</code> with the value <code>code</code></li><li><code>client_id</code> with the client identifier</li><li><code>redirect_uri</code> with the client redirect URI. This parameter is optional, but if not send the user will be redirected to a pre-registered redirect URI.</li><li><code>scope</code> a space delimited list of scopes</li><li><code>state</code> with a <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">CSRF</a> token. This parameter is optional but highly recommended. You should store the value of the CSRF token in the user’s session to be validated when they return.</li></ul><p>All of these parameters will be validated by the authorization server.</p><p>The user will then be asked to login to the authorization server and approve the client.</p><p>If the user approves the client they will be redirected from the authorisation server back to the client (specifically to the redirect URI) with the following parameters in the query string:</p><ul><li><code>code</code> with the authorization code</li><li><code>state</code> with the state parameter sent in the original request. You should compare this value with the value stored in the user’s session to ensure the authorization code obtained is in response to requests made by this client rather than another client application.</li></ul><h3 id="The-Flow-Part-Two"><a href="#The-Flow-Part-Two" class="headerlink" title="The Flow (Part Two)"></a>The Flow (Part Two)</h3><p>The client will now send a POST request to the authorization server with the following parameters:</p><ul><li><code>grant_type</code> with the value of <code>authorization_code</code></li><li><code>client_id</code> with the client identifier</li><li><code>client_secret</code> with the client secret</li><li><code>redirect_uri</code> with the same redirect URI the user was redirect back to</li><li><code>code</code> with the authorization code from the query string</li></ul><p>The authorization server will respond with a JSON object containing the following properties:</p><ul><li><code>token_type</code> this will usually be the word “Bearer” (to indicate a bearer token)</li><li><code>expires_in</code> with an integer representing the TTL of the access token (i.e. when the token will expire)</li><li><code>access_token</code> the access token itself</li><li><code>refresh_token</code> a refresh token that can be used to acquire a new access token when the original expires</li></ul><h2 id="Implicit-grant-section-4-2"><a href="#Implicit-grant-section-4-2" class="headerlink" title="Implicit grant (section 4.2)"></a>Implicit grant (<a href="http://tools.ietf.org/html/rfc6749#section-4.2" target="_blank" rel="noopener">section 4.2</a>)</h2><p>The implicit grant is similar to the authorization code grant with two distinct differences.</p><p>It is intended to be used for user-agent-based clients (e.g. single page web apps) that can’t keep a client secret because all of the application code and storage is easily accessible.</p><p>Secondly instead of the authorization server returning an authorization code which is exchanged for an access token, the authorization server returns an access token.</p><h3 id="The-Flow"><a href="#The-Flow" class="headerlink" title="The Flow"></a>The Flow</h3><p>The client will redirect the user to the authorization server with the following parameters in the query string:</p><ul><li><code>response_type</code> with the value <code>token</code></li><li><code>client_id</code> with the client identifier</li><li><code>redirect_uri</code> with the client redirect URI. This parameter is optional, but if not sent the user will be redirected to a pre-registered redirect URI.</li><li><code>scope</code> a space delimited list of scopes</li><li><code>state</code> with a <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">CSRF</a> token. This parameter is optional but highly recommended. You should store the value of the CSRF token in the user’s session to be validated when they return.</li></ul><p>All of these parameters will be validated by the authorization server.</p><p>The user will then be asked to login to the authorization server and approve the client.</p><p>If the user approves the client they will be redirected back to the authorization server with the following parameters in the query string:</p><ul><li><code>token_type</code> with the value <code>Bearer</code></li><li><code>expires_in</code> with an integer representing the TTL of the access token</li><li><code>access_token</code> the access token itself</li><li><code>state</code> with the state parameter sent in the original request. You should compare this value with the value stored in the user’s session to ensure the authorization code obtained is in response to requests made by this client rather than another client application.</li></ul><p><strong>Note:</strong> this grant does not return a refresh token because the browser has no means of keeping it private</p><h2 id="Resource-owner-credentials-grant-section-4-3"><a href="#Resource-owner-credentials-grant-section-4-3" class="headerlink" title="Resource owner credentials grant (section 4.3)"></a>Resource owner credentials grant (<a href="http://tools.ietf.org/html/rfc6749#section-4.3" target="_blank" rel="noopener">section 4.3</a>)</h2><p>This grant is a great user experience for trusted first party clients both on the web and in native device applications.</p><h3 id="The-Flow-1"><a href="#The-Flow-1" class="headerlink" title="The Flow"></a>The Flow</h3><p>The client will ask the user for their authorization credentials (ususally a username and password).</p><p>The client then sends a POST request with following body parameters to the authorization server:</p><ul><li><code>grant_type</code> with the value <code>password</code></li><li><code>client_id</code> with the the client’s ID</li><li><code>client_secret</code> with the client’s secret</li><li><code>scope</code> with a space-delimited list of requested scope permissions.</li><li><code>username</code> with the user’s username</li><li><code>password</code> with the user’s password</li></ul><p>The authorization server will respond with a JSON object containing the following properties:</p><ul><li><code>token_type</code> with the value <code>Bearer</code></li><li><code>expires_in</code> with an integer representing the TTL of the access token</li><li><code>access_token</code> the access token itself</li><li><code>refresh_token</code> a refresh token that can be used to acquire a new access token when the original expires</li></ul><h2 id="Client-credentials-grant-section-4-4"><a href="#Client-credentials-grant-section-4-4" class="headerlink" title="Client credentials grant (section 4.4)"></a>Client credentials grant (<a href="http://tools.ietf.org/html/rfc6749#section-4.4" target="_blank" rel="noopener">section 4.4</a>)</h2><p>The simplest of all of the OAuth 2.0 grants, this grant is suitable for machine-to-machine authentication where a specific user’s permission to access data is not required.</p><h3 id="The-Flow-2"><a href="#The-Flow-2" class="headerlink" title="The Flow"></a>The Flow</h3><p>The client sends a POST request with following body parameters to the authorization server:</p><ul><li><code>grant_type</code> with the value <code>client_credentials</code></li><li><code>client_id</code> with the the client’s ID</li><li><code>client_secret</code> with the client’s secret</li><li><code>scope</code> with a space-delimited list of requested scope permissions.</li></ul><p>The authorization server will respond with a JSON object containing the following properties:</p><ul><li><code>token_type</code> with the value <code>Bearer</code></li><li><code>expires_in</code> with an integer representing the TTL of the access token</li><li><code>access_token</code> the access token itself</li></ul><h2 id="Refresh-token-grant-section-1-5"><a href="#Refresh-token-grant-section-1-5" class="headerlink" title="Refresh token grant (section 1.5)"></a>Refresh token grant (<a href="http://tools.ietf.org/html/rfc6749#section-1.5" target="_blank" rel="noopener">section 1.5</a>)</h2><p>Access tokens eventually expire; however some grants respond with a refresh token which enables the client to get a new access token without requiring the user to be redirected.</p><h3 id="The-Flow-3"><a href="#The-Flow-3" class="headerlink" title="The Flow"></a>The Flow</h3><p>The client sends a POST request with following body parameters to the authorization server:</p><ul><li><code>grant_type</code> with the value <code>refresh_token</code></li><li><code>refresh_token</code> with the refresh token</li><li><code>client_id</code> with the the client’s ID</li><li><code>client_secret</code> with the client’s secret</li><li><code>scope</code> with a space-delimited list of requested scope permissions. This is optional; if not sent the original scopes will be used, otherwise you can request a reduced set of scopes.</li></ul><p>The authorization server will respond with a JSON object containing the following properties:</p><ul><li><code>token_type</code> with the value <code>Bearer</code></li><li><code>expires_in</code> with an integer representing the TTL of the access token</li><li><code>access_token</code> the access token itself</li><li><code>refresh_token</code> a refresh token that can be used to acquire a new access token when the original expires</li></ul><h2 id="Additonal-Grants"><a href="#Additonal-Grants" class="headerlink" title="Additonal Grants"></a>Additonal Grants</h2><p>There are additional grants that have been published in other specifications that I will cover in a future article.</p><h2 id="Which-OAuth-2-0-grant-should-I-use"><a href="#Which-OAuth-2-0-grant-should-I-use" class="headerlink" title="Which OAuth 2.0 grant should I use?"></a>Which OAuth 2.0 grant should I use?</h2><p>A grant is a method of acquiring an access token. Deciding which grants to implement depends on the type of client the end user will be using, and the experience you want for your users.</p><p><img src="http://alexbilbie.com/images/oauth-grants.svg" srcset="/img/loading.gif" alt="img"></p><h3 id="First-party-or-third-party-client"><a href="#First-party-or-third-party-client" class="headerlink" title="First party or third party client?"></a>First party or third party client?</h3><p>A first party client is a client that you trust enough to handle the end user’s authorization credentials. For example Spotify’s iPhone app is owned and developed by Spotify so therefore they implicitly trust it.</p><p>A third party client is a client that you don’t trust.</p><h3 id="Access-Token-Owner"><a href="#Access-Token-Owner" class="headerlink" title="Access Token Owner?"></a>Access Token Owner?</h3><p>An access token represents a permission granted to a client to access some protected resources.</p><p>If you are authorizing a machine to access resources and you don’t require the permission of a user to access said resources you should implement the client credentials grant.</p><p>If you require the permission of a user to access resources you need to determine the client type.</p><h3 id="Client-Type"><a href="#Client-Type" class="headerlink" title="Client Type?"></a>Client Type?</h3><p>Depending on whether or not the client is capable of keeping a secret will depend on which grant the client should use.</p><p>If the client is a web application that has a server side component then you should implement the authorization code grant.</p><p>If the client is a web application that has runs entirely on the front end (e.g. a single page web application) you should implement the password grant for a first party clients and the implicit grant for a third party clients.</p><p>If the client is a native application such as a mobile app you should implement the password grant.</p><p>Third party native applications should use the authorization code grant (via the native browser, not an embedded browser - e.g. for iOS push the user to Safari or use <a href="https://developer.apple.com/library/ios/documentation/SafariServices/Reference/SFSafariViewController_Ref/" target="_blank" rel="noopener">SFSafariViewController</a>, don’t use an embedded <a href="https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKWebView_Ref/" target="_blank" rel="noopener">WKWebView</a>).</p><hr><blockquote><p><a href="http://alexbilbie.com/guide-to-oauth-2-grants/" target="_blank" rel="noopener">alexbilbie.com</a> · by Alex Bilbie</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oauth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular中的自定义异步验证器</title>
    <link href="/2018/10/25/0003-custom-async-validators-in-angular/"/>
    <url>/2018/10/25/0003-custom-async-validators-in-angular/</url>
    
    <content type="html"><![CDATA[<p>在实际工作中，我们经常需要一个基于后端API验证值的验证器。为此，Angular提供了一种定义自定义异步验证器的简便方法。</p><p>本文将介绍如何为Angular应用程序创建自定义异步验证器。</p><a id="more"></a><p>通常你会调用一个真正的后端，但是在这里我们将创建一个虚拟的JSON文件，我们可以通过使用Http服务来调用它。如果正在使用Angular CLI，则可以将JSON文件放在/assets文件夹中，它将自动可用；</p><p><code>/assets/users.json</code></p><pre><code class="hljs json">[  &#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Paul"</span>, <span class="hljs-attr">"email"</span>: <span class="hljs-string">"paul@example.com"</span> &#125;,  &#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Ringo"</span>, <span class="hljs-attr">"email"</span>: <span class="hljs-string">"ringo@example.com"</span> &#125;,  &#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">"email"</span>: <span class="hljs-string">"john@example.com"</span> &#125;,  &#123; <span class="hljs-attr">"name"</span>: <span class="hljs-string">"George"</span>, <span class="hljs-attr">"email"</span>: <span class="hljs-string">"george@example.com"</span> &#125;]</code></pre><h1 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h1><p>接下来，让我们创建一个具有<code>checkEmailNotTaken</code>方法的服务，该方法触发对我们的JSON文件的http GET调用。这里我们使用<code>RxJS</code>的延迟运算符来模拟一些延迟：</p><p><code>signup.service.ts</code></p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; Http &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/http'</span>;<span class="hljs-keyword">import</span> &#123; Observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Observable'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/map'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/filter'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/delay'</span>;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SignupService &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> http: Http</span>) &#123;&#125;  checkEmailNotTaken(email: <span class="hljs-built_in">string</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http      .get(<span class="hljs-string">'assets/users.json'</span>)      .delay(<span class="hljs-number">1000</span>)      .map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())      .map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.email === email))      .map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> !users.length);  &#125;&#125;</code></pre><p>请注意我们如何筛选与提供给方法的用户具有相同电子邮件的用户。然后我们再次映射结果并进行测试以确保我们得到一个空置对象。</p><p>在真实场景中，您可能还想使用debounceTime和distinctUntilChanged运算符的组合，如我们在创建实时搜索的帖子中所讨论的。引入一些这样的去抖动将有助于将发送到后端API的请求数量保持在最低水平。</p><h2 id="组件和异步验证器"><a href="#组件和异步验证器" class="headerlink" title="组件和异步验证器"></a>组件和异步验证器</h2><p>我们的简单组件初始化我们的反应形式并定义我们的异步验证器：<em>validateEmailNotTaken</em>。请注意我们的<code>FormBuilder.group</code>声明中的表单控件如何将异步验证器作为第三个参数。这里我们只使用一个异步验证器，但是你想在数组中包含多个异步验证器：</p><p>app.component.ts</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123;  FormBuilder,  FormGroup,  Validators,  AbstractControl&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;<span class="hljs-keyword">import</span> &#123; SignupService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./signup.service'</span>;<span class="hljs-meta">@Component</span>(&#123; ... &#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent <span class="hljs-keyword">implements</span> OnInit &#123;  myForm: FormGroup;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">    <span class="hljs-keyword">private</span> fb: FormBuilder,    <span class="hljs-keyword">private</span> signupService: SignupService  </span>) &#123;&#125;  ngOnInit() &#123;    <span class="hljs-keyword">this</span>.myForm = <span class="hljs-keyword">this</span>.fb.group(&#123;      name: [<span class="hljs-string">''</span>, Validators.required],      email: [        <span class="hljs-string">''</span>,        [Validators.required, Validators.email],        <span class="hljs-keyword">this</span>.validateEmailNotTaken.bind(<span class="hljs-keyword">this</span>)      ]    &#125;);  &#125;  validateEmailNotTaken(control: AbstractControl) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.signupService.checkEmailNotTaken(control.value).map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> res ? <span class="hljs-literal">null</span> : &#123; emailTaken: <span class="hljs-literal">true</span> &#125;;    &#125;);  &#125;&#125;</code></pre><p>我们的验证器与典型的自定义验证器非常相似。这里我们直接在组件类中定义了验证器而不是单独的文件。这样可以更轻松地访问我们注入的服务实例。另请注意我们如何绑定<strong>此</strong>值以确保它指向组件类。</p><p>我们还可以在自己的文件中定义我们的异步验证器，以便更容易地重用和分离关注点。唯一棘手的部分是找到一种方法来提供我们的服务实例。在这里，例如，我们创建一个具有<em>createValidator</em>静态方法的类，该方法接收我们的服务实例并返回我们的验证器函数：</p><p>/validators/async-email.validator.ts</p><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> &#123; AbstractControl &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;<span class="hljs-keyword">import</span> &#123; SignupService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../signup.service'</span>;<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateEmailNotTaken</span> </span>&#123;  <span class="hljs-keyword">static</span> createValidator(signupService: SignupService) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">control: AbstractControl</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> signupService.checkEmailNotTaken(control.value).map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> res ? <span class="hljs-literal">null</span> : &#123; <span class="hljs-attr">emailTaken</span>: <span class="hljs-literal">true</span> &#125;;      &#125;);    &#125;;  &#125;&#125;</code></pre><p>然后，回到我们的组件中，我们导入<em>ValidateEmailNotTaken</em>类，我们可以使用这样的验证器：</p><pre><code class="hljs undefined">ngOnInit() &#123;  <span class="hljs-keyword">this</span>.myForm = <span class="hljs-keyword">this</span>.fb.group(&#123;    name: [<span class="hljs-string">''</span>, Validators.required],    email: [      <span class="hljs-string">''</span>,      [Validators.required, Validators.email],      ValidateEmailNotTaken.createValidator(<span class="hljs-keyword">this</span>.signupService)    ]  &#125;);&#125;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在模板中，事情真的很简单：</p><p>app.component.html</p><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"myForm"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"email"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"myForm.get('email').status === 'PENDING'"</span>&gt;</span>    Checking...  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"myForm.get('email').status === 'VALID'"</span>&gt;</span>    😺 Email is available!  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"myForm.get('email').errors &amp;&amp; myForm.get('email').errors.emailTaken"</span>&gt;</span>    😢 Oh noes, this email is already taken!  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><p>您可以看到我们根据<em>电子邮件</em>表单控件上status属性的值显示不同的消息。对于可能的值<strong>状态</strong>是<em>VALID</em>，<em>INVALID</em>，<em>PENDING</em>和<em>禁用</em>。如果异步验证错误输出我们的<em>emailTaken</em>错误，我们也会显示错误消息。</p><p>使用异步验证器验证的表单字段在验证<em>待处理</em>时也将具有<em>ng-pending</em>类。这样可以轻松设置当前待验证字段的样式。</p><p>✨你有它！使用后端API检查有效性的简便方法。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea手动设置Spring Boot项目使用Run Dashboard运行</title>
    <link href="/2018/10/17/0002-config-springboot-dashboard/"/>
    <url>/2018/10/17/0002-config-springboot-dashboard/</url>
    
    <content type="html"><![CDATA[<p>最近在做基于Spring cloud的微服务开发，开发过程中，要启动很多Spring Boot项目，Idea提供了<code>Run Dashboard</code>功能，来方便管理Spring Boot项目。</p><p><img src="http://ww1.sinaimg.cn/large/806e3151ly1fwazgrcb0yj20gc095t8t.jpg" srcset="/img/loading.gif" alt></p><a id="more"></a><p>通常Idea会自动提示是否要用<code>Run Dashboard</code>管理。</p><p>如果没有自动提示，可以手动打开<code>view &gt;&gt; Tool Windows &gt;&gt; Run Dashboard</code><br><img src="http://ww1.sinaimg.cn/large/806e3151ly1fwazjtuwvuj20f80gz0to.jpg" srcset="/img/loading.gif" alt></p><p>如果还没有找到<code>Run Dashboard</code>，就需要手动添加，打开workspace.xml，找到<code>&lt;component name=&quot;RunDashboard&quot;&gt;</code>，将其设置成如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"RunDashboard"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"configurationTypes"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SpringBootApplicationConfigurationType"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ruleStates"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RuleState</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ConfigurationTypeDashboardGroupingRule"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RuleState</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">RuleState</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"StatusDashboardGroupingRule"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">RuleState</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Idea</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Angular cli管理多种环境配置</title>
    <link href="/2018/10/16/0001-how-to-manage-different-environments-with-angular-cli/"/>
    <url>/2018/10/16/0001-how-to-manage-different-environments-with-angular-cli/</url>
    
    <content type="html"><![CDATA[<p>大多数的web应用在发布生产之前，需要在多种环境下去运行。例如，您可能需要为QA团队构建一个构建以执行某些测试，或者在您的持续集成服务器上运行特定构建。</p><p>这些构建需要不同的配置：</p><ul><li>不同的服务URLS</li><li>不同的logging选项</li><li>等等</li></ul><p>Angular CLI提供了一种环境功能，允许运行针对特定环境的构建。 例如，以下是如何运行生产构建：</p><pre><code class="hljs undefined">ng build --env=<span class="hljs-keyword">prod</span>   <span class="hljs-comment">// For Angular 2 to 5</span></code></pre><p>在升级到Angular 6+后，构建命令如下：</p><pre><code class="hljs undefined">ng build <span class="hljs-attribute">--configuration</span>=production</code></pre><p>上面代码中的prod标志是指v6之前的.angular-cli.json的环境部分的prod（v6+则是production）属性。<br>默认情况下有两个选项：dev和prod</p><pre><code class="hljs json">"environments": &#123;  "dev": "environments/environment.ts",  "prod": "environments/environment.prod.ts"&#125;</code></pre><p>您可以在此处添加所需的环境。 例如，如果您需要QA构建选项，只需在.angular-cli.json中添加以下条目：</p><pre><code class="hljs json">"environments": &#123;  "dev": "environments/environment.ts",  "prod": "environments/environment.prod.ts",  "qa": "environments/environment.qa.ts"&#125;</code></pre><p>对于v6 +，angular.json environments现在称为configurations。 以下是在v6之后添加新qa环境的方法：</p><pre><code class="hljs json">"configurations": &#123;  "production": &#123; ... &#125;,  "qa": &#123;    "fileReplacements": [      &#123;        "replace": "src/environments/environment.ts",        "with": "src/environments/environment.qa.ts"      &#125;    ]  &#125;&#125;</code></pre><p>然后，您必须在environments目录中创建实际文件environment.qa.ts。</p><p>下面是默认的dev配置：</p><pre><code class="hljs undefined">// The file contents for the current environment will overwrite these during <span class="hljs-keyword">build</span>.// The <span class="hljs-keyword">build</span> <span class="hljs-keyword">system</span> defaults <span class="hljs-keyword">to</span> the dev environment which uses <span class="hljs-symbol">`environment.ts`</span>, but <span class="hljs-keyword">if</span> you <span class="hljs-keyword">do</span>// <span class="hljs-symbol">`ng build --env=prod`</span> <span class="hljs-keyword">then</span> <span class="hljs-symbol">`environment.prod.ts`</span> will be used instead.// The list of which env maps <span class="hljs-keyword">to</span> which file can be found <span class="hljs-keyword">in</span> <span class="hljs-symbol">`.angular-cli.json`</span>.export const environment = &#123;  production: <span class="hljs-literal">false</span>&#125;;</code></pre><p>您可以在上面的environment对象中添加任何特定于环境的属性。 例如，让我们添加一个服务器URL：</p><pre><code class="hljs undefined"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> environment = &#123;  production: <span class="hljs-literal">false</span>,  serverUrl: <span class="hljs-string">"http://dev.server.mycompany.com"</span>&#125;;</code></pre><p>然后，您需要做的就是为QA提供不同的URL，即在environment.qa.ts中定义具有正确值的相同属性：</p><pre><code class="hljs undefined"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> environment = &#123;  production: <span class="hljs-literal">false</span>,  serverUrl: <span class="hljs-string">"http://qa.server.mycompany.com"</span>&#125;;</code></pre><p>既然已经定义了您的环境，那么如何在代码中使用这些属性？ 很简单，您只需要导入环境对象，如下所示：</p><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> &#123;environment&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'../../environments/environment'</span>;@Injectable()<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> &#123;</span>  <span class="hljs-name">LOGIN_URL</span>: <span class="hljs-built_in">string</span> = environment.serverUrl + <span class="hljs-string">'/login'</span> ;</code></pre><p>然后，当您运行QA构建时，Angular CLI将使用environment.qa.ts来读取environment.serverUrl属性值，并且您已设置为将该构建部署到QA环境。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建基于Electron技术的Angular桌面应用</title>
    <link href="/2018/10/15/build-angular-desktop-apps-with-electron/"/>
    <url>/2018/10/15/build-angular-desktop-apps-with-electron/</url>
    
    <content type="html"><![CDATA[<p>In this lesson, you will learn how to build native desktop apps with Angular and Electron. You might be surprised how easy it is to start building high-quality desktop apps for any platform, or even port your existing Angular app to native desktop platforms.<br>通过本文，你可以学到如何使用Angular和Electron构建桌面应用。</p><p>This lesson covers the following topics:</p><ol><li>Configure Electron 1.7 with Angular 4.x.</li><li>Build a simple timer app in Angular.</li><li>Package the app for install on Windows 10, macOS, and Linux Ubuntu.</li></ol><p>You can obtain the <a href="https://github.com/AngularFirebase/angular-electron" target="_blank" rel="noopener">source code</a> for this project on Github.</p><p><img src="https://angularfirebase.com/images/electron-angular-macos.gif" srcset="/img/loading.gif" alt></p><h1 id="Initial-Setup"><a href="#Initial-Setup" class="headerlink" title="Initial Setup"></a>Initial Setup</h1><p>Let’s kick things off by building a new angular app from scratch.</p><h1 id="Generate-the-Angular-App"><a href="#Generate-the-Angular-App" class="headerlink" title="Generate the Angular App"></a>Generate the Angular App</h1><p>Generate a default app with the Angular CLI.</p><pre><code class="hljs undefined"><span class="hljs-built_in">npm</span> install -g @angular/cling <span class="hljs-keyword">new</span> angular-electroncd angular-electron</code></pre><h1 id="Update-index-html"><a href="#Update-index-html" class="headerlink" title="Update index.html"></a>Update index.html</h1><p>The generated root page in Angular points the base href to <code>/</code> - this will cause problems with Electron later on, so let’s update it now. Just add a period in front of the slash in <code>src/index.html</code>.</p><pre><code class="hljs undefined">&lt;base <span class="hljs-attribute">href</span>=<span class="hljs-string">"./"</span>&gt;</code></pre><h1 id="Install-Electron"><a href="#Install-Electron" class="headerlink" title="Install Electron"></a>Install Electron</h1><p>You can install Electron in the Angular development environment.</p><pre><code class="hljs undefined">npm install electron --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre><h1 id="Configure-Electron"><a href="#Configure-Electron" class="headerlink" title="Configure Electron"></a>Configure Electron</h1><p>The next step is to configure Electron. There are all sorts of possibilities for customization and we’re just scratching the surface.</p><h1 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h1><p>Create a new file named main.js in the root of your project - this is the Electron NodeJS backend. This is the entry point for Electron and defines how our desktop app will react to various events performed via the desktop operating system.</p><p>The createWindow function defines the properties of the program window that the user will see. There are many more window options that faciliate additional customization, child windows, modals, etc.</p><p>Notice we are loading the window by pointing it to the index.html file in the dist/ folder. Do NOT confuse this with the index file in the src/ folder. At this point, this file does not exist, but it will be created automatically in the next step by running ng build –prod</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>)<span class="hljs-keyword">let</span> win;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span> (<span class="hljs-params"></span>) </span>&#123;  win = <span class="hljs-keyword">new</span> BrowserWindow(&#123;    width: <span class="hljs-number">600</span>,    height: <span class="hljs-number">600</span>,    backgroundColor: <span class="hljs-string">'#ffffff'</span>,    icon: <span class="hljs-string">`file://<span class="hljs-subst">$&#123;__dirname&#125;</span>/dist/assets/logo.png`</span>  &#125;)  win.loadURL(<span class="hljs-string">`file://<span class="hljs-subst">$&#123;__dirname&#125;</span>/dist/index.html`</span>)  win.on(<span class="hljs-string">'closed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    win = <span class="hljs-literal">null</span>  &#125;)&#125;app.on(<span class="hljs-string">'ready'</span>, createWindow)app.on(<span class="hljs-string">'window-all-closed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (process.platform !== <span class="hljs-string">'darwin'</span>) &#123;    app.quit()  &#125;&#125;)app.on(<span class="hljs-string">'activate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (win === <span class="hljs-literal">null</span>) &#123;    createWindow()  &#125;&#125;)</code></pre><p>That’s it for the Electron setup, all the desktop app magic is happens under the hood.</p><h1 id="Custom-Build-Command"><a href="#Custom-Build-Command" class="headerlink" title="Custom Build Command"></a>Custom Build Command</h1><p>The deployed desktop app will be an Angular AOT build - this happens by default when you run ng build –prod. It’s useful to have a command that will run an AOT production build and start Electron at the same time. This can be easily configured in the package.json file.</p><h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><pre><code class="hljs json">&#123;  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"angular-electron"</span>,  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.0"</span>,  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"MIT"</span>,  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"main.js"</span>,  <span class="hljs-attr">"scripts"</span>: &#123;    <span class="hljs-attr">"ng"</span>: <span class="hljs-string">"ng"</span>,    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"ng serve"</span>,    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"ng build"</span>,    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"ng test"</span>,    <span class="hljs-attr">"lint"</span>: <span class="hljs-string">"ng lint"</span>,    <span class="hljs-attr">"e2e"</span>: <span class="hljs-string">"ng e2e"</span>,    <span class="hljs-attr">"electron"</span>: <span class="hljs-string">"electron ."</span>,    <span class="hljs-attr">"electron-build"</span>: <span class="hljs-string">"ng build --prod &amp;&amp; electron ."</span>  &#125;,&#125;</code></pre><h1 id="Run-the-command"><a href="#Run-the-command" class="headerlink" title="Run the command"></a>Run the command</h1><p>You can run your angular app as an native desktop app with the following command.</p><pre><code class="hljs undefined">npm <span class="hljs-keyword">run</span><span class="bash"> electron-build</span></code></pre><p>At this point, you can run the command (it will take a few seconds) and it will create the dist/ folder and will automatically bring up a window on your operating system with default Angular app.</p><p>This setup does not support hot code reloads. Whenever you change some Angular code, you need to rerun the electron-build command. It is possible to setup hot reloads by pointing the window to a remote URL (such as <a href="https://localhost:4200" target="_blank" rel="noopener">https://localhost:4200</a>) and running ng serve in a separate terminal.</p><h1 id="Building-the-Angular-App"><a href="#Building-the-Angular-App" class="headerlink" title="Building the Angular App"></a>Building the Angular App</h1><p>Now we need to build an Angular App that’s worthy of being installed. I am building a single page timer that will animate a progress circle, then make a chime sound when complete.</p><p><img src="https://angularfirebase.com/images/angular-electron-timer.gif" srcset="/img/loading.gif" alt></p><p>To keep things super simple, I am writing all the code in the app.component</p><h1 id="Install-Round-Progress-Bar"><a href="#Install-Round-Progress-Bar" class="headerlink" title="Install Round Progress Bar"></a>Install Round Progress Bar</h1><p>To get the progress timer looking good quickly, I installed the angular-svg-round-progressbar package. It gives us a pre-built component that we can animate based on the current state of the timer.</p><pre><code class="hljs undefined">npm <span class="hljs-keyword">install</span> angular-svg-<span class="hljs-keyword">round</span>-progressbar <span class="hljs-comment">--save</span></code></pre><p>Then add it to the app.module.ts (also add the FormsModule).</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; BrowserModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;<span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; AppComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;<span class="hljs-keyword">import</span> &#123; FormsModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;<span class="hljs-keyword">import</span> &#123; RoundProgressModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-svg-round-progressbar'</span>;<span class="hljs-meta">@NgModule</span>(&#123;  declarations: [    AppComponent  ],  imports: [    BrowserModule,    FormsModule,    RoundProgressModule  ],  providers: [],  bootstrap: [AppComponent]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule &#123; &#125;</code></pre><h1 id="app-component-ts"><a href="#app-component-ts" class="headerlink" title="app.component.ts"></a>app.component.ts</h1><p>The app works by allowing the user to set the number of seconds the timer will run max. The timer progresses by running an RxJS Observable interval every 10th of a second and incrementing the current value.</p><p>I also defined several getters help deal with NaN values that can cause errors in the progress circle. They also help keep the HTML logic clean and readable.</p><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; Component, OnInit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; Observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Observable'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/observable/interval'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/map'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/takeWhile'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/do'</span>;<span class="hljs-meta">@Component</span>(&#123;  selector: <span class="hljs-string">'app-root'</span>,  templateUrl: <span class="hljs-string">'./app.component.html'</span>,  styleUrls: [<span class="hljs-string">'./app.component.scss'</span>]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;  max     = <span class="hljs-number">1</span>;  current = <span class="hljs-number">0</span>;  start() &#123;    <span class="hljs-keyword">const</span> interval = Observable.interval(<span class="hljs-number">100</span>);        interval          .takeWhile(_ =&gt; !<span class="hljs-keyword">this</span>.isFinished )          .do(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="hljs-keyword">this</span>.current += <span class="hljs-number">0.1</span>)          .subscribe();  &#125;  finish() &#123;    <span class="hljs-keyword">this</span>.current = <span class="hljs-keyword">this</span>.max;  &#125;  reset() &#123;    <span class="hljs-keyword">this</span>.current = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">get</span> maxVal() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(<span class="hljs-keyword">this</span>.max) || <span class="hljs-keyword">this</span>.max &lt; <span class="hljs-number">0.1</span> ? <span class="hljs-number">0.1</span> : <span class="hljs-keyword">this</span>.max;  &#125;  <span class="hljs-keyword">get</span> currentVal() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(<span class="hljs-keyword">this</span>.current) || <span class="hljs-keyword">this</span>.current &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-keyword">this</span>.current;  &#125;  <span class="hljs-keyword">get</span> isFinished() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.currentVal &gt;= <span class="hljs-keyword">this</span>.maxVal;  &#125;&#125;</code></pre><h1 id="app-component-html"><a href="#app-component-html" class="headerlink" title="app.component.html"></a>app.component.html</h1><p>In the HTML, we can declare the progress component and display the user interface elements conditionally based on the state of the timer.</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Electron Timer<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"progress-wrapper"</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"maxVal"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"!isFinished"</span>&gt;</span>          &#123;&#123; max - current | number: '1.1-1' &#125;&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isFinished"</span>&gt;</span>            ding!            <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"assets/chime.mp3"</span> <span class="hljs-attr">autoplay</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">round-progress</span>                [<span class="hljs-attr">max</span>]=<span class="hljs-string">"max"</span>                [<span class="hljs-attr">current</span>]=<span class="hljs-string">"current"</span>                [<span class="hljs-attr">radius</span>]=<span class="hljs-string">"100"</span>                [<span class="hljs-attr">stroke</span>]=<span class="hljs-string">"25"</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">round-progress</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"controls-wrapper"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Seconds<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"number of seconds"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>              [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"max"</span>              (<span class="hljs-attr">keydown</span>)=<span class="hljs-string">"reset()"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"currentVal &lt;= 0"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"start()"</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"!isFinished"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"finish()"</span>&gt;</span>Finish<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></code></pre><h1 id="Packaging-for-Desktop-Operating-Systems"><a href="#Packaging-for-Desktop-Operating-Systems" class="headerlink" title="Packaging for Desktop Operating Systems"></a>Packaging for Desktop Operating Systems</h1><p>Now that we have a decent app ready for desktops, we need to package and distribute it. The electron packager tool will allow to package our code into an executable for desktop platforms - including Windows (win32), MacOS (darwin), and Linux. Keep in mind, there are several other electron packaging tools that might better fit your needs.</p><pre><code class="hljs xml">npm install electron-packager -gnpm install electron-packager --save-dev</code></pre><p>Linux and MacOS developers will need to install WineHQ if they plan on building desktop apps for Windows.</p><p>In this example, I am going to build an executable for Windows.</p><pre><code class="hljs undefined">electron-packager . <span class="hljs-attribute">--platform</span>=win32</code></pre><p>This will generate a directory /angular-electron-win32-x64/ that contains the executable file.</p><p>And why not build one for MacOS while we’re at it.</p><pre><code class="hljs undefined">electron-packager . <span class="hljs-attribute">--platform</span>=darwin</code></pre><p>This will generate a directory /angular-electron-darwin-x64/ that contains the app. Zip it and extract it on a mac system and you should be able to run it natively. You will get warnings that it’s from an unknown developer, but this is expected and it’s perfectly safe to open - it’s your own code after all.</p><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>That’s it for the basic setup with Electron with Angular. In the future, I will post some more advanced examples of these technologies in action.</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot依赖引入的多种方式</title>
    <link href="/2018/10/15/how-to-import-springboot/"/>
    <url>/2018/10/15/how-to-import-springboot/</url>
    
    <content type="html"><![CDATA[<p>使用Spring Boot开发，不可避免的会面临Maven依赖包版本的管理。</p><p>有如下几种方式可以管理Spring Boot的版本。</p><h2 id="1-使用parent继承"><a href="#1-使用parent继承" class="headerlink" title="1. 使用parent继承"></a>1. 使用parent继承</h2><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myproject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Additional lines to be added here... --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>使用parent继承的方式，简单、方便使用。但是有的时候项目又需要继承其他的parent，这个时候parent继承的方式就满足不了需求了。不过不用担心，还有其他方式。</p><h2 id="2-使用import方式"><a href="#2-使用import方式" class="headerlink" title="2.使用import方式"></a>2.使用import方式</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre><p>在parent的pom文件中，声明dependencyManagement，这样在实际的项目pom文件中，直接声明需要的spring boot包就可以，不需要填写version属性。</p><p>还有一种是使用maven plugin。</p><h2 id="3-使用Spring-boot-Maven插件"><a href="#3-使用Spring-boot-Maven插件" class="headerlink" title="3.使用Spring boot Maven插件"></a>3.使用Spring boot Maven插件</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><p>spring boot依赖管理，根据不同的实际需求，选择不同的管理方式，可以大大提高效率。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10下手动编译Spring</title>
    <link href="/2018/10/12/build-spring-on-win10/"/>
    <url>/2018/10/12/build-spring-on-win10/</url>
    
    <content type="html"><![CDATA[<p>在windows下执行<code>gradlew.bat build</code>发生异常，如下：<br><img src="http://img.hb.aicdn.com/6257b1a43c17c6eba97c52034c6f398c459788305765-exykoC_fw658" srcset="/img/loading.gif" alt="image"></p><p>原因是执行gradle编译时，没有生成<code>xxx-schema.zip</code>文件。</p><p>通过修改task schemaZip,将文件路径分符由Unix系统的<code>/</code>修改为windows系统的<code>\\</code>.</p><pre><code class="hljs undefined">task schemaZip(type: Zip) &#123;<span class="hljs-built_in">group </span>= <span class="hljs-string">"Distribution"</span>baseName = <span class="hljs-string">"spring-framework"</span>classifier = <span class="hljs-string">"schema"</span>description = <span class="hljs-string">"Builds -<span class="hljs-variable">$&#123;classifier&#125;</span> archive containing all "</span> +<span class="hljs-string">"XSDs for deployment at http://springframework.org/schema."</span>duplicatesStrategy <span class="hljs-string">'exclude'</span>moduleProjects.each &#123; subproject -&gt;def Properties schemas = new Properties();subproject.sourceSets.main.resources.<span class="hljs-builtin-name">find</span> &#123;it.path.endsWith(<span class="hljs-string">"META-INF\\spring.schemas"</span>)&#125;?.withInputStream &#123; schemas.load(it) &#125;<span class="hljs-keyword">for</span> (def key : schemas.keySet()) &#123;def shortName = key.replaceAll(/http.*schema.(.*).spring-.*/, <span class="hljs-string">'$1'</span>)assert shortName != keyFile xsdFile = subproject.sourceSets.main.resources.<span class="hljs-builtin-name">find</span> &#123;it.path.endsWith(schemas.<span class="hljs-builtin-name">get</span>(key).replaceAll(<span class="hljs-string">'\\/'</span>, <span class="hljs-string">'\\\\'</span>))&#125;assert xsdFile != <span class="hljs-literal">null</span>into (shortName) &#123;<span class="hljs-keyword">from</span> xsdFile.path&#125;&#125;&#125;&#125;</code></pre><blockquote><p><a href="https://stackoverflow.com/questions/34916981/build-spring-framework-source-code-encounter-an-error" target="_blank" rel="noopener">参考stackoverflow</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vs code调试Angular</title>
    <link href="/2018/07/10/vs-code-diao-shi-angular/"/>
    <url>/2018/07/10/vs-code-diao-shi-angular/</url>
    
    <content type="html"><![CDATA[<h1 id="vs-code调试Angular"><a href="#vs-code调试Angular" class="headerlink" title="vs code调试Angular"></a>vs code调试Angular</h1><p>为了调试客户端Angular代码，需要安装<a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank" rel="noopener">Debugger for Chrome</a> Chrome扩展应用</p><p>打开vs code的扩展应用视图(<code>Ctrl+Shift+X</code>), 搜索<code>chrome</code>。</p><p><img src="https://code.visualstudio.com/assets/docs/nodejs/reactjs/debugger-for-chrome.png" srcset="/img/loading.gif" alt="image"></p><p>点击<code>Install</code>，等安装完成后点击<code>Reload</code>，重新加载扩展应用使新安装的应用生效。</p><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>在<code>app.component.ts</code>中设置断点，断点显示为红色原点。</p><p><img src="https://code.visualstudio.com/assets/docs/nodejs/angular/breakpoint.png" srcset="/img/loading.gif" alt="image"></p><h2 id="配置Chrome-debugger"><a href="#配置Chrome-debugger" class="headerlink" title="配置Chrome debugger"></a>配置Chrome debugger</h2><p>首先配置调试器。打开调试视图(<code>Ctrl+Shift+D</code>)，点击设置按钮，创建调试器配置文件<code>launch.json</code>。环境选择<code>Chrome</code>，会在<code>.vscode</code>文件夹下生成一个<code>launch.json</code>文件。</p><p>修改url端口号，将<code>8080</code>修改为<code>4200</code>，如下：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.2.0"</span>,    <span class="hljs-attr">"configurations"</span>: [        &#123;            <span class="hljs-attr">"type"</span>: <span class="hljs-string">"chrome"</span>,            <span class="hljs-attr">"request"</span>: <span class="hljs-string">"launch"</span>,            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Launch Chrome against localhost"</span>,            <span class="hljs-attr">"url"</span>: <span class="hljs-string">"http://localhost:4200"</span>,            <span class="hljs-attr">"webRoot"</span>: <span class="hljs-string">"$&#123;workspaceFolder&#125;"</span>        &#125;    ]&#125;</code></pre><p><code>F5</code>或绿色三角运行调试器，会打开一个新的浏览器实例。</p><p><img src="https://code.visualstudio.com/assets/docs/nodejs/angular/hit-breakpoint.png" srcset="/img/loading.gif" alt="image"></p><p>可以用<code>F10</code>单步调试。还可以查看变量信息，栈信息。<br><img src="https://code.visualstudio.com/assets/docs/nodejs/angular/debug-variable.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
      <tag>VS Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Display real-time data in Angular</title>
    <link href="/2018/06/28/display-real-time-data-in-angular/"/>
    <url>/2018/06/28/display-real-time-data-in-angular/</url>
    
    <content type="html"><![CDATA[<p>In this article, we’ll be taking a look at two ways to display real-time data in an Angular application. We’ll discuss how to push real-time data via a service. One approach will be using sockets while the other will be using the Angular AsyncPipe and Observables.</p><h2 id="Setting-the-scene"><a href="#Setting-the-scene" class="headerlink" title="Setting the scene"></a>Setting the scene</h2><p>Often in an application, we work with a backend API service. We create a component, we call an Angular service which in turn calls an API. That API call returns some data and that data is then displayed in the template of the component. This is a very simple scenario. But what happens when data that arrives is updated frequently - think about stock symbols and their values, an online radio that needs to display a new artist &amp; song title. We somehow need to update the component when the data changes at the API level.</p><h2 id="Async-Pipe-amp-Observables"><a href="#Async-Pipe-amp-Observables" class="headerlink" title="Async Pipe &amp; Observables"></a>Async Pipe &amp; Observables</h2><p>The first approach that we’ll take a look doesn’t require any modification at the API level. In light of this, we’ll be using the <code>Async Pipe</code>. Pipes in Angular work just as pipes work in Linux. They accept an input and produce an output. What the output is going to be is determined by the pipe’s functionality. This pipe accepts a promise or an observable as an input, and it can update the template whenever the promise is resolved or when the observable emits some new value. As with all pipes, we need to apply the pipe in the template.</p><p>Let’s assume that we have a list of products returned by an API and that we have the following service available:</p><pre><code class="hljs typescript"><span class="hljs-comment">// api.service.ts</span><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; HttpClient &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ApiService &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> http: HttpClient</span>) &#123; &#125;  getProducts() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'http://localhost:3000/api/products'</span>);  &#125;&#125;</code></pre><p>The code above is straightforward - we specify the <code>getProducts()</code> method that returns the HTTP GET call.</p><p>It’s time to consume this service in the component. And what we’ll do here is create an Observable and assign the result of the <code>getProducts()</code> method to it. Furthermore, we’ll make that call every 1 second, so if there’s an update at the API level, we can refresh the template:</p><pre><code class="hljs typescript"><span class="hljs-comment">// some.component.ts</span><span class="hljs-keyword">import</span> &#123; Component, OnInit, OnDestroy, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; ApiService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./../api.service'</span>;<span class="hljs-keyword">import</span> &#123; Observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Observable'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/observable/interval'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/startWith'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'rxjs/add/operator/switchMap'</span>;<span class="hljs-meta">@Component</span>(&#123;  selector: <span class="hljs-string">'app-products'</span>,  templateUrl: <span class="hljs-string">'./products.component.html'</span>,  styleUrls: [<span class="hljs-string">'./products.component.css'</span>]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ProductsComponent <span class="hljs-keyword">implements</span> OnInit &#123;  <span class="hljs-meta">@Input</span>() products$: Observable&lt;<span class="hljs-built_in">any</span>&gt;;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> api: ApiService</span>) &#123; &#125;  ngOnInit() &#123;    <span class="hljs-keyword">this</span>.products$ = Observable                              .interval(<span class="hljs-number">1000</span>)                        .startWith(<span class="hljs-number">0</span>).switchMap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.api.getProducts());  &#125;&#125;</code></pre><p>And last but not least, we need to apply the async pipe in our template:</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- some.component.html --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let product of products$ | async"</span>&gt;</span>&#123;&#123; product.prod_name &#125;&#125; for &#123;&#123; product.price | currency:'£'&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>This way, if we push a new item to the API (or remove one or multiple item(s)) the updates are going to be visible in the component in 1 second.</p><h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><p>Another approach to creating a component and a service that accepts push data from the server is by implementing sockets. To achieve such functionality, changes need to be performed both at the API and the Client side as well.</p><h2 id="API-level-modifications"><a href="#API-level-modifications" class="headerlink" title="API level modifications"></a>API level modifications</h2><p>At the API level, we need to enable sockets, and one of the most used packages that developers use is <code>socket.io</code> which can be installed via <code>npm i socket.io</code>.</p><p>Here’s an implementation of the server using Restify and Socket.io:</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> restify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'restify'</span>);<span class="hljs-keyword">const</span> server = restify.createServer();<span class="hljs-keyword">const</span> products = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./products'</span>);<span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">'socket.io'</span>)(server.server);<span class="hljs-keyword">let</span> sockets = <span class="hljs-keyword">new</span> Set();<span class="hljs-keyword">const</span> corsMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">'restify-cors-middleware'</span>);<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<span class="hljs-keyword">const</span> cors = corsMiddleware(&#123;origins: [<span class="hljs-string">'*'</span>],&#125;);server.use(restify.plugins.bodyParser());server.pre(cors.preflight);server.use(cors.actual);io.on(<span class="hljs-string">'connection'</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;  sockets.add(socket);  socket.emit(<span class="hljs-string">'data'</span>, &#123; data: products &#125;);  socket.on(<span class="hljs-string">'clientData'</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));  socket.on(<span class="hljs-string">'disconnect'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> sockets.delete(socket));&#125;);server.get(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">request, response, next</span>) =&gt;</span> &#123;  response.end();  next();&#125;);server.post(<span class="hljs-string">'/api/products'</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> product = request.body;  products.push(product);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> socket of sockets) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Emitting value: <span class="hljs-subst">$&#123;products&#125;</span>`</span>);    socket.emit(<span class="hljs-string">'data'</span>, &#123; data: products &#125;);  &#125;  response.json(products);&#125;);server.listen(port, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.info(<span class="hljs-string">`Server is up on <span class="hljs-subst">$&#123;port&#125;</span>.`</span>));</code></pre><blockquote><p>Note how Restify requires us to use <code>server.server</code> when requiring <code>socket.io</code>.</p></blockquote><p>The above code may look complex; however, it is a straightforward implementation. The required <code>products</code> file contains an array of objects which represent some data. On the first connection to the server we send data to the requester as well as making sure that we store the socket in a JavaScript <code>Set</code>:</p><pre><code class="hljs typescript">io.on(<span class="hljs-string">'connection'</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;  sockets.add(socket);  socket.emit(<span class="hljs-string">'data'</span>, &#123; data: products &#125;);  socket.on(<span class="hljs-string">'clientData'</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));  socket.on(<span class="hljs-string">'disconnect'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> sockets.delete(socket));&#125;);</code></pre><p>When a new product is added (in this case it’s just a simple push to the <code>products</code> array), then we again, emit the updated array to all the clients who are connected:</p><pre><code class="hljs typescript">server.post(<span class="hljs-string">'/api/products'</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> product = request.body;  products.push(product);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> socket of sockets) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Emitting value: <span class="hljs-subst">$&#123;products&#125;</span>`</span>);    socket.emit(<span class="hljs-string">'data'</span>, &#123; data: products &#125;);  &#125;  response.json(products);&#125;);</code></pre><blockquote><p>Note, that in this article we’re only going through the basics and henceforth the API is kept at an elementary level.</p></blockquote><h1 id="Client-side-modifications"><a href="#Client-side-modifications" class="headerlink" title="Client side modifications"></a>Client side modifications</h1><p>At the client side - from our Angular application - we also need to connect to the socket, and for this, we’ll be using a package called <code>socket.io-client</code> along with its typing. Both of these can be installed via npm: <code>npm i socket.io-client @types/socket.io-client</code>.</p><p>Once installed we can update our Angular service:</p><pre><code class="hljs typescript"><span class="hljs-comment">// api.service.ts</span><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; HttpClient &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> socketIo <span class="hljs-keyword">from</span> <span class="hljs-string">'socket.io-client'</span>;<span class="hljs-keyword">import</span> &#123; Observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Observer'</span>;<span class="hljs-keyword">import</span> &#123; Observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Observable'</span>;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ApiService &#123;  observer: Observer&lt;<span class="hljs-built_in">any</span>&gt;;  getProducts() &#123;    <span class="hljs-keyword">const</span> socket = socketIo(<span class="hljs-string">'http://localhost:3000/'</span>);    socket.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.observer.next(response.data);    &#125;);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createObservable();  &#125;  createObservable() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> <span class="hljs-keyword">this</span>.observer = observer);  &#125;&#125;</code></pre><p>Here we are creating an observer first, then connect to the socket server running on port 3000 (or whatever port we have specified for the API). If data is emitted from the socket server (which happens on the first load as well as when someone adds a new product), an observable is created. This is what gets passed on to the component and then to the template which still utilises the async pipe - the rest of the code does not change.</p><p>Adding a new product will also now mean that the list of products is updated.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this article, we had a look at two ways to achieve real-time data updates in Angular components.</p><blockquote><p><a href="https://fullstack-developer.academy/display-real-time-data-in-angular/" target="_blank" rel="noopener">原文地址</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>how to monitor java garbage collection</title>
    <link href="/2018/06/27/how-to-monitor-java-garbage-collection/"/>
    <url>/2018/06/27/how-to-monitor-java-garbage-collection/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.cubrid.org/blog/how-to-monitor-java-garbage-collection" target="_blank" rel="noopener">原文</a></p></blockquote><h1 id="What-is-GC-Monitoring"><a href="#What-is-GC-Monitoring" class="headerlink" title="What is GC Monitoring?"></a>What is GC Monitoring?</h1><p><strong>Garbage Collection Monitoring</strong> refers to the <em>process of figuring out how JVM is running GC</em>. For example, we can find out:</p><ol><li>When an object in young has moved to old and by how much,</li><li>or wehn <code>stop-the-world</code> has occurred and for how long.</li></ol><p>GC Monitoring is carried out to see <em>if JVM is running GC efficiently</em>, and <em>to check if additional GC tuning is necessary</em>. Based on this information, the application can be edited or GC method can be changed (<strong>GC tuning</strong>).</p><h1 id="How-to-Monitor-GC"><a href="#How-to-Monitor-GC" class="headerlink" title="How to Monitor GC?"></a>How to Monitor GC?</h1><p>There are different ways to monitor GC, but the only difference is how the GC operation information is shown. GC is done by JVM, and since the GC monitoring tools disclose the GC information provided by JVM, you will get the same results on matter how you monitor GC. Therefore, you do not need to learn all methods to monitor GC, but since it only requires a little amount of time to learn each GC monitoring method, knowing a few of them can help you use the right one for different situations and environments.</p><p>The tools or JVM options listed below cannot be used universally regardless of the HVM vendor. This is because there is no need for a “standard” for disclosing GC information. In this example we will use <strong>HotSpot JVM</strong> (Oracle JVM). Since NHN is using Oracle(Sun) JVM, there should be no difficulties in applying the tools or JVM options that we are explaining here.</p><p>First, the GC monitoring methods can be separated into <strong>CUI</strong> and <strong>GUI</strong> depending on the access interface. The typical CUI GC monitoring method involves using a separate CUI application called “<strong>jstat</strong>“, or selecting a JVM option called “<strong>verbosegc</strong>“ when running JVM.</p><p>GUI GC monitoring is done by using a separate GUI application, and three most commonly used applications would be “jconsole”, “jvisualvm” and “Visual GC”.</p><p>Let’s learn more about each method.</p><h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p><strong>jstat</strong> is a monitoring tool in HotSpot JVM. Other monitoring tools for HotSpot JVM are <strong>jps</strong> and <strong>jstatd</strong>. Sometimes, you need all three tools to monitor a Java application.</p><p><strong>jstat</strong> does not provide only the GC operation information display. It also provides class loader operation information or Just-in-Time compiler operation information. Among all the information jstat can provide, in this article we will only cover its functionality to monitor GC operating information.</p><p><strong>jstat</strong> is located in <code>$JDK_HOME/bin</code>, so if java or javac can run without setting a separate directory from the command line, so can jstat.</p><p>You can try running the following in the command line.</p><pre><code class="hljs undefined">$&gt; jstat –gc  $&lt;vmid$&gt; <span class="hljs-number">1000</span>S0C       S1C       S0U    S1U      EC         EU          OC         OU         PC         PU         YGC     YGCT    FGC      FGCT     GCT<span class="hljs-number">3008.0</span>   <span class="hljs-number">3072.0</span>    <span class="hljs-number">0.0</span>     <span class="hljs-number">1511.1</span>   <span class="hljs-number">343360.0</span>   <span class="hljs-number">46383.0</span>     <span class="hljs-number">699072.0</span>   <span class="hljs-number">283690.2</span>   <span class="hljs-number">75392.0</span>    <span class="hljs-number">41064.3</span>    <span class="hljs-number">2540</span>    <span class="hljs-number">18.454</span>    <span class="hljs-number">4</span>      <span class="hljs-number">1.133</span>    <span class="hljs-number">19.588</span><span class="hljs-number">3008.0</span>   <span class="hljs-number">3072.0</span>    <span class="hljs-number">0.0</span>     <span class="hljs-number">1511.1</span>   <span class="hljs-number">343360.0</span>   <span class="hljs-number">47530.9</span>     <span class="hljs-number">699072.0</span>   <span class="hljs-number">283690.2</span>   <span class="hljs-number">75392.0</span>    <span class="hljs-number">41064.3</span>    <span class="hljs-number">2540</span>    <span class="hljs-number">18.454</span>    <span class="hljs-number">4</span>      <span class="hljs-number">1.133</span>    <span class="hljs-number">19.588</span><span class="hljs-number">3008.0</span>   <span class="hljs-number">3072.0</span>    <span class="hljs-number">0.0</span>     <span class="hljs-number">1511.1</span>   <span class="hljs-number">343360.0</span>   <span class="hljs-number">47793.0</span>     <span class="hljs-number">699072.0</span>   <span class="hljs-number">283690.2</span>   <span class="hljs-number">75392.0</span>    <span class="hljs-number">41064.3</span>    <span class="hljs-number">2540</span>    <span class="hljs-number">18.454</span>    <span class="hljs-number">4</span>      <span class="hljs-number">1.133</span>    <span class="hljs-number">19.588</span>$&gt;</code></pre><p>Just like in the example, the real type data will be output along with the following columns:</p><p><strong><code>S0C    S1C     S0U     S1U    EC     EU     OC     OU     PC</code></strong>.</p><p><strong>vmid</strong> (Virtual Machine ID), as its name implies, is the ID for the VM. Java applications running either on a local machine or on a remote machine can be specified using vmid. The vmid for Java application running on a local machine is called <strong>lvmid</strong> (Local vmid), and usually is PID. To find out the lvmid, you can write the PID value using a <strong>ps</strong> command or Windows task manager, but we suggest <strong>jps</strong> because PID and lvmid does not always match. <strong>jps</strong> stands for Java PS. <strong>jps</strong> shows vmids and main method information. Just like ps shows PIDs and process names.</p><p>Find out the vmid of the Java application that you want to monitor by using jps, then use it as a parameter in jstat. If you use jps alone, only bootstrap information will show when several WAS instances are running in one equipment. We suggest that you use <code>ps -ef | grep java</code> command along with jps.</p><p>GC performance data needs constant observation, therefore when running jstat, try to output the GC monitoring information on a regular basis.</p><p>For example, running “<code>jstat –gc &lt;vmid&gt; 1000</code>“ (or 1s) will display the GC monitoring data on the console every 1 second. “<code>jstat –gc &lt;vmid&gt; 1000 10</code>“ will display the GC monitoring information once every 1 second for 10 times in total.</p><p>There are many options other than <code>-gc</code>, among which GC related ones are listed below.</p><table><thead><tr><th align="left">Option Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">gc</td><td align="left">It shows the current size for each heap area and its current usage (Ede, survivor, old, etc.), total number of GC performed, and the accumulated time for GC operations.</td></tr><tr><td align="left">gccapactiy</td><td align="left">It shows the minimum size (ms) and maximum size (mx) of each heap area, current size, and the number of GC performed for each area. (Does not show current usage and accumulated time for GC operations.)</td></tr><tr><td align="left">gccause</td><td align="left">It shows the “information provided by -gcutil” + reason for the last GC and the reason for the current GC.</td></tr><tr><td align="left">gcnew</td><td align="left">Shows the GC performance data for the new area.</td></tr><tr><td align="left">gcnewcapacity</td><td align="left">Shows statistics for the size of new area.</td></tr><tr><td align="left">gcold</td><td align="left">Shows the GC performance data for the old area.</td></tr><tr><td align="left">gcoldcapacity</td><td align="left">Shows statistics for the size of old area.</td></tr><tr><td align="left">gcpermcapacity</td><td align="left">Shows statistics for the permanent area.</td></tr><tr><td align="left">gcutil</td><td align="left">Shows the usage for each heap area in percentage. Also shows the total number of GC performed and the accumulated time for GC operations.</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java各版本特性</title>
    <link href="/2018/06/07/future-of-java-each-version/"/>
    <url>/2018/06/07/future-of-java-each-version/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-5"><a href="#Java-5" class="headerlink" title="Java 5"></a>Java 5</h1><ol><li>泛型Generics</li><li>枚举类型Enumeration</li><li>自动装箱（自动类型包装和解包）autoboxing &amp; unboxing</li><li>可变参数varargs（varargs number of arguments）</li><li>Annotations</li><li>新的迭代语句</li><li>静态导入</li><li>新的格式化方法</li><li>新的线程模型和并发库</li></ol><h1 id="Java-6"><a href="#Java-6" class="headerlink" title="Java 6"></a>Java 6</h1><ol><li>引入一个支持脚本引擎的新框架</li><li>UI的增强</li><li>对WebService支持的增强</li><li>一系列的安全相关的增强</li><li>JDBC 4.0</li><li>Compiler API</li><li>通用的Annotations支持</li></ol><h1 id="Java-7"><a href="#Java-7" class="headerlink" title="Java 7"></a>Java 7</h1><ol><li>switch中可以使用字符串</li><li>泛型实例化类型自动推断</li><li>语法上支持集合，而不一定是数组</li><li>新增了一些取环境信息的工具方法</li><li>Boolean类型反转，空指针安全，参与为运算</li><li>两个char间的equals</li><li>安全的加减乘除</li><li>Map集合支持并发请求</li></ol><h1 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h1><ol><li><p>Lambda表达式</p></li><li><p>默认方法</p></li><li><p>静态方法</p></li><li><p>优化了HashMap以及ConcurrentHashMap<br>将HashMap原来的数组+链表的结构优化成了数组+链表+红黑树的结构，减少了hash碰撞造成的链表长度过长，时间复杂度过高的问题，ConcurrentHashMap则改进了原先的分段锁的方式，采用transient volatile HashEntry&lt;K,V&gt;[] table来保存数据。</p></li><li><p>JVM<br>PermGen空间被移除了，取而代之的是Metaspace。JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p></li><li><p>新增原子性操作类LongAdder</p></li><li><p>新增StampedLock</p></li></ol><h1 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h1><ol><li>jshell</li><li>私有接口方法</li><li>更改了HTTP调动的相关API</li><li>集合工厂方法</li><li>改进了Stream API</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java发展史</title>
    <link href="/2018/06/06/java-history/"/>
    <url>/2018/06/06/java-history/</url>
    
    <content type="html"><![CDATA[<p><img src="https://segmentfault.com/img/bVbcbFO?w=220&h=209" srcset="/img/loading.gif" alt="图片描述"></p><p>Java创始认之一：James Gosling</p><p>Java之父 – James Gosling出生于加拿大，是一位计算机编程天才。在卡内基·梅隆大学攻读计算机博士学位时，他编写了多处理器版本的Unix操作系统。1991年，在Sun公司工作期间，James Gosling和一群技术人员创建了一个名为Oak的项目，旨在开发运行于虚拟机的编程语言，同时允许程序在电视机机顶盒等多平台上运行。后来，这项工作就演变成Java。随着互联网的普及，尤其是网景开发的网页浏览器的面世，Java成为全球最流行的开发语言。</p><p><img src="https://segmentfault.com/img/bVbcbF2?w=875&h=388" srcset="/img/loading.gif" alt="图片描述"></p><ul><li>1996年1月，Sun公司发布了Java的第一个开发工具包（JDK1.0），这是Java发展历程中的重要的里程碑，标志着Java成为一种独立的开发工具。9月，约8.3万个网页应用了Java技术制作。10月，Sun公司发布了Java平台的第一个即时（JIT）编译器。</li><li>1997年2月，JDK1.1面世，在随后的3周时间里，达到了22万次的下载量。4月2日，Java One会议召开，参会者逾一万人，创当时全球同类会议规模之记录。9月，Java Developer Connection社区超过10万。</li><li>1998年12月8日，第二代Java平台的企业版J2EE发布。</li><li>1999年6月，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java 2 Micro Edition， Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition, Java 2平台的标准版），应用于桌面环境；J2EE（Java 2 Enterprise Edition，Java 2平台的企业版），应用于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。</li><li>2000年5月，JDK1.3、JDK1.4和J2SE 1.3相继发布，几周后获得了Apple公司Mac OS X的工业标准的支持。</li><li>2001年9月24日，J2EE1.3发布。</li><li>2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升。</li><li>2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0，代号为”Tiger“。</li><li>2005年6月，在Java One大会上，Sun公司发布了Java SE 6。此时，Java的各种版本已经更名，已取消其中的数字2，如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。</li><li>2006年11月13日，Java技术的发明者Sun公司宣布，将Java技术作为免费软件对外发布。</li><li>2009年，甲骨文公司宣布收购Sun。</li><li>2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。</li><li>2014年，甲骨文公司发布了Java8正式版。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ架构简介</title>
    <link href="/2018/04/09/rocketmq-architecture/"/>
    <url>/2018/04/09/rocketmq-architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Apache RocketMQ是一款具有低延迟，高性能和可靠性，数十亿容量和灵活可扩展性的分布式消息传递和流媒体平台。它由四部分组成：Name Servers，brokers，producers和consumers。 它们中的每一个都可以在没有单点故障的情况下进行水平扩展。</p><p><img src="http://rocketmq.apache.org/assets/images/rmq-basic-arc.png" srcset="/img/loading.gif" alt="RocketMQ架构"></p><h1 id="NameServer集群"><a href="#NameServer集群" class="headerlink" title="NameServer集群"></a>NameServer集群</h1><p>Name Servers提供轻量级服务发现和路由。每个Name Server记录完整的路由信息，提供相应的读写服务，并支持快速存储扩展。</p><h1 id="Broker集群"><a href="#Broker集群" class="headerlink" title="Broker集群"></a>Broker集群</h1><p>Brokers通过提供轻量级的TOPIC和QUEUE机制来实现消息存储。 它们支持Push和Pull模式，包含容错机制（2个或3个副本），并提供强大的峰值填充和按原始时间顺序累积数千亿条消息的能力。此外，broker提供灾难恢复，丰富的指标统计数据和警报机制，而传统的消息传递系统都缺乏这些机制。</p><h1 id="Producer集群"><a href="#Producer集群" class="headerlink" title="Producer集群"></a>Producer集群</h1><p>Producer集群支持分布式部署。分布式producer通过多种负载均衡模式向Broker集群发送消息。发送过程支持fast failure并具有低延迟。</p><h1 id="Consumer集群"><a href="#Consumer集群" class="headerlink" title="Consumer集群"></a>Consumer集群</h1><p>Consumer也支持Push和Pull模型的分布式部署。 它还支持群集消费和消息广播。 它提供了实时的消息订阅机制，可以满足大多数消费者的需求。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次线上问题的排查过程</title>
    <link href="/2018/04/05/online-question-resolve/"/>
    <url>/2018/04/05/online-question-resolve/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>XX系统中，一个用户需要维护的项目数过多，填写的任务数超多，产生了一次工时保存中，只有前面一部分的xx数据持久化到数据库，后面的数据没有保存。</p><p><code>图1</code></p><p><img src="http://ww1.sinaimg.cn/large/806e3151ly1fptj4uwnnuj21200i8gm5.jpg" srcset="/img/loading.gif" alt></p><h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><h2 id="1-增加日志，监控参数信息"><a href="#1-增加日志，监控参数信息" class="headerlink" title="1.增加日志，监控参数信息"></a>1.增加日志，监控参数信息</h2><p>首先想到的是否后面部分的数据在保存过程中发生了异常。排查异常日志，发现没有该问题存在。</p><p>然后增加方法参数信息日志，数据参数信息。发现参数集合size=200，前端发送集合size=400。判断问题可以能是因为服务器容器环境(Nginx+Tomcat)导致</p><h2 id="2-开发环境问题重现"><a href="#2-开发环境问题重现" class="headerlink" title="2.开发环境问题重现"></a>2.开发环境问题重现</h2><h3 id="2-1-模拟数据"><a href="#2-1-模拟数据" class="headerlink" title="2.1 模拟数据"></a>2.1 模拟数据</h3><p>在测试环境模拟线上数据。如<code>图1</code></p><h3 id="2-2-只配置Tomcat"><a href="#2-2-只配置Tomcat" class="headerlink" title="2.2 只配置Tomcat"></a>2.2 只配置Tomcat</h3><p>在idea中直接启动tomcat，无nginx环境，如果没有问题，则可暂时确定为nginx问题。</p><p>然而，在过程中发现了新的问题。</p><pre><code class="hljs undefined"><span class="hljs-keyword">org.springframework.beans.InvalidPropertyException: </span>Invalid property <span class="hljs-string">'detail[256]'</span> of <span class="hljs-keyword">bean </span>class [com.suning.asvp.mer.entity.InviteCooperationInfo]: Index of out of <span class="hljs-keyword">bounds </span>in property path <span class="hljs-string">'detail[256]'</span><span class="hljs-comment">; nested exception is java.lang.IndexOutOfBoundsException: Index: 256, Size: 256  </span>    <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.beans.BeanWrapperImpl.getPropertyValue(BeanWrapperImpl.java:833) </span>~[spring-<span class="hljs-keyword">beans-3.1.2.RELEASE.jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.beans.BeanWrapperImpl.getNestedBeanWrapper(BeanWrapperImpl.java:576) </span>~[spring-<span class="hljs-keyword">beans-3.1.2.RELEASE.jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.beans.BeanWrapperImpl.getBeanWrapperForPropertyPath(BeanWrapperImpl.java:553) </span>~[spring-<span class="hljs-keyword">beans-3.1.2.RELEASE.jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:914) </span>~[spring-<span class="hljs-keyword">beans-3.1.2.RELEASE.jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:76) </span>~[spring-<span class="hljs-keyword">beans-3.1.2.RELEASE.jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.validation.DataBinder.applyPropertyValues(DataBinder.java:692) </span>~[spring-<span class="hljs-built_in">context</span><span class="hljs-number">-3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.RELEASE.<span class="hljs-keyword">jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.validation.DataBinder.doBind(DataBinder.java:588) </span>~[spring-<span class="hljs-built_in">context</span><span class="hljs-number">-3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.RELEASE.<span class="hljs-keyword">jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.web.bind.WebDataBinder.doBind(WebDataBinder.java:191) </span>~[spring-web<span class="hljs-number">-3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.RELEASE.<span class="hljs-keyword">jar:3.1.2.RELEASE] </span>     <span class="hljs-built_in">at</span> <span class="hljs-keyword">org.springframework.web.bind.ServletRequestDataBinder.bind(ServletRequestDataBinder.java:112) </span>~[spring-web<span class="hljs-number">-3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.RELEASE.<span class="hljs-keyword">jar:3.1.2.RELEASE]</span></code></pre><p>查看BeanWrapperImpl源码</p><pre><code class="hljs undefined"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> instanceof List) &#123;      <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span> = <span class="hljs-keyword">Integer</span>.parseInt(key);                            List list = (List) <span class="hljs-keyword">value</span>;      growCollectionIfNecessary(list, <span class="hljs-built_in">index</span>, indexedPropertyName, pd, i + <span class="hljs-number">1</span>);                           <span class="hljs-keyword">value</span> = list.get(<span class="hljs-built_in">index</span>);// 测试报错时，此处list只有<span class="hljs-number">256</span>个，<span class="hljs-built_in">index</span>为<span class="hljs-number">256</span>时，取第<span class="hljs-number">257</span>个报错  &#125;</code></pre><pre><code class="hljs undefined">@SuppressWarnings(<span class="hljs-string">"unchecked"</span>)      <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> growCollectionIfNecessary(              Collection collection, <span class="hljs-built_in">int</span> index, <span class="hljs-keyword">String</span> name, PropertyDescriptor pd, <span class="hljs-built_in">int</span> nestingLevel) &#123;          <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.autoGrowNestedPaths) &#123;              <span class="hljs-keyword">return</span>;          &#125;          <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span> = collection.<span class="hljs-built_in">size</span>();          <span class="hljs-comment">// 当个数小于autoGrowCollectionLimit这个值时才会向list中添加新元素  </span>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">size</span> &amp;&amp; index &lt; <span class="hljs-keyword">this</span>.autoGrowCollectionLimit) &#123;              Class elementType = GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), nestingLevel);              <span class="hljs-keyword">if</span> (elementType != <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = collection.<span class="hljs-built_in">size</span>(); i &lt; index + <span class="hljs-number">1</span>; i++) &#123;                      collection.<span class="hljs-built_in">add</span>(newValue(elementType, name));                  &#125;              &#125;          &#125;      &#125;</code></pre><p>根据上面的分析找到autoGrowCollectionLimit的定义</p><pre><code class="hljs undefined">public class DataBinder implements PropertyEditorRegistry, TypeConverter &#123;      /** Default object name used for binding: <span class="hljs-string">"target"</span> */     <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span><span class="hljs-keyword"> final</span> String DEFAU<span class="hljs-class">LT_OBJECT_NAME = "target";</span>      /** Default limit for<span class="hljs-built_in"> array </span>and collection growing: 256 */     <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span><span class="hljs-keyword"> final</span><span class="hljs-built_in"> int </span>DEFAU<span class="hljs-class">LT_AUTO_GROW_COLLECTION_LIMIT = 256;</span>     <span class="hljs-keyword"> private</span><span class="hljs-built_in"> int </span>autoGrowCollection<span class="hljs-class">Limit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;</span></code></pre><p>解决方案，是在自己的Controller中加入如下方法</p><pre><code class="hljs undefined"><span class="hljs-meta">@InitBinder</span>  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;      binder.setAutoGrowNestedPaths(<span class="hljs-keyword">true</span>);      binder.setAutoGrowCollectionLimit(<span class="hljs-number">1024</span>);  &#125;</code></pre><p>==<strong>BUT</strong> 这个问题和线上的不同，只能算是意外收获。革命尚未成功，同志仍需努力！！！！==</p><h3 id="2-3-增加Nginx"><a href="#2-3-增加Nginx" class="headerlink" title="2.3 增加Nginx"></a>2.3 增加Nginx</h3><p>经过2.2的奋斗，暂时判定是否为Nginx post请求参数做了限制。嗯，开搞~ 在开发环境配置Nginx代理，过程略·····</p><p>nginx.conf 如下</p><pre><code class="hljs undefined"><span class="hljs-attribute">upstream</span> xxxxxxx &#123;<span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8080</span>  weight=<span class="hljs-number">10</span> max_fails=<span class="hljs-number">2</span> fail_timeout=<span class="hljs-number">30s</span> ;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  xxxxxxx.com;    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">100M</span>;  <span class="hljs-comment"># 配置post size</span>    <span class="hljs-comment">#charset koi8-r;</span>    <span class="hljs-comment">#access_log  logs/host.access.log  main;</span>   <span class="hljs-attribute">location</span> / &#123;<span class="hljs-comment">#proxy_next_upstream     http_500 http_502 http_503 http_504 error timeout invalid_header;</span><span class="hljs-attribute">proxy_set_header</span>        Host  <span class="hljs-variable">$host</span>;<span class="hljs-attribute">proxy_set_header</span>        X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<span class="hljs-attribute">proxy_pass</span>              http://xxxxxxx;<span class="hljs-attribute">expires</span>                 <span class="hljs-number">0</span>;&#125;&#125;</code></pre><p>对于<code>client_max_body_size 100M;</code>，网上都是与文件上传相关的。不过都是通过post， request body的方式上传数据，所以通用。</p><p>测试~~</p><p>功能正常，没有重现线上问题。 哭死<del>~</del></p><p>革命还要继续~~</p><h3 id="2-4-Tomcat-post设置"><a href="#2-4-Tomcat-post设置" class="headerlink" title="2.4 Tomcat post设置"></a>2.4 Tomcat post设置</h3><p>去线上服务器拉去配置</p><pre><code class="hljs undefined">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">"1601"</span> <span class="hljs-attribute">maxParameterCount</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span> <span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">"8443"</span> <span class="hljs-attribute">maxSpareThreads</span>=<span class="hljs-string">"750"</span> <span class="hljs-attribute">maxThreads</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attribute">minSpareTHreads</span>=<span class="hljs-string">"50"</span> <span class="hljs-attribute">acceptCount</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">"20000"</span> <span class="hljs-attribute">URIEncoding</span>=<span class="hljs-string">"utf-8"</span>/&gt;</code></pre><p>经分析，发现线上没有body size的配置，却有<code>maxParameterCount=&quot;1000&quot;</code>。该参数为限制请求的参数个数，从而变相限制body size。</p><p>在开发环境配置该参数，测试，<strong>问题重现</strong>。</p><h2 id="3-解决"><a href="#3-解决" class="headerlink" title="3. 解决"></a>3. 解决</h2><p>问题原因定位好了，剩下的就是如何解决了。</p><p>两个方案：</p><ul><li><p>修改线上配置</p><p>  <em>该上实施难度系数高，因为公司使用的统一发布部署平台，开发人员无服务器操作权限。</em></p></li><li><p>修改代码</p><p>  <em>修改保存逻辑，分片存储</em></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题排查，需要先对整体有个把握，然后分析影响范围。不能钻牛角尖，采用西医“头疼医头”的方式。有可能最后结果还是要医头，但此时的医头已经是建立在中医的辩证主义上，对症下药。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring常用Annotation详解</title>
    <link href="/2018/01/26/spring-annotation/"/>
    <url>/2018/01/26/spring-annotation/</url>
    
    <content type="html"><![CDATA[<h1 id="Annotation介绍"><a href="#Annotation介绍" class="headerlink" title="Annotation介绍"></a>Annotation介绍</h1><hr><h1 id="Spring项目开发常用Annotation"><a href="#Spring项目开发常用Annotation" class="headerlink" title="Spring项目开发常用Annotation"></a>Spring项目开发常用Annotation</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>Resource 注释标记应用程序所需的资源。此注释可以应用于应用程序组件类，或者该组件类的字段或方法。如果将该注释应用于一个字段或方法，那么初始化应用程序组件时容器将把所请求资源的一个实例注入其中。如果将该注释应用于组件类，则该注释将声明一个应用程序在运行时将查找的资源。</p><p>即使此注释没有被标记为Inherited，部署工具仍然需要检查任意组件类的所有超类，以发现这些超类中所有使用此注释的地方。所有此类注释实例都指定了应用程序组件所需的资源。注意，此注释可能出现在超类的 private 字段和方法上；在这种情况下容器也需要执行注入操作。</p><p>在Spring中使用该注解，表示按name注入。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h3><p>此注解用于JavaBean的setter方法上，表示此属性是必须的，必须在配置阶段注入，否则会抛出<code>BeanInitializationException</code>。</p><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>此注解用于构造方法、字段、setter方法和注解类型。显示声明依赖，根据type来autowiring, 默认注入是必须的。</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Autowired &#123;<span class="hljs-comment">/** * Declares whether the annotated dependency is required. * &lt;p&gt;Defaults to &#123;<span class="hljs-doctag">@code</span> true&#125;. */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre><p>在构造方法上使用此注解时，需要注意的是，一个类只允许有一个构造方法使用此注解。==此外，在Spring4.3后，如果一个类仅仅只有一个构造方法，那么即使不使用此注解，spring也会自动注入相关的bean。==</p><pre><code class="hljs undefined"><span class="hljs-meta">@Componentpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Address address;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Address address)</span> </span>&#123;        <span class="hljs-keyword">this</span>.address=address;         &#125;&#125;&lt;bean id=<span class="hljs-string">"user"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"xx.User"</span>/&gt;</code></pre><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>此注解是和<code>@Autowired</code>一起使用的。使用此注解可以让你对注入的过程有更多的控制，用@Qulifier指定要绑定的bean的名称。当一个type有多个bean时，使用@Autowired的时候需要配合上@Qulifier才能正常。</p><pre><code class="hljs undefined"><span class="hljs-variable">@Componentpublic</span> class User &#123;    <span class="hljs-variable">@Autowired</span>        <span class="hljs-variable">@Qualifier</span>(<span class="hljs-string">"address1"</span>)        private Address address;        ...&#125;</code></pre><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>此注解一般和@Configuration注解一起使用，指定Spring扫描注解的package。如果没有指定包，那么默认会扫描此配置类所在的package。</p><pre><code class="hljs undefined"><span class="hljs-meta">@Configuartion</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringCoreConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> AdminUser <span class="hljs-title">adminUser</span><span class="hljs-params">()</span> </span>&#123;        AdminUser adminUser = <span class="hljs-keyword">new</span> AdminUser();        <span class="hljs-keyword">return</span> adminUser;        &#125;&#125;</code></pre><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>此注解使用在Spring的组件类上。默认的，Spring中Bean的依赖一开始就被创建和配置。如果想要延迟初始化一个bean，那么可以在此类上使用Lazy注解，表示此bean只有在第一次被使用的时候才会被创建和初始化。此注解也可以使用在被@Configuration注解的类上，表示其中所有被@Bean注解的方法都会延迟初始化。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>此注解使用在字段、构造器参数和方法参数上。@Value可以指定属性取值的表达式，支持通过#{}使用SpringEL来取值，也支持使用${}来将属性来源中(Properties文件呢、本地环境变量、系统属性等)的值注入到bean的属性中。此注解的注入时发生在AutowiredAnnotationBeanPostProcessor中。</p><h2 id="Stereotype注解"><a href="#Stereotype注解" class="headerlink" title="Stereotype注解"></a>Stereotype注解</h2><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>此注解使用在class上来声明一个Spring组件(Bean), 将其加入到应用上下文中。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>此注解使用在class上声明此类是一个Spring controller，是@Component注解的一种具体形式。</p><h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>此注解使用在class上，声明此类是一个服务类，执行业务逻辑、计算、调用内部api等。是@Component注解的一种具体形式。</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p>此类使用在class上声明此类用于访问数据库，一般作为DAO的角色。<br>此注解有自动翻译的特性，例如：当此种component抛出了一个异常，那么会有一个handler来处理此异常，无需使用try-catch块。</p><h2 id="Spring-Boot注解"><a href="#Spring-Boot注解" class="headerlink" title="Spring Boot注解"></a>Spring Boot注解</h2><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>此注解通常被用在主应用class上，告诉<code>Spring Boot</code> 自动基于当前包添加Bean、对bean的属性进行设置等。</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>此注解用在Spring Boot项目的应用主类上（此类需要在base package中）。使用了此注解的类首先会让Spring Boot启动对base package下以及其sub-pacakages的类进行component scan。</p><p>此注解同时添加了以下几个注解：</p><ul><li>@Configuration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h2 id="Spring-MVC和REST注解"><a href="#Spring-MVC和REST注解" class="headerlink" title="Spring MVC和REST注解"></a>Spring MVC和REST注解</h2><h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="@Controller"></a>@Controller</h3><p>上述已经提到过此注解。</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>此注解可以用在class和method上，用来映射web请求到某一个handler类或者handler方法上。当此注解用在Class上时，就创造了一个基础url，其所有的方法上的@RequestMapping都是在此url之上的。</p><p>可以使用其method属性来限制请求匹配的http method。</p><p>此外，Spring4.3之后引入了一系列@RequestMapping的变种。如下：c</p><ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@PatchMapping</li><li>@DeleteMapping</li></ul><p>分别对应了相应method的RequestMapping配置。</p><h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>此注解用在class和method上用来支持跨域请求，是Spring 4.2后引入的。</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">CrossOrigin</span>(maxAge = <span class="hljs-number">3600</span>)@<span class="hljs-selector-tag">RestController</span>@<span class="hljs-selector-tag">RequestMapping</span>(<span class="hljs-string">"/users"</span>)<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">AccountController</span> &#123;        <span class="hljs-variable">@CrossOrigin</span>(origins = <span class="hljs-string">"http://xx.com"</span>)    <span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)    public Result userLogin() &#123;        <span class="hljs-comment">// ...    </span>    &#125;&#125;</code></pre><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>此注解使用在方法级别，声明对Exception的处理逻辑。可以指定目标Exception。</p><h3 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a>@InitBinder</h3><p>此注解使用在方法上，声明对WebDataBinder的初始化(绑定请求参数到JavaBean上的DataBinder)。在controller上使用此注解可以自定义请求参数的绑定。</p><h3 id="MatrixVariable"><a href="#MatrixVariable" class="headerlink" title="@MatrixVariable"></a>@MatrixVariable</h3><p>此注解使用在请求handler方法的参数上，Spring可以注入matrix url中相关的值。这里的矩阵变量可以出现在url中的任何地方，变量之间用;分隔。如下：</p><pre><code class="hljs undefined"><span class="hljs-regexp">//</span> GET <span class="hljs-regexp">/pets/</span><span class="hljs-number">42</span>;q=<span class="hljs-number">11</span>;r=<span class="hljs-number">22</span>@RequestMapping(value = <span class="hljs-string">"/pets/&#123;petId&#125;"</span>)public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;    <span class="hljs-regexp">//</span> petId == <span class="hljs-number">42</span>    <span class="hljs-regexp">//</span> q == <span class="hljs-number">11</span>&#125;</code></pre><p>需要注意的是默认Spring mvc是不支持矩阵变量的，需要开启。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">enable-matrix-variables</span>=<span class="hljs-string">"true"</span> /&gt;</span></code></pre><p>注解配置则需要如下开启：</p><pre><code class="hljs undefined"><span class="hljs-meta">@Configurationpublic</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;     <span class="hljs-meta">@Override</span>    public void configurePathMatch(<span class="hljs-type">PathMatchConfigurer</span> configurer) &#123;        <span class="hljs-type">UrlPathHelper</span> urlPathHelper = <span class="hljs-keyword">new</span> <span class="hljs-type">UrlPathHelper</span>();        urlPathHelper.setRemoveSemicolonContent(<span class="hljs-literal">false</span>);        configurer.setUrlPathHelper(urlPathHelper);    &#125;&#125;</code></pre><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>此注解使用在请求handler方法的参数上。@RequestMapping可以定义动态路径，如:</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">RequestMapping</span>(<span class="hljs-string">"/users/&#123;uid&#125;"</span>)<span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">execute</span>(<span class="hljs-variable">@PathVariable</span>(<span class="hljs-string">"uid"</span>) String uid)&#123;&#125;</code></pre><h3 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a>@RequestAttribute</h3><p>此注解用在请求handler方法的参数上，用于将web请求中的属性(requst attributes，是服务器放入的属性值)绑定到方法参数上。</p><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>此注解用在请求handler方法的参数上，用于将http请求的Body映射绑定到此参数上。HttpMessageConverter负责将对象转换为http请求。</p><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>此注解用在请求handler方法的参数上，用于将http请求头部的值绑定到参数上。</p><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>此注解用在请求handler方法的参数上，用于将http请求参数的值绑定到参数上。</p><h3 id="RequestPart"><a href="#RequestPart" class="headerlink" title="@RequestPart"></a>@RequestPart</h3><p>此注解用在请求handler方法的参数上，用于将文件之类的multipart绑定到参数上。</p><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>此注解用在请求handler方法上。和@RequestBody作用类似，用于将方法的返回对象直接输出到http响应中。</p><h3 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h3><p>此注解用于方法和exception类上，声明此方法或者异常类返回的http状态码。可以在Controller上使用此注解，这样所有的@RequestMapping都会继承。</p><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>此注解用于class上。前面说过可以对每一个controller声明一个ExceptionMethod。这里可以使用@ControllerAdvice来声明一个类来统一对所有@RequestMapping方法来做@ExceptionHandler, @InitBinder, and @ModelAttribute处理。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>此注解用于class上，声明此controller返回的不是一个视图而是一个领域对象。其同时引入了@Controller and @ResponseBody两个注解。</p><h3 id="RestControllerAdvice"><a href="#RestControllerAdvice" class="headerlink" title="@RestControllerAdvice"></a>@RestControllerAdvice</h3><p>此注解用于class上，同时引入了@ControllerAdvice and @ResponseBody两个注解。</p><h3 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h3><p>此注解用于方法的参数上，用于将session中的属性绑定到参数。</p><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h3><p>此注解用于type级别，用于将JavaBean对象存储到session中。一般和@ModelAttribute注解一起使用。如下：</p><pre><code class="hljs undefined"><span class="hljs-variable">@ModelAttribute</span>(<span class="hljs-string">"user"</span>)public PUser getUser() &#123;&#125;<span class="hljs-comment">// controller和上面的代码在同一controller中</span><span class="hljs-variable">@Controller</span><span class="hljs-variable">@SessionAttributes</span>(value = <span class="hljs-string">"user"</span>, types = &#123;    User.class&#125;)public class UserController &#123;&#125;</code></pre><h2 id="数据访问注解"><a href="#数据访问注解" class="headerlink" title="数据访问注解"></a>数据访问注解</h2><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>此注解使用在接口定义、接口中的方法、类定义或者类中的public方法上。需要注意的是此注解并不激活事务行为，它仅仅是一个元数据，会被一些运行时基础设施来消费。</p><h2 id="任务执行、调度注解"><a href="#任务执行、调度注解" class="headerlink" title="任务执行、调度注解"></a>任务执行、调度注解</h2><h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h3><p>此注解使用在方法上，声明此方法被定时调度。使用了此注解的方法返回类型需要是Void，并且不能接受任何参数。</p><pre><code class="hljs undefined"><span class="hljs-variable">@Scheduled</span>(fixedDelay=<span class="hljs-number">1000</span>)public void schedule() &#123;&#125;<span class="hljs-variable">@Scheduled</span>(fixedRate=<span class="hljs-number">1000</span>)public void schedulg() &#123;&#125;</code></pre><p>第二个与第一个不同之处在于其不会等待上一次的任务执行结束。</p><h3 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h3><p>此注解使用在方法上，声明此方法会在一个单独的线程中执行。不同于Scheduled注解，此注解可以接受参数。<br>使用此注解的方法的返回类型可以是Void也可是返回值。但是返回值的类型必须是一个Future。</p><h2 id="测试注解"><a href="#测试注解" class="headerlink" title="测试注解"></a>测试注解</h2><h3 id="ContextConfiguration"><a href="#ContextConfiguration" class="headerlink" title="@ContextConfiguration"></a>@ContextConfiguration</h3><p>此注解使用在Class上，声明测试使用的配置文件，此外，也可以指定加载上下文的类。</p><p>此注解一般需要搭配SpringJUnit4ClassRunner使用。</p><pre><code class="hljs undefined"><span class="hljs-variable">@RunWith</span>(SpringJUnit4ClassRunner.class)<span class="hljs-variable">@ContextConfiguration</span>(classes = SpringCoreConfig.class)public class UserServiceTest &#123;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ文档</title>
    <link href="/2017/05/17/rocketmq-quickstart/"/>
    <url>/2017/05/17/rocketmq-quickstart/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://rocketmq.incubator.apache.org/docs/quick-start/" target="_blank" rel="noopener">官方文档</a></p></blockquote><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>安装以下软件：</p><ol><li>64位系统，推荐Linux/Unix/Mac</li><li>64位 JDK 1.7+</li><li>Maven 3.2.x</li><li>Git</li></ol><h1 id="克隆-amp-编译"><a href="#克隆-amp-编译" class="headerlink" title="克隆&amp;编译"></a>克隆&amp;编译</h1><pre><code class="hljs undefined"><span class="hljs-meta">&gt;</span><span class="bash"> git <span class="hljs-built_in">clone</span> -b develop https://github.com/apache/incubator-rocketmq.git</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> incubator-rocketmq</span><span class="hljs-meta">&gt;</span><span class="bash"> mvn -Prelease-all -DskipTests clean install -U</span><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-built_in">cd</span> distribution/target/apache-rocketmq</span></code></pre><h1 id="启动Name-Server"><a href="#启动Name-Server" class="headerlink" title="启动Name Server"></a>启动Name Server</h1><pre><code class="hljs undefined">&gt; nohup sh bin/mqnamesrv &amp;&gt; tail -f ~/logs/rocketmqlogs/namesrv.logThe Name<span class="hljs-built_in"> Server </span>boot success<span class="hljs-built_in">..</span>.</code></pre><h1 id="启动Broker"><a href="#启动Broker" class="headerlink" title="启动Broker"></a>启动Broker</h1><pre><code class="hljs undefined">&gt; nohup sh <span class="hljs-keyword">bin/mqbroker </span>-n localhost:<span class="hljs-number">9876</span> &amp;&gt; tail -f ~/logs/rocketmqlogs/<span class="hljs-keyword">broker.log</span><span class="hljs-symbol">The</span> <span class="hljs-keyword">broker[%s, </span><span class="hljs-number">172</span>.<span class="hljs-number">30</span>.<span class="hljs-number">30</span>.<span class="hljs-number">233</span>:<span class="hljs-number">10911</span>] <span class="hljs-keyword">boot </span>success...</code></pre><p>需要提供一个可以网络访问的ip。</p><h1 id="发送-amp-接受消息"><a href="#发送-amp-接受消息" class="headerlink" title="发送&amp;接受消息"></a>发送&amp;接受消息</h1><p>发送&amp;接受消息之前需要通过设置环境变量<code>NAMESRV_ADDR</code>，用于通知客户端需要访问的服务地址。</p><pre><code class="hljs undefined">&gt; <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">NAMESRV_ADDR</span>=localhost:9876&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.ProducerSendResult [<span class="hljs-attribute">sendStatus</span>=SEND_OK, msgId= <span class="hljs-built_in">..</span>.&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.ConsumerConsumeMessageThread_%d Receive New Messages: [MessageExt<span class="hljs-built_in">..</span>.</code></pre><h1 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h1><pre><code class="hljs undefined">&gt; <span class="hljs-keyword">sh </span><span class="hljs-keyword">bin/mqshutdown </span><span class="hljs-keyword">broker</span>The mqbroker(<span class="hljs-number">36695</span>) is running...Send <span class="hljs-keyword">shutdown </span>request to mqbroker(<span class="hljs-number">36695</span>) OK&gt; <span class="hljs-keyword">sh </span><span class="hljs-keyword">bin/mqshutdown </span>namesrvThe mqnamesrv(<span class="hljs-number">36664</span>) is running...Send <span class="hljs-keyword">shutdown </span>request to mqnamesrv(<span class="hljs-number">36664</span>) OK</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring主要组件</title>
    <link href="/2017/05/10/spring/"/>
    <url>/2017/05/10/spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring、Spring-Cloud主要组件"><a href="#Spring、Spring-Cloud主要组件" class="headerlink" title="Spring、Spring Cloud主要组件"></a>Spring、Spring Cloud主要组件</h1><h2 id="spring-顶级项目："><a href="#spring-顶级项目：" class="headerlink" title="spring 顶级项目："></a>spring 顶级项目：</h2><ul><li>Spring IO platform:用于系统部署，是可集成的，构建现代化应用的版本平台，具体来说当你使用maven dependency引入spring jar包时它就在工作了。</li><li>Spring Boot:旨在简化创建产品级的 Spring 应用和服务，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用微服务功能，可以和spring cloud联合部署。</li><li>Spring Framework:即通常所说的spring 框架，是一个开源的Java/Java EE全功能栈应用程序框架，其它spring项目如spring boot也依赖于此框架。</li><li>Spring Cloud：微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。</li><li>Spring XD：是一种运行时环境（服务器软件，非开发框架），组合spring技术，如spring batch、spring boot、spring data，采集大数据并处理。</li><li>Spring Data：是一个数据访问及操作的工具包，封装了很多种数据及数据库的访问相关技术，包括：jdbc、Redis、MongoDB、Neo4j等。</li><li>Spring Batch：批处理框架，或说是批量任务执行管理器，功能包括任务调度、日志记录/跟踪等。</li><li>Spring Security：是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。</li><li>Spring Integration：面向企业应用集成（EAI/ESB）的编程框架，支持的通信方式包括HTTP、FTP、TCP/UDP、JMS、RabbitMQ、Email等。</li><li>Spring Social：一组工具包，一组连接社交服务API，如Twitter、Facebook、LinkedIn、GitHub等，有几十个。</li><li>Spring AMQP：消息队列操作的工具包，主要是封装了RabbitMQ的操作。</li><li>Spring HATEOAS：是一个用于支持实现超文本驱动的 REST Web 服务的开发库。</li><li>Spring Mobile：是Spring MVC的扩展，用来简化手机上的Web应用开发。</li><li>Spring for Android：是Spring框架的一个扩展，其主要目的在乎简化Android本地应用的开发，提供RestTemplate来访问Rest服务。</li><li>Spring Web Flow：目标是成为管理Web应用页面流程的最佳方案，将页面跳转流程单独管理，并可配置。</li><li>Spring LDAP：是一个用于操作LDAP的Java工具包，基于Spring的JdbcTemplate模式，简化LDAP访问。</li><li>Spring Session：session管理的开发工具包，让你可以把session保存到redis等，进行集群化session管理。</li><li>Spring Web Services：是基于Spring的Web服务框架，提供SOAP服务开发，允许通过多种方式创建Web服务。</li><li>Spring Shell：提供交互式的Shell可让你使用简单的基于Spring的编程模型来开发命令，比如Spring Roo命令。</li><li>Spring Roo：是一种Spring开发的辅助工具，使用命令行操作来生成自动化项目，操作非常类似于Rails。</li><li>Spring Scala：为Scala语言编程提供的spring框架的封装（新的编程语言，Java平台的Scala于2003年底/2004年初发布）。</li><li>Spring BlazeDS Integration：一个开发RIA工具包，可以集成Adobe Flex、BlazeDS、Spring以及Java技术创建RIA。</li><li>Spring Loaded：用于实现java程序和web应用的热部署的开源工具。</li><li>Spring REST Shell：可以调用Rest服务的命令行工具，敲命令行操作Rest服务。</li></ul><h2 id="目前来说spring主要集中于spring-boot（用于开发微服务）和spring-cloud相关框架的开发，spring-cloud子项目包括："><a href="#目前来说spring主要集中于spring-boot（用于开发微服务）和spring-cloud相关框架的开发，spring-cloud子项目包括：" class="headerlink" title="目前来说spring主要集中于spring boot（用于开发微服务）和spring cloud相关框架的开发，spring cloud子项目包括："></a>目前来说spring主要集中于spring boot（用于开发微服务）和spring cloud相关框架的开发，spring cloud子项目包括：</h2><ul><li>Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。</li><li>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</li><li>Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。</li><li>Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。</li><li>Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</li><li>Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。</li><li>Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li><li>Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。</li><li>Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。</li><li>Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。</li><li>Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。</li><li>Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</li><li>Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。</li><li>Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</li><li>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keepalived 简单配置</title>
    <link href="/2017/04/21/keepalived/"/>
    <url>/2017/04/21/keepalived/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压文件</p><pre><code class="hljs bash">tar -xvf keepalived-x.x.x.tar.gz</code></pre><p>进入文件夹<code>keepalived-x.x.x</code></p><pre><code class="hljs undefined">./configure<span class="hljs-built_in">make</span> &amp;&amp; <span class="hljs-built_in">make</span> install</code></pre><p>在安装过程中需要注意以下几点：</p><ul><li>gcc环境</li><li>openssl环境</li><li>root权限</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code class="hljs bash"><span class="hljs-comment"># cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/</span><span class="hljs-comment"># cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</span><span class="hljs-comment"># mkdir /etc/keepalived  </span><span class="hljs-comment"># cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/</span><span class="hljs-comment"># cp /usr/local/sbin/keepalived /usr/sbin/</span></code></pre><p>做成系统启动服务方便管理.</p><pre><code class="hljs bash"><span class="hljs-comment"># vi /etc/rc.local   </span>/etc/init.d/keepalived start</code></pre><p>增加上面一行。</p><p>修改配置<code>/etc/keepalived/keepalived.conf</code></p><pre><code class="hljs config">! Configuation File for keepalivedglobal_defs &#123;    notification_email &#123;        acassen@firewall.loc    # 邮件地址，当异常时发邮件通知。可以是多个，每个一行    &#125;    notification_email_from Alexandre.Cassen@firewall.loc    smtp_server 192.168.200.1    smtp_connect_timeout 30    router_id LVS_DEVEL    vrrp_skip_check_adv_addr    vrrp_strict&#125;vrrp_instance VI_1 &#123;    state MASTER    # 从机设为BACKUP    interface   eth0   # 网卡接口    mcast_src_ip 10.0.0.131  # 默认没有这项，加上这项后服务好用了    priority  100  # 优先级，从机小与主机    advert_int 1      authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        10.0.0.111   # 虚拟ip设置，可以是多个，主从一致    &#125;&#125;</code></pre><blockquote><p>参考文档 <a href="http://wenku.baidu.com/view/8e38022d2af90242a895e532.html" target="_blank" rel="noopener">http://wenku.baidu.com/view/8e38022d2af90242a895e532.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Keepalived</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7使用firewalld打开关闭防火墙与端口</title>
    <link href="/2017/04/21/firewalld/"/>
    <url>/2017/04/21/firewalld/</url>
    
    <content type="html"><![CDATA[<p>1、firewalld的基本使用</p><p>启动： systemctl start firewalld</p><p>查看状态： systemctl status firewalld</p><p>停止： systemctl disable firewalld</p><p>禁用： systemctl stop firewalld</p><p>2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p><p>启动一个服务：systemctl start firewalld.service</p><p>关闭一个服务：systemctl stop firewalld.service</p><p>重启一个服务：systemctl restart firewalld.service</p><p>显示一个服务的状态：systemctl status firewalld.service</p><p>在开机时启用一个服务：systemctl enable firewalld.service</p><p>在开机时禁用一个服务：systemctl disable firewalld.service</p><p>查看服务是否开机启动：systemctl is-enabled firewalld.service</p><p>查看已启动的服务列表：systemctl list-unit-files|grep enabled</p><p>查看启动失败的服务列表：systemctl –failed</p><p>3.配置firewalld-cmd</p><p>查看版本： firewall-cmd –version</p><p>查看帮助： firewall-cmd –help</p><p>显示状态： firewall-cmd –state</p><p>查看所有打开的端口： firewall-cmd<br>–zone=public –list-ports</p><p>更新防火墙规则： firewall-cmd –reload</p><p>查看区域信息:  firewall-cmd<br>–get-active-zones</p><p>查看指定接口所属区域： firewall-cmd<br>–get-zone-of-interface=eth0</p><p>拒绝所有包：firewall-cmd –panic-on</p><p>取消拒绝状态： firewall-cmd –panic-off</p><p>查看是否拒绝： firewall-cmd –query-panic</p><p>那怎么开启一个端口呢<br>添加</p><p>firewall-cmd –zone=public<br>–add-port=80/tcp –permanent<br>（–permanent永久生效，没有此参数重启后失<br>效）</p><p>重新载入</p><p>firewall-cmd –reload</p><p>查看</p><p>firewall-cmd –zone= public<br>–query-port=80/tcp</p><p>删除</p><p>firewall-cmd –zone= public<br>–remove-port=80/tcp –permanent</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java系列  - JDK环境配置</title>
    <link href="/2017/04/21/jdk-profile/"/>
    <url>/2017/04/21/jdk-profile/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>打开<code>/etc/profile</code>, 添加如下代码：</p><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/opt/jdk<span class="hljs-built_in">export</span> JRE_HOME=<span class="hljs-variable">$JAVA_HOME</span>/jre<span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib:<span class="hljs-variable">$JRE_HOME</span>/lib<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span></code></pre><p>执行代码，使配置生效</p><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile</code></pre><p>安装命令 <strong>需要root权限</strong></p><pre><code class="hljs bash">alternatives --install /usr/bin/java java /opt/jdk/bin/java 1600alternatives --install /usr/bin/javac javac /opt/jdk/bin/javac 1600</code></pre><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><blockquote><p>windows下，path路径以<code>;</code>分割，bat变量<code>%JAVA_HOME%</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript编程规范</title>
    <link href="/2017/04/21/javascript-rule/"/>
    <url>/2017/04/21/javascript-rule/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JavaScript是一种客户端脚本语言，Web工程都会用到它，这份指南列出了编写JavaScript时需要遵守的规则。</p><h2 id="JavaScript语言规范"><a href="#JavaScript语言规范" class="headerlink" title="JavaScript语言规范"></a>JavaScript语言规范</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明变量必须加上var<br>关键字:</p><pre><code class="hljs undefined">var a1 = <span class="hljs-number">1</span><span class="hljs-comment">;</span>var b1 = <span class="hljs-number">11</span><span class="hljs-comment">;</span></code></pre><p>当你没有写var<br>，变量就会暴露在全局上下文中，这样很可能会和现有的变量冲突。另外，如果没有加上，很难明确该变量的作用域是什么，变量很可能在局部作用域中，很容易泄漏到Document或者Window中，所以务必用var<br>变量。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的形式如：<code>NAMES_LIKE_THIS</code>，即使用大写字符，并用下划线分割，你也可用<code>@const</code>标记来指明它是一个常量，但请不要使用<code>const</code>关键字。<br>对于基本类型的常量，只需要转换命名：</p><pre><code class="hljs undefined"><span class="hljs-comment">/** * The number of seconds of minute. * @type &#123;number&#125; */</span>eflag.example.SECONDES_IN_<span class="hljs-built_in">A_MINUTE</span> = <span class="hljs-number">60</span><span class="hljs-comment">;</span></code></pre><p>对于非基本类型，使用<code>@const</code><br>标记：</p><pre><code class="hljs undefined"><span class="hljs-comment">/** * The number of seconds in each of the given units. * <span class="hljs-doctag">@type</span> &#123;Object.&lt;number&gt;&#125; * <span class="hljs-doctag">@const</span> */</span>eflag.example.SECONDS_TABLE = &#123;<span class="hljs-string">minute:</span> <span class="hljs-number">60</span>,<span class="hljs-string">hour:</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span>,<span class="hljs-string">day:</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>&#125;</code></pre><p>至于关键字<code>const</code>，因为IE不能识别，所以不要使用。</p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>总是使用分号。 如果仅依靠语句间的隐式分割，有时会很麻烦，使用分号，你自己更能清楚那里是语句的起止。<br>行末分号：</p><pre><code class="hljs undefined"><span class="hljs-string">var</span> <span class="hljs-string">foo</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">,bar</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">,baz</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span><span class="hljs-string">var</span> <span class="hljs-string">obj</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;foo:</span> <span class="hljs-number">1</span><span class="hljs-string">,bar:</span> <span class="hljs-number">2</span><span class="hljs-string">,baz:</span> <span class="hljs-number">3</span><span class="hljs-string">&#125;;</span></code></pre><h3 id="单引号-39-39-和双引号-quot-quot"><a href="#单引号-39-39-和双引号-quot-quot" class="headerlink" title="单引号(&#39;&#39;)和双引号(&quot;&quot;)"></a>单引号(<code>&#39;&#39;</code>)和双引号(<code>&quot;&quot;</code>)</h3><p>由于JavaScript对于单引号和双引号都可以识别为字符串，但为了统一规范，所以在JavaScript中字符串的定义要求使用单引号：</p><pre><code class="hljs undefined"><span class="hljs-attribute">var val</span> = <span class="hljs-string">'a'</span>;</code></pre><p>同样，html中属性使用的是双引号：</p><pre><code class="hljs undefined">&lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"text"</span>&gt;</code></pre><p>在JavaScript中动态生成html标签时：</p><pre><code class="hljs undefined"><span class="hljs-keyword">var</span> <span class="hljs-number">_</span><span class="hljs-keyword">input</span> = '&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span>&gt;';</code></pre><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>参数和括号间五空格：</p><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(arg1, arg2)</span></span>&#123;&#125;</code></pre><p>冒号后面有空格</p><pre><code class="hljs undefined">&#123;<span class="hljs-attribute">foo</span>: <span class="hljs-number">1</span>,bar: <span class="hljs-number">2</span>,baz: <span class="hljs-number">3</span>&#125;</code></pre><p>条件语句有空格</p><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;&#125;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125;<span class="hljs-keyword">switch</span>(v)&#123;&#125;</code></pre><h3 id="Tips-and-Tricks"><a href="#Tips-and-Tricks" class="headerlink" title="Tips and Tricks"></a>Tips and Tricks</h3><h3 id="True和False布尔表达式"><a href="#True和False布尔表达式" class="headerlink" title="True和False布尔表达式"></a>True和False布尔表达式</h3><p>下面的布尔表达式都会返回<code>false</code>：</p><pre><code class="hljs undefined"><span class="hljs-literal">null</span><span class="hljs-literal">undefined</span><span class="hljs-string">''</span>空字符串<span class="hljs-number">0</span></code></pre><p>数字<code>0</code> 但小心下面的，可都返回<code>true</code>：</p><pre><code class="hljs undefined"><span class="hljs-string">'0'</span>字符串<span class="hljs-number">0</span>[<span class="hljs-meta"></span>]空数组&#123;&#125;空对象</code></pre><p>如果你想检查字符串是否为<code>null</code>或<code>空</code>：</p><pre><code class="hljs undefined">if (y != null &amp;&amp; y != <span class="hljs-string">''</span>) &#123;&#125;</code></pre><p>写成这样会更好：</p><pre><code class="hljs undefined"><span class="hljs-selector-tag">if</span> (<span class="hljs-selector-tag">y</span>) &#123;&#125;</code></pre><h3 id="条件（三元）操作符"><a href="#条件（三元）操作符" class="headerlink" title="条件（三元）操作符(?:)"></a>条件（三元）操作符(<code>?:</code>)</h3><p>三元操作符用于替代下面的代码：</p><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span> != <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">return</span> foo();&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">return</span> bar();&#125;</code></pre><p>你可以写成：</p><pre><code class="hljs undefined"><span class="hljs-keyword">return</span> <span class="hljs-keyword">val</span> ? foo() : bar();</code></pre><p>在生成HTML代码时也是很有用的：</p><pre><code class="hljs undefined">var html = <span class="hljs-string">'&lt;input type="</span>checkbox<span class="hljs-string">"'</span> + (isChecked ? <span class="hljs-string">' checked'</span> : <span class="hljs-string">''</span>)+ (isEnabled ? <span class="hljs-string">''</span> : <span class="hljs-string">' disabled'</span>)+ <span class="hljs-string">' name="</span>foo<span class="hljs-string">"&gt;'</span>;</code></pre><h3 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp;和||"></a><code>&amp;&amp;</code>和<code>||</code></h3><p>二元布尔操作符是可短路的，只有在必要的时候才会计算到最后一项。 <code>||</code>被称作为<code>default</code>操作符，因为可以这样：</p><pre><code class="hljs undefined"><span class="hljs-comment">/** * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*=&#125;</span> <span class="hljs-variable">opt_win</span></span> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">opt_win</span>) </span>&#123;  <span class="hljs-keyword">var</span> win;  <span class="hljs-keyword">if</span> (opt_win) &#123;    win = opt_win;  &#125; <span class="hljs-keyword">else</span> &#123;    win = <span class="hljs-built_in">window</span>;  &#125;<span class="hljs-comment">// ...</span>&#125;</code></pre><p>你可以使用它来简化上面的代码：</p><pre><code class="hljs undefined"><span class="hljs-comment">/** * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*=&#125;</span> <span class="hljs-variable">opt_win</span></span> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">opt_win</span>) </span>&#123;  <span class="hljs-keyword">var</span> win = opt_win || <span class="hljs-built_in">window</span>;  <span class="hljs-comment">// ...</span>&#125;</code></pre><h3 id="使用join-来创建字符串"><a href="#使用join-来创建字符串" class="headerlink" title="使用join()来创建字符串"></a>使用<code>join()</code>来创建字符串</h3><p>通常是这样使用的：</p><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listHtml</span><span class="hljs-params">(items)</span> &#123;</span>  var html = <span class="hljs-string">'&lt;div class="foo"'</span>;  <span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; items.<span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">i</span> &gt; <span class="hljs-number">0</span>) &#123;      html += <span class="hljs-string">','</span>;    &#125;    html += itemHtml(items[<span class="hljs-built_in">i</span>]);  &#125;  html += <span class="hljs-string">'&lt;/div&gt;'</span>;  <span class="hljs-keyword">return</span> html;&#125;</code></pre><p>但这样在IE下非常慢，可以用下面的方式：</p><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listHtml</span><span class="hljs-params">(items)</span> &#123;</span>  var html = [];  <span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; items.<span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) &#123;    html[<span class="hljs-built_in">i</span>] = itemHtml(items[<span class="hljs-built_in">i</span>]);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div class="foo"&gt;'</span> + html.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'&lt;/div&gt;'</span>;&#125;</code></pre><p>你也可以使用数组作为字符串构造器，然后通过<code>myArray.join(&#39;&#39;)</code><br>转换成字符串，不过由于赋值操作快于数组的<code>push()</code>，所以尽量使用复制操作。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用系统命令</title>
    <link href="/2017/04/21/linux-command/"/>
    <url>/2017/04/21/linux-command/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs bash"><span class="hljs-comment"># uname -a # 查看内核/操作系统/CPU信息 </span><span class="hljs-comment"># head -n 1 /etc/issue # 查看操作系统版本 </span><span class="hljs-comment"># cat /proc/cpuinfo # 查看CPU信息 </span><span class="hljs-comment"># hostname # 查看计算机名 </span><span class="hljs-comment"># lspci -tv # 列出所有PCI设备 </span><span class="hljs-comment"># lsusb -tv # 列出所有USB设备 </span><span class="hljs-comment"># lsmod # 列出加载的内核模块 </span><span class="hljs-comment"># env # 查看环境变量资源 </span><span class="hljs-comment"># free -m # 查看内存使用量和交换区使用量 </span><span class="hljs-comment"># df -h # 查看各分区使用情况 </span><span class="hljs-comment"># du -sh &lt;目录名&gt; # 查看指定目录的大小 </span><span class="hljs-comment"># grep MemTotal /proc/meminfo # 查看内存总量 </span><span class="hljs-comment"># grep MemFree /proc/meminfo # 查看空闲内存量 </span><span class="hljs-comment"># uptime # 查看系统运行时间、用户数、负载 </span><span class="hljs-comment"># cat /proc/loadavg # 查看系统负载磁盘和分区 </span><span class="hljs-comment"># mount | column -t # 查看挂接的分区状态 </span><span class="hljs-comment"># fdisk -l # 查看所有分区 </span><span class="hljs-comment"># swapon -s # 查看所有交换分区 </span><span class="hljs-comment"># hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) </span><span class="hljs-comment"># dmesg | grep IDE # 查看启动时IDE设备检测状况网络 </span><span class="hljs-comment"># ifconfig # 查看所有网络接口的属性 </span><span class="hljs-comment"># iptables -L # 查看防火墙设置 </span><span class="hljs-comment"># route -n # 查看路由表 </span><span class="hljs-comment"># netstat -lntp # 查看所有监听端口 </span><span class="hljs-comment"># netstat -antp # 查看所有已经建立的连接 </span><span class="hljs-comment"># netstat -s # 查看网络统计信息进程 </span><span class="hljs-comment"># ps -ef # 查看所有进程 </span><span class="hljs-comment"># top # 实时显示进程状态用户 </span><span class="hljs-comment"># w # 查看活动用户 </span><span class="hljs-comment"># id &lt;用户名&gt; # 查看指定用户信息 </span><span class="hljs-comment"># last # 查看用户登录日志 </span><span class="hljs-comment"># cut -d: -f1 /etc/passwd # 查看系统所有用户 </span><span class="hljs-comment"># cut -d: -f1 /etc/group # 查看系统所有组 </span><span class="hljs-comment"># crontab -l # 查看当前用户的计划任务服务 </span><span class="hljs-comment"># chkconfig –list # 列出所有系统服务 </span><span class="hljs-comment"># chkconfig –list | grep on # 列出所有启动的系统服务程序 </span><span class="hljs-comment"># rpm -qa # 查看所有安装的软件包</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量配置</title>
    <link href="/2017/04/21/linux-profile/"/>
    <url>/2017/04/21/linux-profile/</url>
    
    <content type="html"><![CDATA[<p>不论使用Linux开发，还是使用Linux生产，都不可避免环境变量的配置。通常都是去修改系统文件：<code>/etc/profile</code>, <code>/etc/enviroment</code>, <code>~/.bashrc</code>, <code>~/.profile</code>等等，在这些文件的末尾<code>export</code>上自己想要添加的环境变量，<code>source</code>一下该文件，配置就立刻生效了。</p><p>今天通过阅读<code>/etc/profile</code>文件：</p><pre><code class="hljs bash"><span class="hljs-comment"># /etc/profile: system-wide .profile file for the Bourne shell (sh(1))</span><span class="hljs-comment"># and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"`id -u`"</span> -eq 0 ]; <span class="hljs-keyword">then</span>  PATH=<span class="hljs-string">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span><span class="hljs-keyword">else</span>  PATH=<span class="hljs-string">"/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">export</span> PATH<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$PS1</span>"</span> ]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$BASH</span>"</span> ] &amp;&amp; [ <span class="hljs-string">"<span class="hljs-variable">$BASH</span>"</span> != <span class="hljs-string">"/bin/sh"</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-comment"># The file bash.bashrc already sets the default PS1.</span>    <span class="hljs-comment"># PS1='\h:\w\$ '</span>    <span class="hljs-keyword">if</span> [ -f /etc/bash.bashrc ]; <span class="hljs-keyword">then</span>      . /etc/bash.bashrc    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">else</span>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"`id -u`"</span> -eq 0 ]; <span class="hljs-keyword">then</span>      PS1=<span class="hljs-string">'# '</span>    <span class="hljs-keyword">else</span>      PS1=<span class="hljs-string">'$ '</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [ -d /etc/profile.d ]; <span class="hljs-keyword">then</span>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> /etc/profile.d/*.sh; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> [ -r <span class="hljs-variable">$i</span> ]; <span class="hljs-keyword">then</span>      . <span class="hljs-variable">$i</span>    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-built_in">unset</span> i<span class="hljs-keyword">fi</span></code></pre><p>发现最后一个<code>for</code>循环，其作用是搜用<code>/etc/profile.d</code>下的所有的<code>.sh</code>结尾的可执行文件，并运行。<br>因此，我们就可以根据不同的功能编写不同的可执行文件，将他们放到<code>/etc/profile.d</code>下，如<code>jdk.sh</code>，<code>ant.sh</code>，<code>maven.sh</code>等等。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL修改root密码的多种方法</title>
    <link href="/2017/04/21/mysql-password/"/>
    <url>/2017/04/21/mysql-password/</url>
    
    <content type="html"><![CDATA[<p>方法1： 用SET PASSWORD命令</p><pre><code class="hljs undefined">　　mysql -u root　　mysql&gt; <span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-comment">FOR</span> <span class="hljs-comment">'root'</span><span class="hljs-comment">@</span><span class="hljs-comment">'localhost'</span><span class="hljs-comment"> = PASSWORD(</span><span class="hljs-comment">'newpass'</span><span class="hljs-comment">)</span>;</code></pre><p>方法2：用mysqladmin</p><pre><code class="hljs undefined">　　mysqladmin -u<span class="hljs-built_in"> root</span> password <span class="hljs-string">"newpass"</span>　　如<span class="hljs-built_in">果root</span>已经设置过密码，采用如下方法　　mysqladmin -u<span class="hljs-built_in"> root</span> password oldpass <span class="hljs-string">"newpass"</span></code></pre><p>方法3： 用UPDATE直接编辑user表</p><pre><code class="hljs undefined">　　mysql -u root　　mysql&gt; use mysql;　　mysql&gt; UPDATE<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">SET</span> Password = PASSWORD(<span class="hljs-string">'newpass'</span>) WHERE<span class="hljs-built_in"> user </span>= <span class="hljs-string">'root'</span>;　　mysql&gt; FLUSH PRIVILEGES;</code></pre><p>在丢失root密码的时候，可以这样</p><pre><code class="hljs undefined">　　mysqld_safe --skip-grant-tables&amp;　　mysql -u root mysql　　mysql&gt; UPDATE<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">SET</span> <span class="hljs-attribute">password</span>=PASSWORD("new password<span class="hljs-string">") WHERE user='root';　　mysql&gt; FLUSH PRIVILEGES;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bootstrap模态框使WebUploader点击失效问题解决</title>
    <link href="/2017/04/21/webupload/"/>
    <url>/2017/04/21/webupload/</url>
    
    <content type="html"><![CDATA[<p>在使用Bootstrap模态框页面上使用上传组件WebUploader，发现点击失效。</p><p>解决方法：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> uploader;<span class="hljs-comment">//在点击弹出模态框的时候再初始化WebUploader，解决点击上传无反应问题</span>$(<span class="hljs-string">"#myModal"</span>).on(<span class="hljs-string">"shown.bs.modal"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    uploader = WebUploader.create(&#123;        <span class="hljs-attr">swf</span> : <span class="hljs-string">'/web/public/Uploader.swf'</span>,        <span class="hljs-attr">server</span> : $(<span class="hljs-string">"#jumicontextPath"</span>).val()+<span class="hljs-string">'/common/file/upload'</span>,<span class="hljs-comment">// 后台路径</span>        <span class="hljs-attr">pick</span> : <span class="hljs-string">'#filePicker'</span>, <span class="hljs-comment">// 选择文件的按钮。可选。内部根据当前运行是创建，可能是input元素，也可能是flash.</span>        <span class="hljs-attr">resize</span> : <span class="hljs-literal">false</span>,<span class="hljs-comment">// 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！</span>        <span class="hljs-attr">chunked</span> : <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否分片</span>        <span class="hljs-attr">duplicate</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//去重， 根据文件名字、文件大小和最后修改时间来生成hash Key.</span>        <span class="hljs-attr">chunkSize</span> : <span class="hljs-number">52428</span> * <span class="hljs-number">100</span>, <span class="hljs-comment">// 分片大小， 5M</span>        <span class="hljs-comment">/*    fileSingleSizeLimit:100*1024,//文件大小限制*/</span>        <span class="hljs-attr">auto</span> : <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 只允许选择图片文件。</span>        <span class="hljs-attr">accept</span>: &#123;            <span class="hljs-attr">title</span>: <span class="hljs-string">'Images'</span>,            <span class="hljs-attr">extensions</span>: <span class="hljs-string">'gif,jpg,jpeg,bmp,png'</span>,            <span class="hljs-attr">mimeTypes</span>: <span class="hljs-string">'image/jpg,image/jpeg,image/png'</span>        &#125;    &#125;);    <span class="hljs-comment">// 文件上传成功，给item添加成功class, 用样式标记上传成功。</span>    uploader.on(<span class="hljs-string">'uploadSuccess'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file,response</span>) </span>&#123;        <span class="hljs-keyword">var</span> fileUrl = response.data.fileUrl;        <span class="hljs-comment">//TODO</span>        $(<span class="hljs-string">"#responeseText"</span>).text(<span class="hljs-string">"上传成功,文件名："</span>+response.data.fileName);    &#125;);    <span class="hljs-comment">// 当文件上传出错时触发</span>    uploader.on(<span class="hljs-string">'uploadError'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>&#123;        $(<span class="hljs-string">"#responeseText"</span>).text(<span class="hljs-string">"上传失败"</span>);    &#125;);    <span class="hljs-comment">//当validate不通过时触发</span>    uploader.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>&#123;        <span class="hljs-keyword">if</span>(type==<span class="hljs-string">"F_EXCEED_SIZE"</span>)&#123;            alert(<span class="hljs-string">"文件大小不能超过xxx KB!"</span>);        &#125;    &#125;);&#125;);</code></pre><p>单单这样也会有问题，这样每次弹出模态框之后都加载一个边框，使按钮越来越大，所以需要在关闭模态框后销毁webuploader</p><pre><code class="hljs javascript"><span class="hljs-comment">//关闭模态框销毁WebUploader，解决再次打开模态框时按钮越变越大问题</span>$(<span class="hljs-string">'#myModal'</span>).on(<span class="hljs-string">'hide.bs.modal'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    $(<span class="hljs-string">"#responeseText"</span>).text(<span class="hljs-string">""</span>);    uploader.destroy();&#125;);</code></pre><hr><table><thead><tr><th align="left">事件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">show.bs.modal</td><td align="left">在调用 show 方法后触发。</td></tr><tr><td align="left">shown.bs.modal</td><td align="left">当模态框对用户可见时触发（将等待 CSS 过渡效果完成）。</td></tr><tr><td align="left">hide.bs.modal</td><td align="left">当调用 hide 实例方法时触发。</td></tr><tr><td align="left">hidden.bs.modal</td><td align="left">当模态框完全对用户隐藏时触发。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bootstrap</tag>
      
      <tag>webuploader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Logback配置文件</title>
    <link href="/2017/04/21/logback-xml/"/>
    <url>/2017/04/21/logback-xml/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-comment">&lt;!-- 定义变量 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_HOME"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/mnt/raid5/log/web"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_DEBUG_HOME"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/debug"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_INFO_HOME"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/info"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_WARN_HOME"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/warn"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"LOG_ERROR_HOME"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;LOG_HOME&#125;/error"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"STDOUT"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><span class="hljs-comment">&lt;!-- 日志输出编码 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">Encoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><span class="hljs-comment">&lt;!-- 格式化输出: %d表示日期, %thread表示线程名, %-5level:级别从左显示5个字符宽度, %msg:日志消息, %n换行符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] %level [%thread] %logger&#123;36&#125; %X&#123;medic.eventCode&#125; %msg %ex%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-comment">&lt;!-- DEBUG输出 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_DEBUG"</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_DEBUG_HOME&#125;/debug.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">Encoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><span class="hljs-comment">&lt;!-- 日志文件输出的文件名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_DEBUG_HOME&#125;/debug.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><span class="hljs-comment">&lt;!-- 格式化输出: %d表示日期, %thread表示线程名, %-5level:级别从左显示5个字符宽度, %msg:日志消息, %n换行符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] %level [%thread] %logger&#123;36&#125; %X&#123;medic.eventCode&#125; %msg %ex%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><span class="hljs-comment">&lt;!--日志文件最大的大小 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><span class="hljs-comment">&lt;!-- &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;&lt;level&gt;DEBUG&lt;/level&gt;&lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;&lt;onMismatch&gt;DENY&lt;/onMismatch&gt;&lt;/filter&gt; --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-comment">&lt;!-- INFO输出 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_INFO"</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_INFO_HOME&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">Encoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><span class="hljs-comment">&lt;!-- 日志文件输出的文件名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_INFO_HOME&#125;/info.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><span class="hljs-comment">&lt;!-- 格式化输出: %d表示日期, %thread表示线程名, %-5level:级别从左显示5个字符宽度, %msg:日志消息, %n换行符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] %level [%thread] %logger&#123;36&#125; %X&#123;medic.eventCode&#125; %msg %ex%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><span class="hljs-comment">&lt;!--日志文件最大的大小 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-comment">&lt;!-- WARN输出 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_WARN"</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_WARN_HOME&#125;/warn.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">Encoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><span class="hljs-comment">&lt;!-- 日志文件输出的文件名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_WARN_HOME&#125;/warn.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><span class="hljs-comment">&lt;!-- 格式化输出: %d表示日期, %thread表示线程名, %-5level:级别从左显示5个字符宽度, %msg:日志消息, %n换行符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] %level [%thread] %logger&#123;36&#125; %X&#123;medic.eventCode&#125; %msg %ex%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><span class="hljs-comment">&lt;!--日志文件最大的大小 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-comment">&lt;!-- ERROR输出 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FILE_ERROR"</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_ERROR_HOME&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">Encoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span><span class="hljs-comment">&lt;!-- 日志文件输出的文件名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_ERROR_HOME&#125;/error.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><span class="hljs-comment">&lt;!-- 格式化输出: %d表示日期, %thread表示线程名, %-5level:级别从左显示5个字符宽度, %msg:日志消息, %n换行符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] %level [%thread] %logger&#123;36&#125; %X&#123;medic.eventCode&#125; %msg %ex%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><span class="hljs-comment">&lt;!--日志文件最大的大小 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span><span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>100MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"DEBUG"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"STDOUT"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"FILE_DEBUG"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"FILE_INFO"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"FILE_WARN"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"FILE_ERROR"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Squid 代理服务器配置</title>
    <link href="/2017/04/21/squid/"/>
    <url>/2017/04/21/squid/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs shell">yum -y install squid</code></pre><p>安装<code>Mysql</code></p><pre><code class="hljs undefined">yum <span class="hljs-keyword">install </span>perl-<span class="hljs-keyword">ExtUtils-CBuilder </span>perl-<span class="hljs-keyword">ExtUtils-MakeMaker </span>-y</code></pre><p>安装<code>DBI-1.636.tar.gz</code></p><pre><code class="hljs undefined">wget http://<span class="hljs-built_in">search</span>.cpan.org/CPAN/authors/id/T/TI/TIMB/DBI-<span class="hljs-number">1.636</span>.tar.gztar -xvf DBI-<span class="hljs-number">1.636</span>.tar.gz<span class="hljs-keyword">cd</span> DBI-<span class="hljs-number">1.636</span><span class="hljs-keyword">make</span><span class="hljs-keyword">make</span> install</code></pre><p>安装 <code>DBD-mysql-4.039.tar.gz</code> 时，需要设置</p><pre><code class="hljs undefined">wget http:<span class="hljs-comment">//www.cpan.org/authors/id/C/CA/CAPTTOFU/DBD-mysql-4.039.tar.gz</span>tar -xvf DBD-mysql-<span class="hljs-number">4.039</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>cd DBD-mysql-<span class="hljs-number">4.039</span>perl Makefile<span class="hljs-selector-class">.PL</span> --mysql_config=/usr/bin/mysql_configmakemake install</code></pre><p><em>配置文件 <code>squid.conf</code></em></p><pre><code class="hljs undefined"><span class="hljs-comment">#auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd</span>auth_param basic program /usr/lib64/squid/basic_db_auth --user root --password mysql2016 --plaintext --persistauth_param basic children 5auth_param basic realm Squid proxy-caching web<span class="hljs-built_in"> server</span>auth_param basic credentialsttl 2 hoursacl normal proxy_auth REQUIREDhttp_access allow normal<span class="hljs-comment">#</span><span class="hljs-comment"># Recommended minimum configuration:</span><span class="hljs-comment">#</span><span class="hljs-comment"># Example rule allowing access from your local networks.</span><span class="hljs-comment"># Adapt to list your (internal) IP networks from where browsing</span><span class="hljs-comment"># should be allowed</span>acl localnet src 10.0.0.0/8     # RFC1918 possible internal<span class="hljs-built_in"> network</span>acl localnet src 172.16.0.0/12  # RFC1918 possible internal<span class="hljs-built_in"> network</span>acl localnet src 192.168.0.0/16 # RFC1918 possible internal<span class="hljs-built_in"> network</span>acl localnet src fc00::/7       # RFC 4193 local private<span class="hljs-built_in"> network </span>rangeacl localnet src fe80::/10      # RFC 4291 link-local (directly plugged) machinesacl SSL_ports<span class="hljs-built_in"> port </span>443acl Safe_ports<span class="hljs-built_in"> port </span>80          # httpacl Safe_ports<span class="hljs-built_in"> port </span>21          # ftpacl Safe_ports<span class="hljs-built_in"> port </span>443         # httpsacl Safe_ports<span class="hljs-built_in"> port </span>70          # gopheracl Safe_ports<span class="hljs-built_in"> port </span>210         # waisacl Safe_ports<span class="hljs-built_in"> port </span>1025-65535  # unregistered portsacl Safe_ports<span class="hljs-built_in"> port </span>280         # http-mgmtacl Safe_ports<span class="hljs-built_in"> port </span>488         # gss-httpacl Safe_ports<span class="hljs-built_in"> port </span>591         # filemakeracl Safe_ports<span class="hljs-built_in"> port </span>777         # multiling httpacl CONNECT method CONNECT<span class="hljs-comment">#</span><span class="hljs-comment"># Recommended minimum Access Permission configuration:</span><span class="hljs-comment">#</span><span class="hljs-comment"># Deny requests to certain unsafe ports</span>http_access deny !Safe_ports<span class="hljs-comment"># Deny CONNECT to other than secure SSL ports</span>http_access deny CONNECT !SSL_ports<span class="hljs-comment"># Only allow cachemgr access from localhost</span>http_access allow localhost managerhttp_access deny manager<span class="hljs-comment"># We strongly recommend the following be uncommented to protect innocent</span><span class="hljs-comment"># web applications running on the proxy server who think the only</span><span class="hljs-comment"># one who can access services on "localhost" is a local user</span><span class="hljs-comment">#http_access deny to_localhost</span><span class="hljs-comment">#</span><span class="hljs-comment"># INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS</span><span class="hljs-comment">#</span><span class="hljs-comment"># Example rule allowing access from your local networks.</span><span class="hljs-comment"># Adapt localnet in the ACL section to list your (internal) IP networks</span><span class="hljs-comment"># from where browsing should be allowed</span>http_access allow localnethttp_access allow localhost<span class="hljs-comment"># And finally deny all other access to this proxy</span>http_access allow all<span class="hljs-comment"># Squid normally listens to port 3128</span>http_port 3128<span class="hljs-comment"># Uncomment and adjust the following to add a disk cache directory.</span><span class="hljs-comment"># Uncomment and adjust the following to add a disk cache directory.</span><span class="hljs-comment">#cache_dir ufs /var/spool/squid 100 16 256</span><span class="hljs-comment"># Leave coredumps in the first cache dir</span>coredump_dir /var/spool/squid<span class="hljs-comment">#</span><span class="hljs-comment"># Add any of your own refresh_pattern entries above these.</span><span class="hljs-comment">#</span>refresh_pattern ^ftp:           1440    20%     10080refresh_pattern ^gopher:        1440    0%      1440refresh_pattern -i (/cgi-bin/|\?) 0     0%      0refresh_pattern .               0       20%     4320<span class="hljs-comment">#auth_param basic program /usr/lib64/squid/ncsa_auth /etc/squid/passwd</span><span class="hljs-comment">#auth_param basic children 5        </span><span class="hljs-comment">#auth_param basic credentialsttl 1 hours    </span><span class="hljs-comment">#auth_param basic realm my test prosy         </span><span class="hljs-comment">#acl test123 proxy_auth REQUIRED  </span><span class="hljs-comment">#http_access allow test123    </span><span class="hljs-comment">#auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd</span><span class="hljs-comment">#auth_param basic children 5</span><span class="hljs-comment">#auth_param basic realm Squid proxy-caching web server</span><span class="hljs-comment">#auth_param basic credentialsttl 2 hours</span><span class="hljs-comment">#acl normal proxy_auth REQUIRED</span><span class="hljs-comment">#http_access allow normal</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Squid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【vue系列】安装nodejs</title>
    <link href="/2017/04/21/vue/"/>
    <url>/2017/04/21/vue/</url>
    
    <content type="html"><![CDATA[<p>去官网下载安装包</p><h2 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h2><pre><code class="hljs undefined">npm install xxx <span class="hljs-string">//</span> 安装模块npm install xxx -g  <span class="hljs-string">//</span> 将模块安装到全局环境中 参考http:<span class="hljs-string">//goddyzhao.tumblr.com/post/9835631010/no-direct-command-for-local-installed-command-line-modul</span>npm <span class="hljs-keyword">ls</span> <span class="hljs-string">//</span> 查看安装的模块及依赖npm <span class="hljs-keyword">ls</span> -g <span class="hljs-string">//</span> 查看全局安装的模块及依赖npm uninstall xxx  <span class="hljs-params">(-g)</span> <span class="hljs-string">//</span> 卸载模块npm cache clean <span class="hljs-string">//</span> 清理缓存</code></pre><h2 id="淘宝npm源"><a href="#淘宝npm源" class="headerlink" title="淘宝npm源"></a>淘宝npm源</h2><pre><code class="hljs undefined">$ <span class="hljs-built_in">npm</span> install -g cnpm --registry=https://registry.<span class="hljs-built_in">npm</span>.taobao.org</code></pre><p>然后就可以使用<code>cnpm</code></p><h2 id="使用webpack-server"><a href="#使用webpack-server" class="headerlink" title="使用webpack server"></a>使用webpack server</h2><pre><code class="hljs undefined"><span class="hljs-string">./node_modules/.bin/webpack-dev-server</span> <span class="hljs-params">--progress</span> <span class="hljs-params">--colors</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端框架</title>
    <link href="/2016/10/19/front-framework/"/>
    <url>/2016/10/19/front-framework/</url>
    
    <content type="html"><![CDATA[<h2 id="Semantic-UI"><a href="#Semantic-UI" class="headerlink" title="Semantic UI"></a>Semantic UI</h2><p>Semantic UI—完全语义化的前端界面开发框架，跟 Bootstrap 和 Foundation 比起来，还是有些不同的，在功能特性上、布局设计上、用户体验上均存在很多差异。</p><p>Semantic UI 特点：</p><ul><li>文档和演示非常完善</li><li>易于学习和使用</li><li>配备网格布局</li><li>支持 Sass 和 LESS 动态样式语言</li><li>有一些非常实用的附加配置，例如inverted类。</li><li>对于社区贡献来说是比较开放的。</li><li>有一个非常好的按钮实现，情态动词，和进度条。</li><li>在许多功能上使用图标字体。</li></ul><p>Semantic UI 对浏览器的支持：</p><ul><li>Last 2 Versions FF, Chrome, IE (aka 10+)</li><li>Safari 6</li><li>IE 9+ (Browser prefix only)</li><li>Android 4</li><li>Blackberry 10</li></ul><p><img src="http://static.oschina.net/uploads/space/2013/1008/140748_1T9v_119807.jpg" srcset="/img/loading.gif" alt="Semantic UI"></p><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>Bootstrap是快速开发Web应用程序的前端工具包。它是一个CSS和HTML的集合，它使用了最新的浏览器技术，给你的Web开发提供了时尚的版式，表单，buttons，表格，网格系统等等。</p><h2 id="EasyUI"><a href="#EasyUI" class="headerlink" title="EasyUI"></a>EasyUI</h2><p>jQuery EasyUI 为网页开发提供了一堆的常用UI组件，包括菜单、对话框、布局、窗帘、表格、表单等等组件。</p><p>下图是一个具有布局效果的窗口：</p><h2 id="Extjs"><a href="#Extjs" class="headerlink" title="Extjs"></a>Extjs</h2><p>ExtJS 主要用来开发RIA富客户端的AJAX应用，主要用于创建前端用户界面，与后台技术无关的前端ajax框架。因此，可以把ExtJS用在.Net、Java、Php等各种开发语言开发的应用中。ExtJs最开始基于YUI技术，由开发人员 JackSlocum开发，通过参考JavaSwing等机制来组织可视化组件，无论从UI界面上CSS样式的应用，到数据解析上的异常处理，都可算是一 款不可多得的JavaScript客户端技术的精品。</p><p>Ext的UI组件模型和开发理念脱胎、成型于Yahoo组件库YUI和Java平台上Swing两者，并为开发者屏蔽了大量跨浏览器方面的处理。相对来说，EXT要比开发者直接针对DOM、W3C对象模型开发UI组件轻松。</p><p>特点如下：</p><ul><li>高性能, customizable UI widgets</li><li>Well designed, documented and extensible Component model</li><li>Commercial and Open Source licenses available</li><li></li></ul><h2 id="Amaze-UI"><a href="#Amaze-UI" class="headerlink" title="Amaze UI"></a>Amaze UI</h2><p> Amaze UI是国内首款Html5开源跨屏前端框架，优秀开源前端框架，拥有丰富的CSS+JS组件。轻量级高性能开源框架，以移动优先（Mobile first）为理念，从小屏逐步扩展到大屏，最终实现所有屏幕适配，适应移动互联潮流；面向 HTML5 开发，使用 CSS3 来做动画交互，平滑、高效，更适合移动设备，让 Web 应用更快速载；含近 20 个 CSS 组件、10 个 JS 组件，更有 17 款包含近 60 个主题的 Web 组件，可快速构建界面出色、体验优秀的跨屏页面，大幅提升开发效率；相比国外框架，Amaze UI 关注中文排版，根据用户代理调整字体，实现更好的中文排版效果；兼顾国内主流浏览器及 App 内置浏览器兼容支持。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2016/07/19/hashmap/"/>
    <url>/2016/07/19/hashmap/</url>
    
    <content type="html"><![CDATA[<blockquote><p>代码基于JDK 1.8</p></blockquote><h2 id="基数知识"><a href="#基数知识" class="headerlink" title="基数知识"></a>基数知识</h2><p>Map是保存了Key-Value键值对的数据集合接口。HashMap是基于HashCode的Map实现。因为基于Key的HashCode进行存储，所以HashMap中Key都是唯一的。</p><ul><li><strong>HashMap中Key，Value均可以为null。</strong></li></ul><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><ul><li><code>Map</code> -  <code>AbstractMap&lt;K,V&gt;</code>本身实现了<code>Map&lt;K,V&gt;</code>接口，在这里再次强调了<code>HashMap</code>实现了<code>Map</code></li><li><code>Cloneable</code>  实现了克隆接口</li><li><code>Serializable</code>  实现了序列化接口</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre><code class="hljs java"><span class="hljs-comment">/** * table, 在初次使用时进行初始化, 必要时进行大小调整。 * 在分配大小时，长度总是 2的幂 */</span><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="hljs-comment">// Node静态内部类，链表数据结构</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    V value;    Node&lt;K, V&gt; next;    Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;        <span class="hljs-keyword">this</span>.hash = hash;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;        <span class="hljs-keyword">this</span>.next = next;    &#125;&#125;</code></pre><p>上面代码描述了<code>HashMap</code>的底层数据结构：<code>数组</code> + <code>链表</code>。</p><blockquote><p><em>在1.8中，增加了红黑树，带详细研究…</em></p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>对于构造函数，提供了多个重载，以方便创建实例：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span></span></code></pre><p>在构造函数中，<code>initialCapacity</code>和<code>loadFactor</code>两个参数对map的性能有很大的影响。</p><ul><li><code>initialCapacity</code>: 初始化大小， 即<code>table</code>数组的长度，如果此值太小，可能会因引起<code>table</code>频繁调整数组大小，如果太大，实际内容很少，则造成资源浪费，默认 1 &lt;&lt; 4。</li><li><code>loadFactor</code>: 加载因子，取值范围（0,1）的浮点数，如果此值太小，可能会因引起<code>table</code>频繁调整数组大小，如果太大，<code>table</code>大小很长时间不调整，调整时内容移动大。默认值0.75</li></ul><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; h;</code></pre><p>计算key在table中的索引,h为key的hashcode，n为当前table的大小。</p><p>HashMap为非线程安全Map，其中key和value均可以为null。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
